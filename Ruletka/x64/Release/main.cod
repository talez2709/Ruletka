; Listing generated by Microsoft (R) Optimizing Compiler Version 19.11.25547.0 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BC@EOODALEL@Unknown?5exception?$AA@	; `string'
PUBLIC	??_C@_08EPJLHIJG@bad?5cast?$AA@			; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_06JGCGFIEG@polish?$AA@			; `string'
PUBLIC	??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@		; `string'
PUBLIC	??_C@_05PDJBBECF@pause?$AA@			; `string'
PUBLIC	??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@ ; `string'
PUBLIC	??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@		; `string'
PUBLIC	??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@	; `string'
PUBLIC	??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@ ; `string'
PUBLIC	??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ ; `string'
PUBLIC	??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@	; `string'
PUBLIC	??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ ; `string'
PUBLIC	??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@ ; `string'
PUBLIC	??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@ ; `string'
PUBLIC	??_C@_01JBBJJEPG@p?$AA@				; `string'
PUBLIC	??_C@_01EFFIKLCJ@n?$AA@				; `string'
PUBLIC	??_C@_01KDCPPGHE@r?$AA@				; `string'
PUBLIC	??_C@_01OJONOECF@b?$AA@				; `string'
PUBLIC	??_C@_01JEJKBAGA@g?$AA@				; `string'
PUBLIC	??_C@_01LPLHEDKD@d?$AA@				; `string'
PUBLIC	??_C@_02ICGBAFJO@k1?$AA@			; `string'
PUBLIC	??_C@_02KJEMFGFN@k2?$AA@			; `string'
PUBLIC	??_C@_02LAFHGHBM@k3?$AA@			; `string'
PUBLIC	??_C@_02JHFNFPIK@w1?$AA@			; `string'
PUBLIC	??_C@_02LMHAAMEJ@w2?$AA@			; `string'
PUBLIC	??_C@_02KFGLDNAI@w3?$AA@			; `string'
PUBLIC	??_C@_02OKCKKLMP@w4?$AA@			; `string'
PUBLIC	??_C@_02PDDBJKIO@w5?$AA@			; `string'
PUBLIC	??_C@_02NIBMMJEN@w6?$AA@			; `string'
PUBLIC	??_C@_02MBAHPIAM@w7?$AA@			; `string'
PUBLIC	??_C@_02EGJPOEMD@w8?$AA@			; `string'
PUBLIC	??_C@_02FPIENFIC@w9?$AA@			; `string'
PUBLIC	??_C@_03NCLMABJC@w10?$AA@			; `string'
PUBLIC	??_C@_03MLKHDAND@w11?$AA@			; `string'
PUBLIC	??_C@_03OAIKGDBA@w12?$AA@			; `string'
PUBLIC	??_C@_01GBGANLPD@0?$AA@				; `string'
PUBLIC	??_C@_01HIHLOKLC@1?$AA@				; `string'
PUBLIC	??_C@_01FDFGLJHB@2?$AA@				; `string'
PUBLIC	??_C@_01EKENIIDA@3?$AA@				; `string'
PUBLIC	??_C@_01FAMBOPH@4?$AA@				; `string'
PUBLIC	??_C@_01BMBHCPLG@5?$AA@				; `string'
PUBLIC	??_C@_01DHDKHMHF@6?$AA@				; `string'
PUBLIC	??_C@_01COCBENDE@7?$AA@				; `string'
PUBLIC	??_C@_01KJLJFBPL@8?$AA@				; `string'
PUBLIC	??_C@_01LAKCGALK@9?$AA@				; `string'
PUBLIC	??_C@_02PKFBJPLJ@10?$AA@			; `string'
PUBLIC	??_C@_02ODEKKOPI@11?$AA@			; `string'
PUBLIC	??_C@_02MIGHPNDL@12?$AA@			; `string'
PUBLIC	??_C@_02NBHMMMHK@13?$AA@			; `string'
PUBLIC	??_C@_02JODNFKLN@14?$AA@			; `string'
PUBLIC	??_C@_02IHCGGLPM@15?$AA@			; `string'
PUBLIC	??_C@_02KMALDIDP@16?$AA@			; `string'
PUBLIC	??_C@_02LFBAAJHO@17?$AA@			; `string'
PUBLIC	??_C@_02DCIIBFLB@18?$AA@			; `string'
PUBLIC	??_C@_02CLJDCEPA@19?$AA@			; `string'
PUBLIC	??_C@_02PIBHCBOA@20?$AA@			; `string'
PUBLIC	??_C@_02OBAMBAKB@21?$AA@			; `string'
PUBLIC	??_C@_02MKCBEDGC@22?$AA@			; `string'
PUBLIC	??_C@_02NDDKHCCD@23?$AA@			; `string'
PUBLIC	??_C@_02JMHLOEOE@24?$AA@			; `string'
PUBLIC	??_C@_02IFGANFKF@25?$AA@			; `string'
PUBLIC	??_C@_02KOENIGGG@26?$AA@			; `string'
PUBLIC	??_C@_02LHFGLHCH@27?$AA@			; `string'
PUBLIC	??_C@_02DAMOKLOI@28?$AA@			; `string'
PUBLIC	??_C@_02CJNFJKKJ@29?$AA@			; `string'
PUBLIC	??_C@_02PJNFELNH@30?$AA@			; `string'
PUBLIC	??_C@_02OAMOHKJG@31?$AA@			; `string'
PUBLIC	??_C@_02MLODCJFF@32?$AA@			; `string'
PUBLIC	??_C@_02NCPIBIBE@33?$AA@			; `string'
PUBLIC	??_C@_02JNLJIOND@34?$AA@			; `string'
PUBLIC	??_C@_02IEKCLPJC@35?$AA@			; `string'
PUBLIC	??_C@_02KPIPOMFB@36?$AA@			; `string'
PUBLIC	??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@ ; `string'
PUBLIC	??_C@_05OMMBNPEF@Masz?5?$AA@			; `string'
PUBLIC	??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ ; `string'
PUBLIC	??_C@_01PBGHHLMH@?$AH?$AA@			; `string'
PUBLIC	??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ ; `string'
PUBLIC	??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ ; `string'
PUBLIC	??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ ; `string'
PUBLIC	??_C@_02MGHEPNFN@?$AI?$AI?$AA@			; `string'
PUBLIC	??_C@_02KNHHEEKP@?5?5?$AA@			; `string'
PUBLIC	??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@	; `string'
PUBLIC	??_C@_02KHOJGJKF@?4?5?$AA@			; `string'
PUBLIC	??_C@_02DEPNMBPN@$?4?$AA@			; `string'
PUBLIC	??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@ ; `string'
PUBLIC	??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@ ; `string'
PUBLIC	??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@ ; `string'
PUBLIC	??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ ; `string'
PUBLIC	??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@ ; `string'
PUBLIC	??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@	; `string'
PUBLIC	??_C@_01PFHFFBPC@t?$AA@				; `string'
PUBLIC	??_C@_03PFPKAEFD@tak?$AA@			; `string'
PUBLIC	??_C@_03FFMIKLGN@Tak?$AA@			; `string'
PUBLIC	??_C@_03PIABMJCP@TAK?$AA@			; `string'
PUBLIC	??_C@_03FKMOMPJO@nie?$AA@			; `string'
PUBLIC	??_C@_03PKPMGAKA@Nie?$AA@			; `string'
PUBLIC	??_C@_03FHDFACOC@NIE?$AA@			; `string'
PUBLIC	??_C@_04IBLEHOMF@?4wav?$AA@			; `string'
PUBLIC	??_C@_05PNHGCFLK@p?4wav?$AA@			; `string'
PUBLIC	??_C@_05MEKKEGFB@n?4wav?$AA@			; `string'
PUBLIC	??_C@_05LALOIELB@r?4wav?$AA@			; `string'
PUBLIC	??_C@_05LDGIIGCK@b?4wav?$AA@			; `string'
PUBLIC	??_C@_05ODKFBHJJ@g?4wav?$AA@			; `string'
PUBLIC	??_C@_05GFDBGFDH@d?4wav?$AA@			; `string'
PUBLIC	??_C@_01DICPFPGM@k?$AA@				; `string'
PUBLIC	??_C@_01NOFIACDB@w?$AA@				; `string'
PUBLIC	??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@	; `string'
PUBLIC	??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ ; `string'
PUBLIC	??_C@_09LFKNBKJA@Posiadasz?$AA@			; `string'
PUBLIC	??_C@_0L@DAFLKCID@Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@		; `string'
PUBLIC	??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@	; `string'
PUBLIC	??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@		; `string'
PUBLIC	??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@	; `string'
PUBLIC	??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@		; `string'
PUBLIC	??_C@_01LFCBOECM@?4?$AA@			; `string'
PUBLIC	??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@	; `string'
PUBLIC	??_C@_01JLIPDDHJ@?3?$AA@			; `string'
PUBLIC	??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ ; `string'
PUBLIC	??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ ; `string'
PUBLIC	??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ ; `string'
PUBLIC	??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ ; `string'
PUBLIC	??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ ; `string'
PUBLIC	??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ ; `string'
PUBLIC	??_C@_05CMOJBPHN@G?$LDos?1?$AA@			; `string'
PUBLIC	??_C@_05KFCKMKOB@Jacek?$AA@			; `string'
PUBLIC	??_C@_03FPCJKMNP@Ewa?$AA@			; `string'
PUBLIC	??_C@_04CDICBAGM@Maja?$AA@			; `string'
PUBLIC	??_C@_03JIHJHPIE@Jan?$AA@			; `string'
PUBLIC	??_C@_06DKNIKMFF@Jacek2?$AA@			; `string'
PUBLIC	??_C@_04PLEDLCJI@Ewa2?$AA@			; `string'
PUBLIC	??_C@_05KJFHPLBC@Maja2?$AA@			; `string'
PUBLIC	??_C@_04HDNGKDH@Jan2?$AA@			; `string'
PUBLIC	??_C@_05NKPCGME@Agata?$AA@			; `string'
PUBLIC	??_C@_01IDAFKMJL@_?$AA@				; `string'
PUBLIC	??_C@_01KMDKNFGN@?1?$AA@			; `string'
PUBLIC	??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ ; `string'
PUBLIC	??_C@_04JLFAMLOH@G?$LDos?$AA@			; `string'
PUBLIC	??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ ; `string'
PUBLIC	??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ ; `string'
PUBLIC	??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ ; `string'
PUBLIC	??_C@_0M@COFBHHKL@setting?4txt?$AA@		; `string'
PUBLIC	??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ ; `string'
PUBLIC	??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ ; `string'
PUBLIC	??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ ; `string'
PUBLIC	??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ ; `string'
PUBLIC	??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ ; `string'
PUBLIC	??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ ; `string'
PUBLIC	??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@	; `string'
PUBLIC	??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@	; `string'
PUBLIC	??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ ; `string'
PUBLIC	??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ ; `string'
PUBLIC	??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@	; `string'
PUBLIC	??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ ; `string'
PUBLIC	??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ ; `string'
PUBLIC	??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ ; `string'
PUBLIC	??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ ; `string'
PUBLIC	??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ ; `string'
PUBLIC	??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ ; `string'
PUBLIC	??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ ; `string'
PUBLIC	??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ ; `string'
PUBLIC	??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ ; `string'
PUBLIC	??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ ; `string'
PUBLIC	??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ ; `string'
PUBLIC	??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ ; `string'
PUBLIC	??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ ; `string'
PUBLIC	??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ ; `string'
PUBLIC	??_C@_01EPMOAMKG@$?$AA@				; `string'
PUBLIC	??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@		; `string'
PUBLIC	??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@		; `string'
PUBLIC	??_C@_07KIPBKJCE@win?4wav?$AA@			; `string'
PUBLIC	??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ ; `string'
PUBLIC	??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@		; `string'
PUBLIC	??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ ; `string'
PUBLIC	??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ ; `string'
PUBLIC	??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ ; `string'
PUBLIC	??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ ; `string'
PUBLIC	??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@		; `string'
PUBLIC	??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@	; `string'
PUBLIC	??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@	; `string'
PUBLIC	??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ ; `string'
PUBLIC	??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@		; `string'
PUBLIC	??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ ; `string'
PUBLIC	??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ ; `string'
PUBLIC	??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ ; `string'
PUBLIC	??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ ; `string'
PUBLIC	??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@	; `string'
PUBLIC	??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@	; `string'
PUBLIC	??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@	; `string'
PUBLIC	??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@	; `string'
PUBLIC	??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@	; `string'
PUBLIC	??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ ; `string'
PUBLIC	??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@	; `string'
PUBLIC	??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ ; `string'
PUBLIC	??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@	; `string'
PUBLIC	??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4exception@std@@6B@				; std::exception::`RTTI Complete Object Locator'
PUBLIC	?czy_kontynuowaæ_grê@@3FA			; czy_kontynuowaæ_grê
PUBLIC	??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA	; iloœæ_max_dodatkowych_obrotów_ruletki
PUBLIC	?iloœæ_minimalna_obrotów_ruletki@@3FA		; iloœæ_minimalna_obrotów_ruletki
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?efekty_dŸwiêkowe@@3FA				; efekty_dŸwiêkowe
PUBLIC	?kwota_pocz¹tkowa@@3HA				; kwota_pocz¹tkowa
PUBLIC	?g³os_szybkoœæ_odczytu_numeru@@3FA		; g³os_szybkoœæ_odczytu_numeru
PUBLIC	??_R1A@?0A@EA@bad_cast@std@@8			; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
PUBLIC	??_R0?AVios_base@std@@@8			; std::ios_base `RTTI Type Descriptor'
PUBLIC	??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?stan_dŸwiêków@@3FA				; stan_dŸwiêków
PUBLIC	??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R17A@3EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R1A@?0A@EA@exception@std@@8			; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	?czas_przeskoku_kulki_wolny@@3FA		; czas_przeskoku_kulki_wolny
PUBLIC	??_R0?AV?$_Iosb@H@std@@@8			; std::_Iosb<int> `RTTI Type Descriptor'
PUBLIC	??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	?styl_liczenia_wygranej@@3FA			; styl_liczenia_wygranej
PUBLIC	??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2bad_cast@std@@8				; std::bad_cast::`RTTI Base Class Array'
PUBLIC	??_R2exception@std@@8				; std::exception::`RTTI Base Class Array'
PUBLIC	??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_7bad_cast@std@@6B@				; std::bad_cast::`vftable'
PUBLIC	??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?czas_przeskoku_kulki_szybki@@3FA		; czas_przeskoku_kulki_szybki
PUBLIC	?g³os_odczytu_numeru@@3FA			; g³os_odczytu_numeru
PUBLIC	??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R0?AVbad_cast@std@@@8			; std::bad_cast `RTTI Type Descriptor'
PUBLIC	_CTA2?AVbad_cast@std@@
PUBLIC	??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7exception@std@@6B@				; std::exception::`vftable'
PUBLIC	?EfektyKompletne@@3_NA				; EfektyKompletne
PUBLIC	_TI2?AVbad_cast@std@@
PUBLIC	??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
PUBLIC	??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R3exception@std@@8				; std::exception::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
PUBLIC	??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R1A@?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
PUBLIC	?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
PUBLIC	?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
PUBLIC	??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3bad_cast@std@@8				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
PUBLIC	??_R4bad_cast@std@@6B@				; std::bad_cast::`RTTI Complete Object Locator'
PUBLIC	_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
PUBLIC	??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	?Czas@@3U_SYSTEMTIME@@A				; Czas
PUBLIC	??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
PUBLIC	??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	?G³osyKompletne@@3_NA				; G³osyKompletne
PUBLIC	??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
PUBLIC	??_R2ios_base@std@@8				; std::ios_base::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
PUBLIC	??_R3ios_base@std@@8				; std::ios_base::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
PUBLIC	??_R2?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Base Class Array'
PUBLIC	_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
PUBLIC	??_R1A@A@3EA@ios_base@std@@8			; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
PUBLIC	??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
PUBLIC	??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
PUBLIC	??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
PUBLIC	??_R3?$_Iosb@H@std@@8				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
PUBLIC	??_R0?AVexception@std@@@8			; std::exception `RTTI Type Descriptor'
PUBLIC	??_R17?0A@EA@?$_Iosb@H@std@@8			; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
PUBLIC	?czas_przerwy_dzwiêku@@3FA			; czas_przerwy_dzwiêku
PUBLIC	??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8	; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
EXTRN	__imp_??Bid@locale@std@@QEAA_KXZ:PROC
EXTRN	__imp_?always_noconv@codecvt_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?is@?$ctype@D@std@@QEBA_NFD@Z:PROC
EXTRN	__imp_?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?rdstate@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?good@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?eof@ios_base@std@@QEBA_NXZ:PROC
EXTRN	__imp_?flags@ios_base@std@@QEBAHXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEBA_JXZ:PROC
EXTRN	__imp_?width@ios_base@std@@QEAA_J_J@Z:PROC
EXTRN	__imp_?getloc@ios_base@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z:PROC
EXTRN	__imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z:PROC
EXTRN	__imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::imbue
EXTRN	__imp_?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z:PROC
EXTRN	?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::sync
EXTRN	__imp_?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::setbuf
EXTRN	__imp_?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z:PROC
EXTRN	?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsputn
EXTRN	__imp_?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z:PROC
EXTRN	?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC ; std::basic_streambuf<char,std::char_traits<char> >::xsgetn
EXTRN	__imp_?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z:PROC
EXTRN	?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::uflow
EXTRN	__imp_?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ:PROC
EXTRN	?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::showmanyc
EXTRN	__imp_?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ:PROC
EXTRN	?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Unlock
EXTRN	__imp_?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC ; std::basic_streambuf<char,std::char_traits<char> >::_Lock
EXTRN	__imp_?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ:PROC
EXTRN	__imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ:PROC
EXTRN	__imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z:PROC
EXTRN	__imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z:PROC
EXTRN	__imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z:PROC
EXTRN	__imp_?_Pninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?setp@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD0@Z:PROC
EXTRN	__imp_?pbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?_Gninc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?_Gndec@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAPEADXZ:PROC
EXTRN	__imp_?epptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?setg@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAD00@Z:PROC
EXTRN	__imp_?gbump@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXH@Z:PROC
EXTRN	__imp_?egptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?pbase@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?gptr@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_?eback@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEBAPEADXZ:PROC
EXTRN	__imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?fill@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADXZ:PROC
EXTRN	__imp_?rdbuf@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z:PROC
EXTRN	__imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z:PROC
EXTRN	__imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXPEAPEAD0PEAH001@Z:PROC
EXTRN	__imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ:PROC
EXTRN	__imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ:PROC
EXTRN	__imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ:PROC
EXTRN	__imp_?tie@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBAPEAV?$basic_ostream@DU?$char_traits@D@std@@@2@XZ:PROC
EXTRN	__imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z:PROC
EXTRN	__imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z:PROC
EXTRN	__imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z:PROC
EXTRN	__imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z:PROC
EXTRN	__imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z:PROC
EXTRN	__imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ:PROC
EXTRN	__imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z:PROC
EXTRN	__imp__get_stream_buffer_pointers:PROC
EXTRN	__imp__invalid_parameter_noinfo_noreturn:PROC
EXTRN	__imp__fseeki64:PROC
EXTRN	??_7type_info@@6B@:BYTE				; type_info::`vftable'
EXTRN	__imp_GetSystemTime:PROC
EXTRN	__imp_CreateDirectoryA:PROC
EXTRN	__imp_fsetpos:PROC
EXTRN	__imp___std_terminate:PROC
EXTRN	__imp_ungetc:PROC
EXTRN	__imp_atoi:PROC
EXTRN	__imp__time64:PROC
EXTRN	__imp_memchr:PROC
EXTRN	__imp_setvbuf:PROC
EXTRN	__imp_fgetpos:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp__lock_file:PROC
EXTRN	__imp__unlock_file:PROC
EXTRN	__imp_SetConsoleCursorInfo:PROC
EXTRN	__imp__access:PROC
EXTRN	__imp_system:PROC
EXTRN	__imp_Sleep:PROC
EXTRN	__imp_PlaySoundA:PROC
EXTRN	??3@YAXPEAX_K@Z:PROC				; operator delete
EXTRN	??3@YAXPEAX@Z:PROC				; operator delete
EXTRN	__imp__invalid_parameter_noinfo:PROC
EXTRN	__imp_fgetc:PROC
EXTRN	atexit:PROC
EXTRN	__imp_rand:PROC
EXTRN	__imp___std_exception_copy:PROC
EXTRN	__imp_URLDownloadToFileA:PROC
EXTRN	__imp_remove:PROC
EXTRN	__imp_?_Xlength_error@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Random_device@std@@YAIXZ:PROC
EXTRN	__imp_?id@?$ctype@D@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z:PROC
EXTRN	?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z:PROC ; std::_Facet_Register
EXTRN	__imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A:QWORD
EXTRN	__imp_?_BADOFF@std@@3_JB:QWORD
EXTRN	__imp_?_Xout_of_range@std@@YAXPEBD@Z:PROC
EXTRN	__imp_?_Xbad_alloc@std@@YAXXZ:PROC
EXTRN	__imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_?uncaught_exception@std@@YA_NXZ:PROC
EXTRN	__imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ:PROC
EXTRN	__imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A:BYTE
EXTRN	__imp_??0_Lockit@std@@QEAA@H@Z:PROC
EXTRN	__imp_??1_Lockit@std@@QEAA@XZ:PROC
EXTRN	__imp_fclose:PROC
EXTRN	??2@YAPEAX_K@Z:PROC				; operator new
EXTRN	__imp_fflush:PROC
EXTRN	__imp_GetConsoleCursorInfo:PROC
EXTRN	__imp_srand:PROC
EXTRN	__imp_GetStdHandle:PROC
EXTRN	__imp_SetConsoleTextAttribute:PROC
EXTRN	__imp_memmove:PROC
EXTRN	__imp_fputc:PROC
EXTRN	__imp_setlocale:PROC
EXTRN	__imp___std_exception_destroy:PROC
EXTRN	__security_check_cookie:PROC
EXTRN	__imp___CxxFrameHandler3:PROC
;	COMDAT ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
_BSS	ENDS
;	COMDAT ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB
_BSS	SEGMENT
?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB DQ 01H DUP (?) ; std::_Facetptr<std::ctype<char> >::_Psave
?Czas@@3U_SYSTEMTIME@@A DB 010H DUP (?)			; Czas
_BSS	ENDS
;	COMDAT ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@ios_base@std@@8
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R17?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,-1,0,64)'
	DD	00H
	DD	08H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AVexception@std@@@8
data$r	SEGMENT
??_R0?AVexception@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::exception `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVexception@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R3?$_Iosb@H@std@@8 DD 00H				; std::_Iosb<int>::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	02H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@A@3EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,0,4,64)'
	DD	01H
	DD	00H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0exception@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R2?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R2?$_Iosb@H@std@@8 DD imagerel ??_R1A@?0A@EA@?$_Iosb@H@std@@8 ; std::_Iosb<int>::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ifstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3ios_base@std@@8
rdata$r	SEGMENT
??_R3ios_base@std@@8 DD 00H				; std::ios_base::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	098H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	08H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2ios_base@std@@8
rdata$r	SEGMENT
??_R2ios_base@std@@8 DD imagerel ??_R1A@?0A@EA@ios_base@std@@8 ; std::ios_base::`RTTI Base Class Array'
	DD	imagerel ??_R17?0A@EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ios<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,0,4,80)'
	DD	02H
	DD	00H
	DD	00H
	DD	04H
	DD	050H
	DD	imagerel ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_filebuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0b8H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	098H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DD 01H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
	DD	imagerel ??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
rdata$r	ENDS
;	COMDAT _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
xdata$x	SEGMENT
_CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24 DD 00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	00H
	DD	0ffffffffH
	ORG $+4
	DD	018H
	DD	imagerel ??0bad_cast@std@@QEAA@AEBV01@@Z
xdata$x	ENDS
;	COMDAT ??_R4bad_cast@std@@6B@
rdata$r	SEGMENT
??_R4bad_cast@std@@6B@ DD 01H				; std::bad_cast::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVbad_cast@std@@@8
	DD	imagerel ??_R3bad_cast@std@@8
	DD	imagerel ??_R4bad_cast@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3bad_cast@std@@8
rdata$r	SEGMENT
??_R3bad_cast@std@@8 DD 00H				; std::bad_cast::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB
CONST	SEGMENT
?npos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@2_KB DQ ffffffffffffffffH ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::npos
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`vbtable'
	DD	0b0H
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_fstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ios@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ios<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ios@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_filebuf<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_filebuf@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3exception@std@@8
rdata$r	SEGMENT
??_R3exception@std@@8 DD 00H				; std::exception::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	01H
	DD	imagerel ??_R2exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@ios_base@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@ios_base@std@@8 DD imagerel ??_R0?AVios_base@std@@@8 ; std::ios_base::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3ios_base@std@@8
rdata$r	ENDS
;	COMDAT ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0b0H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_istream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_istream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ostream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (16,-1,0,64)'
	DD	03H
	DD	010H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT _TI2?AVbad_cast@std@@
xdata$x	SEGMENT
_TI2?AVbad_cast@std@@ DD 00H
	DD	imagerel ??1bad_cast@std@@UEAA@XZ
	DD	00H
	DD	imagerel _CTA2?AVbad_cast@std@@
xdata$x	ENDS
;	COMDAT ??_7exception@std@@6B@
CONST	SEGMENT
??_7exception@std@@6B@ DQ FLAT:??_R4exception@std@@6B@	; std::exception::`vftable'
	DQ	FLAT:??_Eexception@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
CONST	SEGMENT
??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ DQ FLAT:??_R4?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vftable'
	DQ	FLAT:??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAPEAV12@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT _CTA2?AVbad_cast@std@@
xdata$x	SEGMENT
_CTA2?AVbad_cast@std@@ DD 02H
	DD	imagerel _CT??_R0?AVbad_cast@std@@@8??0bad_cast@std@@QEAA@AEBV01@@Z24
	DD	imagerel _CT??_R0?AVexception@std@@@8??0exception@std@@QEAA@AEBV01@@Z24
xdata$x	ENDS
;	COMDAT ??_R0?AVbad_cast@std@@@8
data$r	SEGMENT
??_R0?AVbad_cast@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::bad_cast `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVbad_cast@std@@', 00H
data$r	ENDS
;	COMDAT ??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
CONST	SEGMENT
??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@ DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
CONST	ENDS
;	COMDAT ??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ios@DU?$char_traits@D@std@@@std@@8 DD 00H	; std::basic_ios<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	03H
	DD	imagerel ??_R2?$basic_ios@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_7bad_cast@std@@6B@
CONST	SEGMENT
??_7bad_cast@std@@6B@ DQ FLAT:??_R4bad_cast@std@@6B@	; std::bad_cast::`vftable'
	DQ	FLAT:??_Ebad_cast@std@@UEAAPEAXI@Z
	DQ	FLAT:?what@exception@std@@UEBAPEBDXZ
CONST	ENDS
;	COMDAT ??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ostream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ostream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2exception@std@@8
rdata$r	SEGMENT
??_R2exception@std@@8 DD imagerel ??_R1A@?0A@EA@exception@std@@8 ; std::exception::`RTTI Base Class Array'
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R2bad_cast@std@@8
rdata$r	SEGMENT
??_R2bad_cast@std@@8 DD imagerel ??_R1A@?0A@EA@bad_cast@std@@8 ; std::bad_cast::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@exception@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R3?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD 00H ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	02H
	DD	imagerel ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_streambuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ofstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_ofstream<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
CONST	ENDS
;	COMDAT ??_R0?AV?$_Iosb@H@std@@@8
data$r	SEGMENT
??_R0?AV?$_Iosb@H@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::_Iosb<int> `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$_Iosb@H@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbtable'
	DD	088H
CONST	ENDS
;	COMDAT ??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
CONST	SEGMENT
??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ DQ FLAT:??_R4?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@ ; std::basic_filebuf<char,std::char_traits<char> >::`vftable'
	DQ	FLAT:??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DQ	FLAT:?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
	DQ	FLAT:?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DQ	FLAT:?showmanyc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JXZ
	DQ	FLAT:?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?xsgetn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEAD_J@Z
	DQ	FLAT:?xsputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@MEAA_JPEBD_J@Z
	DQ	FLAT:?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
	DQ	FLAT:?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
	DQ	FLAT:?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
	DQ	FLAT:?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DQ	FLAT:?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
CONST	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_streambuf@DU?$char_traits@D@std@@@std@@@8 ; std::basic_streambuf<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@exception@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@exception@std@@8 DD imagerel ??_R0?AVexception@std@@@8 ; std::exception::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	00H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3exception@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	09H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	ENDS
;	COMDAT ??_R17A@3EA@?$_Iosb@H@std@@8
rdata$r	SEGMENT
??_R17A@3EA@?$_Iosb@H@std@@8 DD imagerel ??_R0?AV?$_Iosb@H@std@@@8 ; std::_Iosb<int>::`RTTI Base Class Descriptor at (8,0,4,64)'
	DD	00H
	DD	08H
	DD	00H
	DD	04H
	DD	040H
	DD	imagerel ??_R3?$_Iosb@H@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_iostream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_iostream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	0aH
	DD	imagerel ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	04H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8
rdata$r	SEGMENT
??_R2?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@8 ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_streambuf@DU?$char_traits@D@std@@@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AVios_base@std@@@8
data$r	SEGMENT
??_R0?AVios_base@std@@@8 DQ FLAT:??_7type_info@@6B@	; std::ios_base `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AVios_base@std@@', 00H
data$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocato'
	DB	'r@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ifstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ifstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ifstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R1A@?0A@EA@bad_cast@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@bad_cast@std@@8 DD imagerel ??_R0?AVbad_cast@std@@@8 ; std::bad_cast::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3bad_cast@std@@8
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_ifstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_ifstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R0?AV?$basic_istream@DU?$char_traits@D@std@@@std@@@8 ; std::basic_istream<char,std::char_traits<char> >::`RTTI Base Class Descriptor at (0,-1,0,64)'
	DD	03H
	DD	00H
	DD	0ffffffffH
	DD	00H
	DD	040H
	DD	imagerel ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	05H
	DD	imagerel ??_R2?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
CONST	SEGMENT
??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@ DD 00H ; std::basic_fstream<char,std::char_traits<char> >::`vbtable'
	DD	0a8H
?Ruletka_ko³o@@3QBHB DD 00H				; Ruletka_ko³o
	DD	020H
	DD	0fH
	DD	013H
	DD	04H
	DD	015H
	DD	02H
	DD	019H
	DD	011H
	DD	022H
	DD	06H
	DD	01bH
	DD	0dH
	DD	024H
	DD	0bH
	DD	01eH
	DD	08H
	DD	017H
	DD	0aH
	DD	05H
	DD	018H
	DD	010H
	DD	021H
	DD	01H
	DD	014H
	DD	0eH
	DD	01fH
	DD	09H
	DD	016H
	DD	012H
	DD	01dH
	DD	07H
	DD	01cH
	DD	0cH
	DD	023H
	DD	03H
	DD	01aH
	ORG $+12
?Ruletka_plansza_kolor_col@@3QBHB DD 02H		; Ruletka_plansza_kolor_col
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	DD	08H
	DD	04H
	ORG $+4
?Ruletka_plansza_kolor@@3QBDB DB 067H			; Ruletka_plansza_kolor
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
	DB	062H
	DB	072H
CONST	ENDS
;	COMDAT ??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_fstream<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_fstream@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
rdata$r	SEGMENT
??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@ DD 01H ; std::basic_ofstream<char,std::char_traits<char> >::`RTTI Complete Object Locator'
	DD	0a8H
	DD	04H
	DD	imagerel ??_R0?AV?$basic_ofstream@DU?$char_traits@D@std@@@std@@@8
	DD	imagerel ??_R3?$basic_ofstream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R4?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
?czy_kontynuowaæ_grê@@3FA DW 01H			; czy_kontynuowaæ_grê
?EfektyKompletne@@3_NA DB 01H				; EfektyKompletne
?G³osyKompletne@@3_NA DB 01H				; G³osyKompletne
?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA DW 03H	; iloœæ_max_dodatkowych_obrotów_ruletki
	ORG $+2
?iloœæ_minimalna_obrotów_ruletki@@3FA DW 02H		; iloœæ_minimalna_obrotów_ruletki
	ORG $+2
?efekty_dŸwiêkowe@@3FA DW 01H				; efekty_dŸwiêkowe
	ORG $+2
?kwota_pocz¹tkowa@@3HA DD 03e8H				; kwota_pocz¹tkowa
?g³os_szybkoœæ_odczytu_numeru@@3FA DW 04H		; g³os_szybkoœæ_odczytu_numeru
	ORG $+2
?stan_dŸwiêków@@3FA DW 01H				; stan_dŸwiêków
	ORG $+2
?czas_przeskoku_kulki_wolny@@3FA DW 04bH		; czas_przeskoku_kulki_wolny
	ORG $+2
?styl_liczenia_wygranej@@3FA DW 01H			; styl_liczenia_wygranej
	ORG $+2
?czas_przeskoku_kulki_szybki@@3FA DW 032H		; czas_przeskoku_kulki_szybki
	ORG $+2
?g³os_odczytu_numeru@@3FA DW 01H			; g³os_odczytu_numeru
	ORG $+2
?czas_przerwy_dzwiêku@@3FA DW 01f4H			; czas_przerwy_dzwiêku
_DATA	ENDS
;	COMDAT ??_R4exception@std@@6B@
rdata$r	SEGMENT
??_R4exception@std@@6B@ DD 01H				; std::exception::`RTTI Complete Object Locator'
	DD	00H
	DD	00H
	DD	imagerel ??_R0?AVexception@std@@@8
	DD	imagerel ??_R3exception@std@@8
	DD	imagerel ??_R4exception@std@@6B@
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_filebuf<char,std::char_traits<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_filebuf@DU?$char_traits@D@std@@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R2?$basic_fstream@DU?$char_traits@D@std@@@std@@8 DD imagerel ??_R1A@?0A@EA@?$basic_fstream@DU?$char_traits@D@std@@@std@@8 ; std::basic_fstream<char,std::char_traits<char> >::`RTTI Base Class Array'
	DD	imagerel ??_R1A@?0A@EA@?$basic_iostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@?0A@EA@?$basic_istream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	DD	imagerel ??_R1BA@?0A@EA@?$basic_ostream@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3FA@?$basic_ios@DU?$char_traits@D@std@@@std@@8
	DD	imagerel ??_R1A@A@3EA@ios_base@std@@8
	DD	imagerel ??_R17A@3EA@?$_Iosb@H@std@@8
	ORG $+3
rdata$r	ENDS
;	COMDAT ??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8
data$r	SEGMENT
??_R0?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@8 DQ FLAT:??_7type_info@@6B@ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> > `RTTI Type Descriptor'
	DQ	0000000000000000H
	DB	'.?AV?$basic_stringstream@DU?$char_traits@D@std@@V?$alloc'
	DB	'ator@D@2@@std@@', 00H
data$r	ENDS
;	COMDAT ??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_iostream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_iostream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	03H
	DD	09H
	DD	imagerel ??_R2?$basic_iostream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	SEGMENT
??_R3?$basic_istream@DU?$char_traits@D@std@@@std@@8 DD 00H ; std::basic_istream<char,std::char_traits<char> >::`RTTI Class Hierarchy Descriptor'
	DD	00H
	DD	04H
	DD	imagerel ??_R2?$basic_istream@DU?$char_traits@D@std@@@std@@8
rdata$r	ENDS
;	COMDAT ??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
CONST	SEGMENT
??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@ DB 'string too long', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
CONST	SEGMENT
??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@ DB 'invalid string posi'
	DB	'tion', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@ DB 'g', 0b3H, 'o'
	DB	's_szybko', 09cH, 0e6H, '_odczytu_numeru', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
CONST	SEGMENT
??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@ DB 'g', 0b3H, 'os_odczytu_n'
	DB	'umeru', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
CONST	SEGMENT
??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@ DB 'czy_kontynuowa', 0e6H, '_'
	DB	'gr', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
CONST	SEGMENT
??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH, 'k'
	DB	0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
CONST	SEGMENT
??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@ DB 'kwota_pocz', 0b9H, 'tkowa'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
CONST	SEGMENT
??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@ DB 'styl_liczenia_wygranej'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
CONST	SEGMENT
??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@ DB 'czas_przeskoku_kul'
	DB	'ki_wolny', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
CONST	SEGMENT
??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@ DB 'czas_przeskoku_ku'
	DB	'lki_szybki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
CONST	SEGMENT
??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
CONST	SEGMENT
??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@ DB ' Wylosowano ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
CONST	SEGMENT
??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@ DB 'Kulka w gr'
	DB	'ze, zaczekaj na wylosowanie numeru...', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
CONST	SEGMENT
??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@ DB ' Obstawiono zaklad ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
CONST	SEGMENT
??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@ DB 'Obstawiono zak', 0b3H
	DB	'ad ', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
CONST	SEGMENT
??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@ DB 'Obstawiono za ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
CONST	SEGMENT
??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@ DB 'Gratuluje zwi'
	DB	0eaH, 'kszy', 0b3H, 'e', 09cH, ' ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
CONST	SEGMENT
??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@ DB ' krotnie '
	DB	'sw', 0f3H, 'j zas', 0f3H, 'b finansowy', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
CONST	SEGMENT
??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@ DB 'Grat'
	DB	'uluje zwi', 0eaH, 'kszy', 0b3H, 'e', 09cH, ' sw', 0f3H, 'j za'
	DB	's', 0f3H, 'b finansowy', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
CONST	SEGMENT
??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@ DB 'Ko', 0f1H, 'cz'
	DB	'ysz gr', 0eaH, ' z wynikiem ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
CONST	SEGMENT
??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@ DB ' Przegrales ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
CONST	SEGMENT
??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@ DB ' Dostajesz '
	DB	'polowe zak', 0b3H, 'adu ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_07KIPBKJCE@win?4wav?$AA@
CONST	SEGMENT
??_C@_07KIPBKJCE@win?4wav?$AA@ DB 'win.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@ DB ' Posiadasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
CONST	SEGMENT
??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@ DB ' Wygrywasz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01EPMOAMKG@$?$AA@
CONST	SEGMENT
??_C@_01EPMOAMKG@$?$AA@ DB '$', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czon', 0b9H, ' mo'
	DB	'w', 0eaH, 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
CONST	SEGMENT
??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@ DB 'N'
	DB	'ie mo', 0bfH, 'esz mie', 0e6H, ' wy', 0b3H, 0b9H, 'czonych d', 09fH
	DB	'wi', 0eaH, 'k', 0f3H, 'w i w', 0b3H, 0b9H, 'czonych efekt', 0f3H
	DB	'w d', 09fH, 'wi', 0eaH, 'kowych', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
CONST	SEGMENT
??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@ DB 'Opcja efe'
	DB	'kty d', 09fH, 'wi', 0eaH, 'kowe przyjmuje warto', 09cH, 'ci 0'
	DB	' lub 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
CONST	SEGMENT
??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@ DB 'Opcja'
	DB	' szybko', 09cH, 0e6H, ' g', 0b3H, 'osu odczytu przyjmuje wart'
	DB	'o', 09cH, 'ci w przedziale [1;5]', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
CONST	SEGMENT
??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@ DB 'Opcja g', 0b3H
	DB	'os odczytu numeru przyjmuje warto', 09cH, 'ci w przedziale [0'
	DB	';10]', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
CONST	SEGMENT
??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@ DB 'Opcja kontynu'
	DB	'owania gry przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
CONST	SEGMENT
??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@ DB 'Stan '
	DB	'd', 09fH, 'wi', 0eaH, 'k', 0f3H, 'w przyjmuje warto', 09cH, 'c'
	DB	'i tylko 0 lub 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
CONST	SEGMENT
??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@ DB 'Kwot'
	DB	'a pocz', 0b9H, 'tkowa nie mo', 0bfH, 'e by', 0e6H, ' mniejsza'
	DB	' od zera', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
CONST	SEGMENT
??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@ DB 'Czas'
	DB	' przerwy d', 09fH, 'wi', 0eaH, 'ku nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejszy od zera', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
CONST	SEGMENT
??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@ DB 'Styl liczeia '
	DB	'wygranej przyjmuje warto', 09cH, 'ci tylko 0 lub 1', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
CONST	SEGMENT
??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@ DB 'Jedna z dek'
	DB	'laracji w sprawie obrot', 0f3H, 'w ruletki musi by', 0e6H, ' '
	DB	'wi', 0eaH, 'ksza od zera', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
CONST	SEGMENT
??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@ DB 'Ilo', 09cH
	DB	0e6H, ' max obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e by', 0e6H
	DB	' mniejsza od 0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
CONST	SEGMENT
??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@ DB 'Ilo', 09cH
	DB	0e6H, ' minimalna obrot', 0f3H, 'w ruletki nie mo', 0bfH, 'e b'
	DB	'y', 0e6H, ' mniejsza od 0', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
CONST	SEGMENT
??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@ DB 'Ustawiam do'
	DB	'my', 09cH, 'lne ustawienie', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
CONST	SEGMENT
??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@ DB 'Warto', 09cH
	DB	0e6H, ' wolnego czasu przeskoku kulki musi by', 0e6H, ' ni', 0bfH
	DB	'sza ni', 0bfH, ' warto', 09cH, 0e6H, ' szybkiego czasu przesk'
	DB	'oku kulki', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
CONST	SEGMENT
??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@ DB 'efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
CONST	SEGMENT
??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@ DB 'g', 0b3H
	DB	'os_szybko', 09cH, 0e6H, '_odczytu_numeru 4', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
CONST	SEGMENT
??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@ DB 'g', 0b3H, 'os_odczyt'
	DB	'u_numeru 1', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
CONST	SEGMENT
??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@ DB 'czy_kontynuowa', 0e6H
	DB	'_gr', 0eaH, ' 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
CONST	SEGMENT
??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@ DB 'stan_d', 09fH, 'wi', 0eaH
	DB	'k', 0f3H, 'w 1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
CONST	SEGMENT
??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@ DB 'kwota_pocz', 0b9H, 't'
	DB	'kowa 1000', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
CONST	SEGMENT
??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@ DB 'styl_liczenia_wygra'
	DB	'nej 1', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
CONST	SEGMENT
??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@ DB 'czas_przerwy_dzwi', 0eaH
	DB	'ku 500', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
CONST	SEGMENT
??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@ DB 'czas_przeskoku'
	DB	'_kulki_wolny 75', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
CONST	SEGMENT
??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@ DB 'czas_przeskok'
	DB	'u_kulki_szybki 50', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
CONST	SEGMENT
??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@ DB 'ilo', 09cH, 0e6H
	DB	'_max_dodatkowych_obrot', 0f3H, 'w_ruletki 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
CONST	SEGMENT
??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@ DB 'ilo', 09cH
	DB	0e6H, '_minimalna_obrot', 0f3H, 'w_ruletki 2', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@COFBHHKL@setting?4txt?$AA@
CONST	SEGMENT
??_C@_0M@COFBHHKL@setting?4txt?$AA@ DB 'setting.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
CONST	SEGMENT
??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@ DB 'Pobr'
	DB	'ano brakuj', 0b9H, 'ce pliki g', 0b3H, 'os', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
CONST	SEGMENT
??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla g', 0b3H, 'osu oraz nie mo', 0bfH, 'na pob'
	DB	'ra', 0e6H, ' danych, wy', 0b3H, 0b9H, 'czono odczytywanie wyn'
	DB	'iku', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w g', 0b3H, 'o'
	DB	's', 0f3H, 'w', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_04JLFAMLOH@G?$LDos?$AA@
CONST	SEGMENT
??_C@_04JLFAMLOH@G?$LDos?$AA@ DB 'G', 0b3H, 'os', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/G%C5%82os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01KMDKNFGN@?1?$AA@
CONST	SEGMENT
??_C@_01KMDKNFGN@?1?$AA@ DB '/', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01IDAFKMJL@_?$AA@
CONST	SEGMENT
??_C@_01IDAFKMJL@_?$AA@ DB '_', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05NKPCGME@Agata?$AA@
CONST	SEGMENT
??_C@_05NKPCGME@Agata?$AA@ DB 'Agata', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04HDNGKDH@Jan2?$AA@
CONST	SEGMENT
??_C@_04HDNGKDH@Jan2?$AA@ DB 'Jan2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05KJFHPLBC@Maja2?$AA@
CONST	SEGMENT
??_C@_05KJFHPLBC@Maja2?$AA@ DB 'Maja2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04PLEDLCJI@Ewa2?$AA@
CONST	SEGMENT
??_C@_04PLEDLCJI@Ewa2?$AA@ DB 'Ewa2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_06DKNIKMFF@Jacek2?$AA@
CONST	SEGMENT
??_C@_06DKNIKMFF@Jacek2?$AA@ DB 'Jacek2', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03JIHJHPIE@Jan?$AA@
CONST	SEGMENT
??_C@_03JIHJHPIE@Jan?$AA@ DB 'Jan', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_04CDICBAGM@Maja?$AA@
CONST	SEGMENT
??_C@_04CDICBAGM@Maja?$AA@ DB 'Maja', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FPCJKMNP@Ewa?$AA@
CONST	SEGMENT
??_C@_03FPCJKMNP@Ewa?$AA@ DB 'Ewa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05KFCKMKOB@Jacek?$AA@
CONST	SEGMENT
??_C@_05KFCKMKOB@Jacek?$AA@ DB 'Jacek', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05CMOJBPHN@G?$LDos?1?$AA@
CONST	SEGMENT
??_C@_05CMOJBPHN@G?$LDos?1?$AA@ DB 'G', 0b3H, 'os/', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
CONST	SEGMENT
??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@ DB 'Pobran'
	DB	'o brakuj', 0b9H, 'ce pliki efekt', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
CONST	SEGMENT
??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/zwielokrotnenie.wav', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana2.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
CONST	SEGMENT
??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/wygrana1.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
CONST	SEGMENT
??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@ DB 'Brak p'
	DB	'lik', 0f3H, 'w dla efekt', 0f3H, 'w d', 09fH, 'wi', 0eaH, 'ko'
	DB	'wych oraz nie mo', 0bfH, 'na pobra', 0e6H, ' danych, wy', 0b3H
	DB	0b9H, 'czono efekty d', 09fH, 'wi', 0eaH, 'kowe muzyczne, w', 0b3H
	DB	0b9H, 'czono efekty systemowe', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
CONST	SEGMENT
??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@ DB 'https://gi'
	DB	'thub.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAw'
	DB	'i%C4%99kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
CONST	SEGMENT
??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@ DB 'Rozpoczynam'
	DB	' pobieranie brakuj', 0b9H, 'cych plik', 0f3H, 'w efekt', 0f3H
	DB	'w', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
CONST	SEGMENT
??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@ DB 'Efekty_d', 09fH
	DB	'wi', 0eaH, 'kowe/bankrut.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
CONST	SEGMENT
??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@ DB 'Efekty_d', 09fH, 'wi', 0eaH
	DB	'kowe', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@ DB 'Nowa gra rozpoc'
	DB	'zeta dnia ', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_01JLIPDDHJ@?3?$AA@
CONST	SEGMENT
??_C@_01JLIPDDHJ@?3?$AA@ DB ':', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
CONST	SEGMENT
??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@ DB 'Gra rozpoczeta dnia ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01LFCBOECM@?4?$AA@
CONST	SEGMENT
??_C@_01LFCBOECM@?4?$AA@ DB '.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
CONST	SEGMENT
??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@ DB ' o godzinie ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
CONST	SEGMENT
??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@ DB 'Gra rozpoczeta dnia', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
CONST	SEGMENT
??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@ DB 'Obstawiono za', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
CONST	SEGMENT
??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@ DB 'Obstawiono zaklad', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
CONST	SEGMENT
??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@ DB ' Wylosowano', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0L@DAFLKCID@Wylosowano?$AA@
CONST	SEGMENT
??_C@_0L@DAFLKCID@Wylosowano?$AA@ DB 'Wylosowano', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_09LFKNBKJA@Posiadasz?$AA@
CONST	SEGMENT
??_C@_09LFKNBKJA@Posiadasz?$AA@ DB 'Posiadasz', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
CONST	SEGMENT
??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@ DB 'Uruch'
	DB	'omiono ponownie gr', 0eaH, ' z wy', 0b3H, 0b9H, 'czon', 0b9H, ' '
	DB	'opcj', 0b9H, ' kontynuowania', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
CONST	SEGMENT
??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@ DB 'log_aktualny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01NOFIACDB@w?$AA@
CONST	SEGMENT
??_C@_01NOFIACDB@w?$AA@ DB 'w', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DICPFPGM@k?$AA@
CONST	SEGMENT
??_C@_01DICPFPGM@k?$AA@ DB 'k', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05GFDBGFDH@d?4wav?$AA@
CONST	SEGMENT
??_C@_05GFDBGFDH@d?4wav?$AA@ DB 'd.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05ODKFBHJJ@g?4wav?$AA@
CONST	SEGMENT
??_C@_05ODKFBHJJ@g?4wav?$AA@ DB 'g.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LDGIIGCK@b?4wav?$AA@
CONST	SEGMENT
??_C@_05LDGIIGCK@b?4wav?$AA@ DB 'b.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05LALOIELB@r?4wav?$AA@
CONST	SEGMENT
??_C@_05LALOIELB@r?4wav?$AA@ DB 'r.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05MEKKEGFB@n?4wav?$AA@
CONST	SEGMENT
??_C@_05MEKKEGFB@n?4wav?$AA@ DB 'n.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_05PNHGCFLK@p?4wav?$AA@
CONST	SEGMENT
??_C@_05PNHGCFLK@p?4wav?$AA@ DB 'p.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_04IBLEHOMF@?4wav?$AA@
CONST	SEGMENT
??_C@_04IBLEHOMF@?4wav?$AA@ DB '.wav', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_03FHDFACOC@NIE?$AA@
CONST	SEGMENT
??_C@_03FHDFACOC@NIE?$AA@ DB 'NIE', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PKPMGAKA@Nie?$AA@
CONST	SEGMENT
??_C@_03PKPMGAKA@Nie?$AA@ DB 'Nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FKMOMPJO@nie?$AA@
CONST	SEGMENT
??_C@_03FKMOMPJO@nie?$AA@ DB 'nie', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PIABMJCP@TAK?$AA@
CONST	SEGMENT
??_C@_03PIABMJCP@TAK?$AA@ DB 'TAK', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03FFMIKLGN@Tak?$AA@
CONST	SEGMENT
??_C@_03FFMIKLGN@Tak?$AA@ DB 'Tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03PFPKAEFD@tak?$AA@
CONST	SEGMENT
??_C@_03PFPKAEFD@tak?$AA@ DB 'tak', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01PFHFFBPC@t?$AA@
CONST	SEGMENT
??_C@_01PFHFFBPC@t?$AA@ DB 't', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
CONST	SEGMENT
??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@ DB 'Na koncie masz ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@
CONST	SEGMENT
??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@ DB '$, '
	DB	'czy chcesz grac dalej(''t'' - tak, ''n'' - nie) ?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
CONST	SEGMENT
??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@ DB 'Nie m'
	DB	'o', 0bfH, 'esz kontynuowa', 0e6H, ', przegra', 0b3H, 'e', 09cH
	DB	' wszystko', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@
CONST	SEGMENT
??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@ DB 'Obstawiles ni'
	DB	'epoprawnie, przegra', 0b3H, 'e', 09cH, ' ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@
CONST	SEGMENT
??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@ DB 'Obstawiles ni'
	DB	'epoprawnie lecz uda', 0b3H, 'o Ci si', 0eaH, ', dostajesz po', 0b3H
	DB	'ow', 0eaH, ' zak', 0b3H, 'adu ', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@
CONST	SEGMENT
??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@ DB 'Obstawiles p'
	DB	'oprawnie, wygrywasz ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DEPNMBPN@$?4?$AA@
CONST	SEGMENT
??_C@_02DEPNMBPN@$?4?$AA@ DB '$.', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KHOJGJKF@?4?5?$AA@
CONST	SEGMENT
??_C@_02KHOJGJKF@?4?5?$AA@ DB '. ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
CONST	SEGMENT
??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@ DB 'Wylosowano numer ', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KNHHEEKP@?5?5?$AA@
CONST	SEGMENT
??_C@_02KNHHEEKP@?5?5?$AA@ DB '  ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MGHEPNFN@?$AI?$AI?$AA@
CONST	SEGMENT
??_C@_02MGHEPNFN@?$AI?$AI?$AA@ DB 08H, 08H, 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
CONST	SEGMENT
??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@ DB 'Ni'
	DB	'e mo', 0bfH, 'esz obstawi', 0e6H, ' ujemn', 0b9H, ' kwot', 0b9H
	DB	' zak', 0b3H, 'adu', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@
CONST	SEGMENT
??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@ DB 'Nie masz tyle pie'
	DB	'ni', 0eaH, 'dzy', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@
CONST	SEGMENT
??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@ DB 'Nie mo', 0bfH
	DB	'esz obstawi', 0e6H, ' zerowego zak', 0b3H, 'adu', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_01PBGHHLMH@?$AH?$AA@
CONST	SEGMENT
??_C@_01PBGHHLMH@?$AH?$AA@ DB 07H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@
CONST	SEGMENT
??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@ DB 'Wpro'
	DB	'wadzi', 0b3H, 'e', 0e6H, ' nieprawid', 0b3H, 'ow', 0b9H, ' wa'
	DB	'rto', 09cH, 0e6H, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_05OMMBNPEF@Masz?5?$AA@
CONST	SEGMENT
??_C@_05OMMBNPEF@Masz?5?$AA@ DB 'Masz ', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@
CONST	SEGMENT
??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@ DB '$, ja'
	DB	'k', 0b9H, ' kwot', 0eaH, ' chcesz obstawi', 0e6H, ' wynik?', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_02KPIPOMFB@36?$AA@
CONST	SEGMENT
??_C@_02KPIPOMFB@36?$AA@ DB '36', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IEKCLPJC@35?$AA@
CONST	SEGMENT
??_C@_02IEKCLPJC@35?$AA@ DB '35', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JNLJIOND@34?$AA@
CONST	SEGMENT
??_C@_02JNLJIOND@34?$AA@ DB '34', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NCPIBIBE@33?$AA@
CONST	SEGMENT
??_C@_02NCPIBIBE@33?$AA@ DB '33', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MLODCJFF@32?$AA@
CONST	SEGMENT
??_C@_02MLODCJFF@32?$AA@ DB '32', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OAMOHKJG@31?$AA@
CONST	SEGMENT
??_C@_02OAMOHKJG@31?$AA@ DB '31', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PJNFELNH@30?$AA@
CONST	SEGMENT
??_C@_02PJNFELNH@30?$AA@ DB '30', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CJNFJKKJ@29?$AA@
CONST	SEGMENT
??_C@_02CJNFJKKJ@29?$AA@ DB '29', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DAMOKLOI@28?$AA@
CONST	SEGMENT
??_C@_02DAMOKLOI@28?$AA@ DB '28', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LHFGLHCH@27?$AA@
CONST	SEGMENT
??_C@_02LHFGLHCH@27?$AA@ DB '27', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KOENIGGG@26?$AA@
CONST	SEGMENT
??_C@_02KOENIGGG@26?$AA@ DB '26', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IFGANFKF@25?$AA@
CONST	SEGMENT
??_C@_02IFGANFKF@25?$AA@ DB '25', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JMHLOEOE@24?$AA@
CONST	SEGMENT
??_C@_02JMHLOEOE@24?$AA@ DB '24', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NDDKHCCD@23?$AA@
CONST	SEGMENT
??_C@_02NDDKHCCD@23?$AA@ DB '23', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MKCBEDGC@22?$AA@
CONST	SEGMENT
??_C@_02MKCBEDGC@22?$AA@ DB '22', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OBAMBAKB@21?$AA@
CONST	SEGMENT
??_C@_02OBAMBAKB@21?$AA@ DB '21', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PIBHCBOA@20?$AA@
CONST	SEGMENT
??_C@_02PIBHCBOA@20?$AA@ DB '20', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02CLJDCEPA@19?$AA@
CONST	SEGMENT
??_C@_02CLJDCEPA@19?$AA@ DB '19', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02DCIIBFLB@18?$AA@
CONST	SEGMENT
??_C@_02DCIIBFLB@18?$AA@ DB '18', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LFBAAJHO@17?$AA@
CONST	SEGMENT
??_C@_02LFBAAJHO@17?$AA@ DB '17', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KMALDIDP@16?$AA@
CONST	SEGMENT
??_C@_02KMALDIDP@16?$AA@ DB '16', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02IHCGGLPM@15?$AA@
CONST	SEGMENT
??_C@_02IHCGGLPM@15?$AA@ DB '15', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JODNFKLN@14?$AA@
CONST	SEGMENT
??_C@_02JODNFKLN@14?$AA@ DB '14', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NBHMMMHK@13?$AA@
CONST	SEGMENT
??_C@_02NBHMMMHK@13?$AA@ DB '13', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MIGHPNDL@12?$AA@
CONST	SEGMENT
??_C@_02MIGHPNDL@12?$AA@ DB '12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ODEKKOPI@11?$AA@
CONST	SEGMENT
??_C@_02ODEKKOPI@11?$AA@ DB '11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PKFBJPLJ@10?$AA@
CONST	SEGMENT
??_C@_02PKFBJPLJ@10?$AA@ DB '10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LAKCGALK@9?$AA@
CONST	SEGMENT
??_C@_01LAKCGALK@9?$AA@ DB '9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KJLJFBPL@8?$AA@
CONST	SEGMENT
??_C@_01KJLJFBPL@8?$AA@ DB '8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01COCBENDE@7?$AA@
CONST	SEGMENT
??_C@_01COCBENDE@7?$AA@ DB '7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01DHDKHMHF@6?$AA@
CONST	SEGMENT
??_C@_01DHDKHMHF@6?$AA@ DB '6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01BMBHCPLG@5?$AA@
CONST	SEGMENT
??_C@_01BMBHCPLG@5?$AA@ DB '5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FAMBOPH@4?$AA@
CONST	SEGMENT
??_C@_01FAMBOPH@4?$AA@ DB '4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EKENIIDA@3?$AA@
CONST	SEGMENT
??_C@_01EKENIIDA@3?$AA@ DB '3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01FDFGLJHB@2?$AA@
CONST	SEGMENT
??_C@_01FDFGLJHB@2?$AA@ DB '2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01HIHLOKLC@1?$AA@
CONST	SEGMENT
??_C@_01HIHLOKLC@1?$AA@ DB '1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01GBGANLPD@0?$AA@
CONST	SEGMENT
??_C@_01GBGANLPD@0?$AA@ DB '0', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03OAIKGDBA@w12?$AA@
CONST	SEGMENT
??_C@_03OAIKGDBA@w12?$AA@ DB 'w12', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03MLKHDAND@w11?$AA@
CONST	SEGMENT
??_C@_03MLKHDAND@w11?$AA@ DB 'w11', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_03NCLMABJC@w10?$AA@
CONST	SEGMENT
??_C@_03NCLMABJC@w10?$AA@ DB 'w10', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02FPIENFIC@w9?$AA@
CONST	SEGMENT
??_C@_02FPIENFIC@w9?$AA@ DB 'w9', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02EGJPOEMD@w8?$AA@
CONST	SEGMENT
??_C@_02EGJPOEMD@w8?$AA@ DB 'w8', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02MBAHPIAM@w7?$AA@
CONST	SEGMENT
??_C@_02MBAHPIAM@w7?$AA@ DB 'w7', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02NIBMMJEN@w6?$AA@
CONST	SEGMENT
??_C@_02NIBMMJEN@w6?$AA@ DB 'w6', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02PDDBJKIO@w5?$AA@
CONST	SEGMENT
??_C@_02PDDBJKIO@w5?$AA@ DB 'w5', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02OKCKKLMP@w4?$AA@
CONST	SEGMENT
??_C@_02OKCKKLMP@w4?$AA@ DB 'w4', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KFGLDNAI@w3?$AA@
CONST	SEGMENT
??_C@_02KFGLDNAI@w3?$AA@ DB 'w3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LMHAAMEJ@w2?$AA@
CONST	SEGMENT
??_C@_02LMHAAMEJ@w2?$AA@ DB 'w2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02JHFNFPIK@w1?$AA@
CONST	SEGMENT
??_C@_02JHFNFPIK@w1?$AA@ DB 'w1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02LAFHGHBM@k3?$AA@
CONST	SEGMENT
??_C@_02LAFHGHBM@k3?$AA@ DB 'k3', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02KJEMFGFN@k2?$AA@
CONST	SEGMENT
??_C@_02KJEMFGFN@k2?$AA@ DB 'k2', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_02ICGBAFJO@k1?$AA@
CONST	SEGMENT
??_C@_02ICGBAFJO@k1?$AA@ DB 'k1', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01LPLHEDKD@d?$AA@
CONST	SEGMENT
??_C@_01LPLHEDKD@d?$AA@ DB 'd', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JEJKBAGA@g?$AA@
CONST	SEGMENT
??_C@_01JEJKBAGA@g?$AA@ DB 'g', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01OJONOECF@b?$AA@
CONST	SEGMENT
??_C@_01OJONOECF@b?$AA@ DB 'b', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01KDCPPGHE@r?$AA@
CONST	SEGMENT
??_C@_01KDCPPGHE@r?$AA@ DB 'r', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01EFFIKLCJ@n?$AA@
CONST	SEGMENT
??_C@_01EFFIKLCJ@n?$AA@ DB 'n', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_01JBBJJEPG@p?$AA@
CONST	SEGMENT
??_C@_01JBBJJEPG@p?$AA@ DB 'p', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@
CONST	SEGMENT
??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@ DB '0 - 36 '
	DB	'- pojedyncze pole o odpowiednim numerze', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@
CONST	SEGMENT
??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@ DB 'w1,'
	DB	' w2, ..., w12 - wiersz trzech numer', 0f3H, 'w', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
CONST	SEGMENT
??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@ DB 'k1, k'
	DB	'2, k3 - kolumna 1, kolumna 2, kolumna 3', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@ DB 'd - dolna po', 0b3H, 'o'
	DB	'wa', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
CONST	SEGMENT
??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@ DB 'g - g', 0f3H, 'rna p'
	DB	'o', 0b3H, 'owa', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@ DB 'b - czarne(black)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@
CONST	SEGMENT
??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@ DB 'r - czerwone(red)', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
CONST	SEGMENT
??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@ DB 'n - nieparzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
CONST	SEGMENT
??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@ DB 'p - parzyste', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@
CONST	SEGMENT
??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@ DB 'Ja'
	DB	'k', 0b9H, ' opcje chcesz obstawic ? (zgodnie z poni', 0bfH, 's'
	DB	'zym opisem) :', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_05PDJBBECF@pause?$AA@
CONST	SEGMENT
??_C@_05PDJBBECF@pause?$AA@ DB 'pause', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
CONST	SEGMENT
??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@ DB 'log_og', 0f3H, 'lny.txt', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_06JGCGFIEG@polish?$AA@
CONST	SEGMENT
??_C@_06JGCGFIEG@polish?$AA@ DB 'polish', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_08EPJLHIJG@bad?5cast?$AA@
CONST	SEGMENT
??_C@_08EPJLHIJG@bad?5cast?$AA@ DB 'bad cast', 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
CONST	SEGMENT
??_C@_0BC@EOODALEL@Unknown?5exception?$AA@ DB 'Unknown exception', 00H ; `string'
CONST	ENDS
PUBLIC	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
PUBLIC	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
PUBLIC	??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ; std::uniform_int<int>::_Adjust
PUBLIC	?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	?_Adjust@?$uniform_int@H@std@@CAII@Z		; std::uniform_int<int>::_Adjust
PUBLIC	??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
PUBLIC	??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
PUBLIC	?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
PUBLIC	??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ; std::_Traits_equal<std::char_traits<char> >
PUBLIC	??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>
PUBLIC	??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ; std::forward<std::allocator<char> const & __ptr64>
PUBLIC	??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z	; std::forward<char * __ptr64 const & __ptr64>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
PUBLIC	??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::forward<std::allocator<char> >
PUBLIC	??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z ; std::uniform_int<int>::_Eval<std::random_device>
PUBLIC	??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
PUBLIC	?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
PUBLIC	?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
PUBLIC	?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
PUBLIC	?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
PUBLIC	?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
PUBLIC	?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
PUBLIC	?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
PUBLIC	??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
PUBLIC	??0bad_cast@std@@QEAA@AEBV01@@Z			; std::bad_cast::bad_cast
PUBLIC	??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>
PUBLIC	??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>
PUBLIC	??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z		; std::_Refancy<char * __ptr64,0>
PUBLIC	??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ; std::addressof<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
PUBLIC	??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z	; std::addressof<char * __ptr64>
PUBLIC	??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
PUBLIC	??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ; std::_Pocca<std::allocator<char> >
PUBLIC	??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ; std::_Pocma<std::allocator<char> >
PUBLIC	??$addressof@D@std@@YAPEADAEAD@Z		; std::addressof<char>
PUBLIC	??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
PUBLIC	??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
PUBLIC	??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ; std::move<std::allocator<char> & __ptr64>
PUBLIC	??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>
PUBLIC	??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
PUBLIC	??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
PUBLIC	??$_Unfancy@D@std@@YAPEADPEAD@Z			; std::_Unfancy<char>
PUBLIC	??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Min_value<unsigned __int64>
PUBLIC	??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ; std::_Traits_find<std::char_traits<char> >
PUBLIC	??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z		; std::size<char,29>
PUBLIC	??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z		; std::size<char,20>
PUBLIC	??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z		; std::size<char,14>
PUBLIC	??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z		; std::size<char,17>
PUBLIC	??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z		; std::size<char,23>
PUBLIC	??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z		; std::size<char,27>
PUBLIC	??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z		; std::size<char,28>
PUBLIC	??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z		; std::size<char,38>
PUBLIC	??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z		; std::size<char,32>
PUBLIC	??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z ; std::uniform_int<int>::operator()<std::random_device>
PUBLIC	??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
PUBLIC	??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
PUBLIC	??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
PUBLIC	??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z ; std::uniform_int<int>::param_type::_Init
PUBLIC	??0?$allocator@D@std@@QEAA@XZ			; std::allocator<char>::allocator<char>
PUBLIC	?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
PUBLIC	?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ; std::_Default_allocator_traits<std::allocator<char> >::max_size
PUBLIC	?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
PUBLIC	??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
PUBLIC	??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
PUBLIC	??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
PUBLIC	??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
PUBLIC	?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed
PUBLIC	??0param_type@?$uniform_int@H@std@@QEAA@HH@Z	; std::uniform_int<int>::param_type::param_type
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ; std::fpos<_Mbstatet>::fpos<_Mbstatet>
PUBLIC	?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ; std::fpos<_Mbstatet>::state
PUBLIC	?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ	; std::fpos<_Mbstatet>::seekpos
PUBLIC	??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ		; std::fpos<_Mbstatet>::operator __int64
PUBLIC	?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z	; std::allocator<char>::deallocate
PUBLIC	?allocate@?$allocator@D@std@@QEAAPEAD_K@Z	; std::allocator<char>::allocate
PUBLIC	??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
PUBLIC	??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
PUBLIC	?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
PUBLIC	?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init
PUBLIC	?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
PUBLIC	?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
PUBLIC	?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
PUBLIC	?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
PUBLIC	?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
PUBLIC	?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
PUBLIC	?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
PUBLIC	?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
PUBLIC	??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z		; std::_Max_value<unsigned __int64>
PUBLIC	?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
PUBLIC	?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
PUBLIC	?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
PUBLIC	?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
PUBLIC	?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
PUBLIC	?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
PUBLIC	??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
PUBLIC	?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
PUBLIC	?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
PUBLIC	?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ; std::_String_val<std::_Simple_types<char> >::_Myptr
PUBLIC	?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
PUBLIC	?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ; std::_String_val<std::_Simple_types<char> >::_Check_offset
PUBLIC	?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
PUBLIC	??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
PUBLIC	??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
PUBLIC	??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
PUBLIC	??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
PUBLIC	??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
PUBLIC	??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>
PUBLIC	?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower
PUBLIC	?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper
PUBLIC	??0?$uniform_int@H@std@@QEAA@HH@Z		; std::uniform_int<int>::uniform_int<int>
PUBLIC	?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ; std::pointer_traits<char * __ptr64>::pointer_to
PUBLIC	??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
PUBLIC	??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
PUBLIC	??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
PUBLIC	??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
PUBLIC	??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
PUBLIC	?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
PUBLIC	?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
PUBLIC	?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
PUBLIC	?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
PUBLIC	??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
PUBLIC	??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
PUBLIC	?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
PUBLIC	?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
PUBLIC	?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::overflow
PUBLIC	?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
PUBLIC	?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::underflow
PUBLIC	?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::uflow
PUBLIC	?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
PUBLIC	?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
PUBLIC	?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
PUBLIC	?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ; std::basic_filebuf<char,std::char_traits<char> >::sync
PUBLIC	?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ; std::basic_filebuf<char,std::char_traits<char> >::imbue
PUBLIC	??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_ifstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_ofstream<char,std::char_traits<char> >::open
PUBLIC	??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
PUBLIC	??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
PUBLIC	?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ; std::basic_fstream<char,std::char_traits<char> >::open
PUBLIC	?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_fstream<char,std::char_traits<char> >::close
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
PUBLIC	?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
PUBLIC	?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
PUBLIC	?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
PUBLIC	?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
PUBLIC	?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
PUBLIC	?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
PUBLIC	?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
PUBLIC	??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>
PUBLIC	??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator()
PUBLIC	??0?$uniform_int_distribution@H@std@@QEAA@HH@Z	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
PUBLIC	?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia
PUBLIC	?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna
PUBLIC	?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ; Koniec_gry
PUBLIC	?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³oœ_wynik
PUBLIC	?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?SprawdŸ_ustawienia@@YAXXZ			; SprawdŸ_ustawienia
PUBLIC	?SprawdŸ_Pliki@@YAXXZ				; SprawdŸ_Pliki
PUBLIC	?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
PUBLIC	?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
PUBLIC	??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
PUBLIC	?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
PUBLIC	?Wylosuj@@YAHAEBH0@Z				; Wylosuj
PUBLIC	?Show_Cursor@@YAXXZ				; Show_Cursor
PUBLIC	?Hide_Cursor@@YAXXZ				; Hide_Cursor
PUBLIC	?Change_Col@@YAXAEBH@Z				; Change_Col
PUBLIC	?Czy_Kontynuowaæ@@YA_NAEBH@Z			; Czy_Kontynuowaæ
PUBLIC	?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; SprawdŸ_Zak³ad
PUBLIC	?Zakrêæ_Ruletk¹@@YAHXZ				; Zakrêæ_Ruletk¹
PUBLIC	?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z		; Wczytaj_Kwotê_Zak³adu
PUBLIC	?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
PUBLIC	?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
PUBLIC	??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
PUBLIC	main
PUBLIC	??Rrandom_device@std@@QEAAIXZ			; std::random_device::operator()
PUBLIC	?entropy@random_device@std@@QEAANXZ		; std::random_device::entropy
PUBLIC	?max@random_device@std@@SAIXZ			; std::random_device::max
PUBLIC	?min@random_device@std@@SAIXZ			; std::random_device::min
PUBLIC	??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ; std::random_device::random_device
PUBLIC	??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z	; std::_Ungetc<char>
PUBLIC	??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z		; std::_Fputc<char>
PUBLIC	??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z		; std::_Fgetc<char>
PUBLIC	?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z	; std::locale::_Getfacet
PUBLIC	??1locale@std@@QEAA@XZ				; std::locale::~locale
PUBLIC	??1bad_cast@std@@UEAA@XZ			; std::bad_cast::~bad_cast
PUBLIC	??_Gbad_cast@std@@UEAAPEAXI@Z			; std::bad_cast::`scalar deleting destructor'
PUBLIC	??0bad_cast@std@@QEAA@XZ			; std::bad_cast::bad_cast
PUBLIC	??$_Convert_size@_K@std@@YA_K_K@Z		; std::_Convert_size<unsigned __int64>
PUBLIC	?_Deallocate@std@@YAXPEAX_K1@Z			; std::_Deallocate
PUBLIC	?_Allocate@std@@YAPEAX_K0_N@Z			; std::_Allocate
PUBLIC	?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z	; std::_Iterator_base0::_Adopt
PUBLIC	?_Orphan_all@_Container_base0@std@@QEAAXXZ	; std::_Container_base0::_Orphan_all
PUBLIC	?eof@?$char_traits@D@std@@SAHXZ			; std::char_traits<char>::eof
PUBLIC	?not_eof@?$char_traits@D@std@@SAHAEBH@Z		; std::char_traits<char>::not_eof
PUBLIC	?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z	; std::char_traits<char>::eq_int_type
PUBLIC	?to_int_type@?$char_traits@D@std@@SAHAEBD@Z	; std::char_traits<char>::to_int_type
PUBLIC	?to_char_type@?$char_traits@D@std@@SADAEBH@Z	; std::char_traits<char>::to_char_type
PUBLIC	?eq@?$char_traits@D@std@@SA_NAEBD0@Z		; std::char_traits<char>::eq
PUBLIC	?assign@?$char_traits@D@std@@SAXAEADAEBD@Z	; std::char_traits<char>::assign
PUBLIC	?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z	; std::char_traits<char>::assign
PUBLIC	?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z	; std::char_traits<char>::move
PUBLIC	?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z	; std::char_traits<char>::find
PUBLIC	?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z	; std::char_traits<char>::copy
PUBLIC	?length@?$char_traits@D@std@@SA_KQEBD@Z		; std::char_traits<char>::length
PUBLIC	?compare@?$char_traits@D@std@@SAHQEBD0_K@Z	; std::char_traits<char>::compare
PUBLIC	??2@YAPEAX_KPEAX@Z				; operator new
PUBLIC	?max@?$numeric_limits@_J@std@@SA_JXZ		; std::numeric_limits<__int64>::max
PUBLIC	??_Gexception@std@@UEAAPEAXI@Z			; std::exception::`scalar deleting destructor'
PUBLIC	?what@exception@std@@UEBAPEBDXZ			; std::exception::what
PUBLIC	??1exception@std@@UEAA@XZ			; std::exception::~exception
PUBLIC	??0exception@std@@QEAA@AEBV01@@Z		; std::exception::exception
PUBLIC	??0exception@std@@QEAA@QEBDH@Z			; std::exception::exception
PUBLIC	?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
PUBLIC	?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
PUBLIC	__real@4040000000000000
PUBLIC	__real@4042800000000000
PUBLIC	__xmm@000000000000000f0000000000000000
EXTRN	??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Ebad_cast@std@@UEAAPEAXI@Z:PROC		; std::bad_cast::`vector deleting destructor'
EXTRN	??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_filebuf<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z:PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
EXTRN	??_Eexception@std@@UEAAPEAXI@Z:PROC		; std::exception::`vector deleting destructor'
EXTRN	??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z:PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
EXTRN	_CxxThrowException:PROC
EXTRN	__CxxFrameHandler3:PROC
EXTRN	__GSHandlerCheck:PROC
EXTRN	__GSHandlerCheck_EH:PROC
EXTRN	__std_terminate:PROC
EXTRN	memcmp:PROC
EXTRN	memcpy:PROC
EXTRN	memset:PROC
EXTRN	__ImageBase:BYTE
EXTRN	__security_cookie:QWORD
EXTRN	_fltused:DWORD
;	COMDAT ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A
_BSS	SEGMENT
?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A DQ 01H DUP (?) ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
_BSS	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ DD imagerel $LN17
	DD	imagerel $LN17+33
	DD	imagerel $unwind$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel $LN11
	DD	imagerel $LN11+88
	DD	imagerel $unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z DD imagerel $LN33
	DD	imagerel $LN33+162
	DD	imagerel $unwind$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ DD imagerel $LN25
	DD	imagerel $LN25+89
	DD	imagerel $unwind$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+45
	DD	imagerel $unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+52
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+52
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+398
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+398
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+404
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+347
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+347
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+353
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD imagerel $LN9
	DD	imagerel $LN9+41
	DD	imagerel $unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel $LN111
	DD	imagerel $LN111+460
	DD	imagerel $unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+56
	DD	imagerel $unwind$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel $LN156
	DD	imagerel $LN156+427
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+56
	DD	imagerel $unwind$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD imagerel $LN91
	DD	imagerel $LN91+62
	DD	imagerel $unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD imagerel $LN91+62
	DD	imagerel $LN91+137
	DD	imagerel $chain$0$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD imagerel $LN91+137
	DD	imagerel $LN91+165
	DD	imagerel $chain$1$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN178
	DD	imagerel $LN178+530
	DD	imagerel $unwind$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DD imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+56
	DD	imagerel $unwind$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD imagerel ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
	DD	imagerel ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z+86
	DD	imagerel $unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36+48
	DD	imagerel $LN36+198
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD imagerel $LN36+198
	DD	imagerel $LN36+236
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52+59
	DD	imagerel $LN52+210
	DD	imagerel $chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD imagerel $LN52+210
	DD	imagerel $LN52+248
	DD	imagerel $chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN64
	DD	imagerel $LN64+72
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN64+72
	DD	imagerel $LN64+158
	DD	imagerel $chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN64+158
	DD	imagerel $LN64+169
	DD	imagerel $chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN64+169
	DD	imagerel $LN64+176
	DD	imagerel $chain$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD imagerel $LN29
	DD	imagerel $LN29+73
	DD	imagerel $unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0bad_cast@std@@QEAA@AEBV01@@Z DD imagerel $LN6
	DD	imagerel $LN6+64
	DD	imagerel $unwind$??0bad_cast@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+46
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+413
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+413
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+419
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+45
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+409
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+409
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+415
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+317
	DD	imagerel $chain$2$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+317
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+324
	DD	imagerel $chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+324
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+330
	DD	imagerel $chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD imagerel ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z+278
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+373
	DD	imagerel $chain$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+373
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+379
	DD	imagerel $chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+275
	DD	imagerel $unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+60
	DD	imagerel $LN26+191
	DD	imagerel $chain$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+191
	DD	imagerel $LN26+199
	DD	imagerel $chain$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD imagerel $LN26+199
	DD	imagerel $LN26+220
	DD	imagerel $chain$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel $LN130
	DD	imagerel $LN130+289
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel $LN7
	DD	imagerel $LN7+59
	DD	imagerel $unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD imagerel $LN89
	DD	imagerel $LN89+124
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD imagerel $LN132
	DD	imagerel $LN132+334
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD imagerel $LN75
	DD	imagerel $LN75+87
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD imagerel $LN142
	DD	imagerel $LN142+308
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA DD imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA+38
	DD	imagerel $unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD imagerel $LN67
	DD	imagerel $LN67+74
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD imagerel $LN201
	DD	imagerel $LN201+128
	DD	imagerel $unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD imagerel $LN93
	DD	imagerel $LN93+62
	DD	imagerel $unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD imagerel $LN93+62
	DD	imagerel $LN93+137
	DD	imagerel $chain$0$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD imagerel $LN93+137
	DD	imagerel $LN93+165
	DD	imagerel $chain$1$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN32
	DD	imagerel $LN32+73
	DD	imagerel $unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD imagerel $LN34
	DD	imagerel $LN34+71
	DD	imagerel $unwind$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD imagerel $LN4
	DD	imagerel $LN4+57
	DD	imagerel $unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel $LN113
	DD	imagerel $LN113+445
	DD	imagerel $unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+56
	DD	imagerel $unwind$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel $LN23
	DD	imagerel $LN23+275
	DD	imagerel $unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+30
	DD	imagerel $LN51+141
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+141
	DD	imagerel $LN51+163
	DD	imagerel $chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD imagerel $LN51+163
	DD	imagerel $LN51+169
	DD	imagerel $chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD imagerel $LN4
	DD	imagerel $LN4+18
	DD	imagerel $unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN10
	DD	imagerel $LN10+44
	DD	imagerel $unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN8
	DD	imagerel $LN8+45
	DD	imagerel $unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD imagerel $LN20
	DD	imagerel $LN20+62
	DD	imagerel $unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD imagerel $LN14
	DD	imagerel $LN14+91
	DD	imagerel $unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN47
	DD	imagerel $LN47+53
	DD	imagerel $unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN458
	DD	imagerel $LN458+293
	DD	imagerel $unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD imagerel $LN45
	DD	imagerel $LN45+170
	DD	imagerel $unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel $LN15
	DD	imagerel $LN15+90
	DD	imagerel $unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel $LN22
	DD	imagerel $LN22+199
	DD	imagerel $unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD imagerel $LN19
	DD	imagerel $LN19+127
	DD	imagerel $unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD imagerel $LN13
	DD	imagerel $LN13+192
	DD	imagerel $unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel $LN454
	DD	imagerel $LN454+495
	DD	imagerel $unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD imagerel $LN12
	DD	imagerel $LN12+72
	DD	imagerel $unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+49
	DD	imagerel $LN77+160
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+160
	DD	imagerel $LN77+182
	DD	imagerel $chain$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD imagerel $LN77+182
	DD	imagerel $LN77+188
	DD	imagerel $chain$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD imagerel $LN86
	DD	imagerel $LN86+201
	DD	imagerel $unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD imagerel ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
	DD	imagerel ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z+72
	DD	imagerel $unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+35
	DD	imagerel $LN24+99
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+99
	DD	imagerel $LN24+129
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD imagerel ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
	DD	imagerel ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z+72
	DD	imagerel $unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24+35
	DD	imagerel $LN24+102
	DD	imagerel $chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN24+102
	DD	imagerel $LN24+132
	DD	imagerel $chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD imagerel ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
	DD	imagerel ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z+42
	DD	imagerel $unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+25
	DD	imagerel $LN24+78
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD imagerel $LN24+78
	DD	imagerel $LN24+99
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32+35
	DD	imagerel $LN32+91
	DD	imagerel $chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD imagerel $LN32+91
	DD	imagerel $LN32+112
	DD	imagerel $chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN154
	DD	imagerel $LN154+58
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN154+58
	DD	imagerel $LN154+322
	DD	imagerel $chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD imagerel $LN154+322
	DD	imagerel $LN154+329
	DD	imagerel $chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD imagerel ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
	DD	imagerel ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z+57
	DD	imagerel $unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN48
	DD	imagerel $LN48+110
	DD	imagerel $unwind$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN46
	DD	imagerel $LN46+100
	DD	imagerel $unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD imagerel $LN7
	DD	imagerel $LN7+21
	DD	imagerel $unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel $LN26
	DD	imagerel $LN26+124
	DD	imagerel $unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN13
	DD	imagerel $LN13+72
	DD	imagerel $unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+234
	DD	imagerel $unwind$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+52
	DD	imagerel $unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD imagerel $LN12
	DD	imagerel $LN12+146
	DD	imagerel $unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN17
	DD	imagerel $LN17+149
	DD	imagerel $unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel $LN6
	DD	imagerel $LN6+59
	DD	imagerel $unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN48
	DD	imagerel $LN48+189
	DD	imagerel $unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN131
	DD	imagerel $LN131+43
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN131+43
	DD	imagerel $LN131+214
	DD	imagerel $chain$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN131+214
	DD	imagerel $LN131+504
	DD	imagerel $chain$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN131+504
	DD	imagerel $LN131+530
	DD	imagerel $chain$6$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD imagerel $LN131+530
	DD	imagerel $LN131+561
	DD	imagerel $chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN76
	DD	imagerel $LN76+404
	DD	imagerel $unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN58
	DD	imagerel $LN58+56
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN58+56
	DD	imagerel $LN58+244
	DD	imagerel $chain$0$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN58+244
	DD	imagerel $LN58+266
	DD	imagerel $chain$1$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel $LN55
	DD	imagerel $LN55+192
	DD	imagerel $unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD imagerel $LN4
	DD	imagerel $LN4+86
	DD	imagerel $unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD imagerel $LN464
	DD	imagerel $LN464+333
	DD	imagerel $unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN12
	DD	imagerel $LN12+115
	DD	imagerel $unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN573
	DD	imagerel $LN573+719
	DD	imagerel $unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel $LN81
	DD	imagerel $LN81+224
	DD	imagerel $unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+51
	DD	imagerel $LN26+79
	DD	imagerel $chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN26+79
	DD	imagerel $LN26+103
	DD	imagerel $chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN591
	DD	imagerel $LN591+773
	DD	imagerel $unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD imagerel $LN23
	DD	imagerel $LN23+268
	DD	imagerel $unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD imagerel $LN18
	DD	imagerel $LN18+240
	DD	imagerel $unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD imagerel $LN9
	DD	imagerel $LN9+89
	DD	imagerel $unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel $LN15
	DD	imagerel $LN15+67
	DD	imagerel $unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD imagerel $LN14
	DD	imagerel $LN14+80
	DD	imagerel $unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+212
	DD	imagerel $unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+198
	DD	imagerel $unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+82
	DD	imagerel $unwind$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+212
	DD	imagerel $unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+198
	DD	imagerel $unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+73
	DD	imagerel $unwind$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel $LN22
	DD	imagerel $LN22+220
	DD	imagerel $unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA+46
	DD	imagerel $unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel $LN15
	DD	imagerel $LN15+198
	DD	imagerel $unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD imagerel $LN6
	DD	imagerel $LN6+76
	DD	imagerel $unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN5
	DD	imagerel $LN5+58
	DD	imagerel $unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD imagerel $LN109
	DD	imagerel $LN109+202
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47+44
	DD	imagerel $LN47+97
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD imagerel $LN47+97
	DD	imagerel $LN47+122
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN55
	DD	imagerel $LN55+54
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN55+54
	DD	imagerel $LN55+110
	DD	imagerel $chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD imagerel $LN55+110
	DD	imagerel $LN55+135
	DD	imagerel $chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD imagerel $LN24
	DD	imagerel $LN24+42
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD imagerel $LN98
	DD	imagerel $LN98+145
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD imagerel $LN49
	DD	imagerel $LN49+100
	DD	imagerel $unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN52
	DD	imagerel $LN52+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN52+22
	DD	imagerel $LN52+104
	DD	imagerel $chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN52+104
	DD	imagerel $LN52+126
	DD	imagerel $chain$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD imagerel $LN52+126
	DD	imagerel $LN52+135
	DD	imagerel $chain$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33+21
	DD	imagerel $LN33+95
	DD	imagerel $chain$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD imagerel $LN33+95
	DD	imagerel $LN33+123
	DD	imagerel $chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD imagerel $LN27
	DD	imagerel $LN27+79
	DD	imagerel $unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD imagerel $LN32
	DD	imagerel $LN32+89
	DD	imagerel $unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+86
	DD	imagerel $LN46+206
	DD	imagerel $chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+206
	DD	imagerel $LN46+214
	DD	imagerel $chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD imagerel $LN46+214
	DD	imagerel $LN46+234
	DD	imagerel $chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN85
	DD	imagerel $LN85+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN85+49
	DD	imagerel $LN85+160
	DD	imagerel $chain$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN85+160
	DD	imagerel $LN85+185
	DD	imagerel $chain$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD imagerel $LN85+185
	DD	imagerel $LN85+191
	DD	imagerel $chain$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32
	DD	imagerel $LN32+122
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$0$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32+122
	DD	imagerel $LN32+360
	DD	imagerel $chain$0$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD imagerel $LN32+360
	DD	imagerel $LN32+447
	DD	imagerel $chain$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1673
	DD	imagerel $LN1673+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1673+307
	DD	imagerel $LN1673+1423
	DD	imagerel $chain$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1673+1423
	DD	imagerel $LN1673+1775
	DD	imagerel $chain$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1673+1775
	DD	imagerel $LN1673+3344
	DD	imagerel $chain$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN1673+3344
	DD	imagerel $LN1673+3362
	DD	imagerel $chain$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD imagerel $LN281
	DD	imagerel $LN281+1236
	DD	imagerel $unwind$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z DD imagerel $LN26
	DD	imagerel $LN26+617
	DD	imagerel $unwind$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD imagerel $LN222
	DD	imagerel $LN222+1193
	DD	imagerel $unwind$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA DD imagerel ?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
	DD	imagerel ?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA+38
	DD	imagerel $unwind$?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+210
	DD	imagerel $unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SprawdŸ_ustawienia@@YAXXZ DD imagerel $LN150
	DD	imagerel $LN150+2377
	DD	imagerel $unwind$?SprawdŸ_ustawienia@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA DD imagerel ?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	imagerel ?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA+46
	DD	imagerel $unwind$?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SprawdŸ_Pliki@@YAXXZ DD imagerel $LN4429
	DD	imagerel $LN4429+8532
	DD	imagerel $unwind$?SprawdŸ_Pliki@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA+38
	DD	imagerel $unwind$?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD imagerel ?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	imagerel ?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA+43
	DD	imagerel $unwind$?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel $LN2936
	DD	imagerel $LN2936+6668
	DD	imagerel $unwind$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel $LN2872
	DD	imagerel $LN2872+4088
	DD	imagerel $unwind$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+49
	DD	imagerel $unwind$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+38
	DD	imagerel $unwind$?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+54
	DD	imagerel $unwind$?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD imagerel ?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	imagerel ?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA+43
	DD	imagerel $unwind$?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wylosuj@@YAHAEBH0@Z DD imagerel $LN448
	DD	imagerel $LN448+502
	DD	imagerel $unwind$?Wylosuj@@YAHAEBH0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Show_Cursor@@YAXXZ DD imagerel $LN5
	DD	imagerel $LN5+97
	DD	imagerel $unwind$?Show_Cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Hide_Cursor@@YAXXZ DD imagerel $LN4
	DD	imagerel $LN4+90
	DD	imagerel $unwind$?Hide_Cursor@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Change_Col@@YAXAEBH@Z DD imagerel $LN4
	DD	imagerel $LN4+38
	DD	imagerel $unwind$?Change_Col@@YAXAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD imagerel $LN534
	DD	imagerel $LN534+877
	DD	imagerel $unwind$?Czy_Kontynuowaæ@@YA_NAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD imagerel $LN545
	DD	imagerel $LN545+962
	DD	imagerel $unwind$?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43
	DD	imagerel $LN43+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$1$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+29
	DD	imagerel $LN43+37
	DD	imagerel $chain$1$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$6$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+37
	DD	imagerel $LN43+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$7$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+204
	DD	imagerel $LN43+417
	DD	imagerel $chain$7$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$8$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+417
	DD	imagerel $LN43+510
	DD	imagerel $chain$8$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$9$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+510
	DD	imagerel $LN43+861
	DD	imagerel $chain$9$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$10$?Zakrêæ_Ruletk¹@@YAHXZ DD imagerel $LN43+861
	DD	imagerel $LN43+912
	DD	imagerel $chain$10$?Zakrêæ_Ruletk¹@@YAHXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD imagerel $LN154
	DD	imagerel $LN154+469
	DD	imagerel $unwind$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel $LN2010
	DD	imagerel $LN2010+2515
	DD	imagerel $unwind$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
	DD	imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA+38
	DD	imagerel $unwind$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+210
	DD	imagerel $unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD imagerel $LN4
	DD	imagerel $LN4+22
	DD	imagerel $unwind$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel $LN18
	DD	imagerel $LN18+210
	DD	imagerel $unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main DD	imagerel $LN112
	DD	imagerel $LN112+810
	DD	imagerel $unwind$main
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$main$dtor$5 DD imagerel main$dtor$5
	DD	imagerel main$dtor$5+49
	DD	imagerel $unwind$main$dtor$5
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??__FG³os@@YAXXZ DD imagerel ??__FG³os@@YAXXZ
	DD	imagerel ??__FG³os@@YAXXZ+114
	DD	imagerel $unwind$??__FG³os@@YAXXZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD imagerel $LN6
	DD	imagerel $LN6+24
	DD	imagerel $unwind$??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD imagerel $LN4
	DD	imagerel $LN4+24
	DD	imagerel $unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD imagerel $LN6
	DD	imagerel $LN6+41
	DD	imagerel $unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD imagerel $LN12
	DD	imagerel $LN12+83
	DD	imagerel $unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??1locale@std@@QEAA@XZ DD imagerel $LN6
	DD	imagerel $LN6+54
	DD	imagerel $unwind$??1locale@std@@QEAA@XZ
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gbad_cast@std@@UEAAPEAXI@Z DD imagerel $LN11
	DD	imagerel $LN11+67
	DD	imagerel $unwind$??_Gbad_cast@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Deallocate@std@@YAXPEAX_K1@Z DD imagerel $LN17
	DD	imagerel $LN17+59
	DD	imagerel $unwind$?_Deallocate@std@@YAXPEAX_K1@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?_Allocate@std@@YAPEAX_K0_N@Z DD imagerel $LN11
	DD	imagerel $LN11+91
	DD	imagerel $unwind$?_Allocate@std@@YAPEAX_K0_N@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD imagerel $LN4
	DD	imagerel $LN4+33
	DD	imagerel $unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z DD imagerel $LN4
	DD	imagerel $LN4+23
	DD	imagerel $unwind$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z DD imagerel $LN4
	DD	imagerel $LN4+14
	DD	imagerel $unwind$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??_Gexception@std@@UEAAPEAXI@Z DD imagerel $LN8
	DD	imagerel $LN8+67
	DD	imagerel $unwind$??_Gexception@std@@UEAAPEAXI@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$??0exception@std@@QEAA@AEBV01@@Z DD imagerel $LN4
	DD	imagerel $LN4+54
	DD	imagerel $unwind$??0exception@std@@QEAA@AEBV01@@Z
pdata	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$memcpy_s DD imagerel memcpy_s
	DD	imagerel memcpy_s+59
	DD	imagerel $unwind$memcpy_s
pdata	ENDS
CRT$XCU	SEGMENT
?G³os$initializer$@@3P6AXXZEA DQ FLAT:??__EG³os@@YAXXZ	; G³os$initializer$
CRT$XCU	ENDS
;	COMDAT __xmm@000000000000000f0000000000000000
CONST	SEGMENT
__xmm@000000000000000f0000000000000000 DB 00H, 00H, 00H, 00H, 00H, 00H, 00H
	DB	00H, 0fH, 00H, 00H, 00H, 00H, 00H, 00H, 00H
CONST	ENDS
;	COMDAT __real@4042800000000000
CONST	SEGMENT
__real@4042800000000000 DQ 04042800000000000r	; 37
CONST	ENDS
;	COMDAT __real@4040000000000000
CONST	SEGMENT
__real@4040000000000000 DQ 04040000000000000r	; 32
	ORG $+2
?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A DB 00H ; G³os
	DB	23 DUP(00H)
	DQ	000000000000000fH
_DATA	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$memcpy_s DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0exception@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gexception@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?compare@?$char_traits@D@std@@SAHQEBD0_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Allocate@std@@YAPEAX_K0_N@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Deallocate@std@@YAXPEAX_K1@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_Gbad_cast@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1locale@std@@QEAA@XZ DD imagerel ??1locale@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1locale@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1locale@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1locale@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1locale@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??__FG³os@@YAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main$dtor$5 DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$main DD imagerel main
	DD	0ffffffffH
	DD	imagerel main+191
	DD	00H
	DD	imagerel main+318
	DD	01H
	DD	imagerel main+344
	DD	02H
	DD	imagerel main+402
	DD	03H
	DD	imagerel main+458
	DD	04H
	DD	imagerel main+487
	DD	05H
	DD	imagerel main+664
	DD	04H
	DD	imagerel main+754
	DD	00H
	DD	imagerel main+764
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$main DD 0ffffffffH
	DD	imagerel main$dtor$0
	DD	00H
	DD	imagerel main$dtor$5
	DD	01H
	DD	imagerel main$dtor$6
	DD	02H
	DD	imagerel main$dtor$8
	DD	00H
	DD	imagerel main$dtor$1
	DD	04H
	DD	imagerel main$dtor$2
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$main DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$main
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$main
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$main DD	053319H
	DD	05a3422H
	DD	0580111H
	DD	05002H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$main
	DD	02b2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD imagerel ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	0ffffffffH
	DD	imagerel ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ+22
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ DD 021311H
	DD	03006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	0ffffffffH
	DD	imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z+80
	DD	00H
	DD	imagerel ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z+369
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z DD 062819H
	DD	0f6419H
	DD	0e3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$10$?Zakrêæ_Ruletk¹@@YAHXZ DD 021H
	DD	imagerel $LN43
	DD	imagerel $LN43+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$9$?Zakrêæ_Ruletk¹@@YAHXZ DD 040021H
	DD	066800H
	DD	0fd400H
	DD	imagerel $LN43+29
	DD	imagerel $LN43+37
	DD	imagerel $chain$1$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$8$?Zakrêæ_Ruletk¹@@YAHXZ DD 021H
	DD	imagerel $LN43+37
	DD	imagerel $LN43+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$7$?Zakrêæ_Ruletk¹@@YAHXZ DD 020521H
	DD	0ee405H
	DD	imagerel $LN43+37
	DD	imagerel $LN43+204
	DD	imagerel $chain$6$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?Zakrêæ_Ruletk¹@@YAHXZ DD 0a1721H
	DD	048817H
	DD	057812H
	DD	06680dH
	DD	0fd408H
	DD	016c404H
	DD	imagerel $LN43+29
	DD	imagerel $LN43+37
	DD	imagerel $chain$1$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?Zakrêæ_Ruletk¹@@YAHXZ DD 040821H
	DD	0156408H
	DD	0145404H
	DD	imagerel $LN43
	DD	imagerel $LN43+29
	DD	imagerel $unwind$?Zakrêæ_Ruletk¹@@YAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Zakrêæ_Ruletk¹@@YAHXZ DD 041d19H
	DD	0f007f20eH
	DD	030047005H
	DD	imagerel __GSHandlerCheck
	DD	030H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	0ffffffffH
	DD	imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z+62
	DD	00H
	DD	imagerel ?Czy_Kontynuowaæ@@YA_NAEBH@Z+785
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Czy_Kontynuowaæ@@YA_NAEBH@Z DD 042319H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Czy_Kontynuowaæ@@YA_NAEBH@Z
	DD	04aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Change_Col@@YAXAEBH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Hide_Cursor@@YAXXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Show_Cursor@@YAXXZ DD 021519H
	DD	030025206H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Wylosuj@@YAHAEBH0@Z DD imagerel ?Wylosuj@@YAHAEBH0@Z
	DD	0ffffffffH
	DD	imagerel ?Wylosuj@@YAHAEBH0@Z+92
	DD	00H
	DD	imagerel ?Wylosuj@@YAHAEBH0@Z+99
	DD	0ffffffffH
	DD	imagerel ?Wylosuj@@YAHAEBH0@Z+287
	DD	01H
	DD	imagerel ?Wylosuj@@YAHAEBH0@Z+294
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Wylosuj@@YAHAEBH0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Wylosuj@@YAHAEBH0@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$1@?0??Wylosuj@@YAHAEBH0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Wylosuj@@YAHAEBH0@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?Wylosuj@@YAHAEBH0@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$?Wylosuj@@YAHAEBH0@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wylosuj@@YAHAEBH0@Z DD 0a2011H
	DD	0106420H
	DD	0f541cH
	DD	0e3418H
	DD	0f008920cH
	DD	07004e006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Wylosuj@@YAHAEBH0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	0ffffffffH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+173
	DD	00H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+205
	DD	01H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+280
	DD	02H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+308
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+341
	DD	04H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+400
	DD	05H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+580
	DD	04H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+669
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+864
	DD	06H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1011
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1091
	DD	07H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1238
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1420
	DD	08H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1567
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1640
	DD	09H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1787
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+1964
	DD	0aH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2111
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2184
	DD	0bH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2331
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2425
	DD	0cH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2683
	DD	0dH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2865
	DD	0cH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+2954
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3088
	DD	0eH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3114
	DD	0fH
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3164
	DD	010H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3183
	DD	011H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3229
	DD	013H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3468
	DD	014H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3648
	DD	013H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3738
	DD	012H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3828
	DD	011H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3898
	DD	03H
	DD	imagerel ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z+3959
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	04H
	DD	imagerel ?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0cH
	DD	imagerel ?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0eH
	DD	imagerel ?dtor$407@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	0fH
	DD	imagerel ?dtor$409@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	03H
	DD	imagerel ?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	011H
	DD	imagerel ?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	012H
	DD	imagerel ?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
	DD	013H
	DD	imagerel ?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 019930522H
	DD	015H
	DD	imagerel $stateUnwindMap$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	00H
	DD	00H
	DD	024H
	DD	imagerel $ip2state$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	090H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 0d3f19H
	DD	063742eH
	DD	062642aH
	DD	0613426H
	DD	05a011aH
	DD	0e00af00cH
	DD	0c006d008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
	DD	02c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	0ffffffffH
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+281
	DD	00H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+296
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+962
	DD	02H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+1112
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+1584
	DD	03H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+3255
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+3553
	DD	04H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+4679
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5056
	DD	05H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5479
	DD	01H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5802
	DD	00H
	DD	imagerel ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z+5892
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	00H
	DD	00H
	DD	0dH
	DD	imagerel $ip2state$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	038H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z DD 0a2f19H
	DD	0170119H
	DD	0e00bf00dH
	DD	0c007d009H
	DD	060047005H
	DD	050023003H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
	DD	0a2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SprawdŸ_Pliki@@YAXXZ DD imagerel ?SprawdŸ_Pliki@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+874
	DD	00H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+876
	DD	0ffffffffH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1171
	DD	00H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1302
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1565
	DD	02H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1710
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1852
	DD	03H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1914
	DD	04H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+1939
	DD	05H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2153
	DD	04H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2241
	DD	03H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2331
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2411
	DD	06H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2558
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2702
	DD	07H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2764
	DD	08H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+2789
	DD	09H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3001
	DD	08H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3089
	DD	07H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3179
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3260
	DD	0aH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3405
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3548
	DD	0bH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3610
	DD	0cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3635
	DD	0dH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3850
	DD	0cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+3938
	DD	0bH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4028
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4108
	DD	0eH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4256
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4400
	DD	0fH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4462
	DD	010H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4487
	DD	011H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4702
	DD	010H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4790
	DD	0fH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4880
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+4961
	DD	012H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5106
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5249
	DD	013H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5311
	DD	014H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5336
	DD	015H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5551
	DD	014H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5639
	DD	013H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5729
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5806
	DD	016H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+5953
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6096
	DD	017H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6158
	DD	018H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6183
	DD	019H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6391
	DD	018H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6479
	DD	017H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6569
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6674
	DD	01aH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6696
	DD	01bH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6746
	DD	01aH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6757
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6835
	DD	01cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6855
	DD	01dH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6872
	DD	01eH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6894
	DD	01fH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6919
	DD	020H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6940
	DD	021H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+6958
	DD	022H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7030
	DD	021H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7041
	DD	020H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7052
	DD	01fH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7063
	DD	01eH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7073
	DD	01dH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7083
	DD	01cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7093
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7193
	DD	023H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7229
	DD	024H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7246
	DD	025H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7262
	DD	026H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7312
	DD	025H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7322
	DD	024H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7332
	DD	023H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7411
	DD	027H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7428
	DD	028H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7449
	DD	029H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7466
	DD	02aH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7489
	DD	02bH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7508
	DD	02cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7532
	DD	02dH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7552
	DD	02eH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7568
	DD	02fH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7640
	DD	02eH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7650
	DD	02dH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7660
	DD	02cH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7670
	DD	02bH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7680
	DD	02aH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7691
	DD	029H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7702
	DD	028H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7713
	DD	027H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7723
	DD	023H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7736
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7764
	DD	023H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7806
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7849
	DD	030H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7883
	DD	031H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7896
	DD	032H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7946
	DD	031H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+7956
	DD	030H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8036
	DD	033H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8053
	DD	034H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8069
	DD	035H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8091
	DD	036H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8110
	DD	037H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8134
	DD	038H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8150
	DD	039H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8222
	DD	038H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8232
	DD	037H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8242
	DD	036H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8252
	DD	035H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8262
	DD	034H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8272
	DD	033H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8282
	DD	030H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8296
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8324
	DD	030H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8366
	DD	01H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8421
	DD	00H
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8434
	DD	0ffffffffH
	DD	imagerel ?SprawdŸ_Pliki@@YAXXZ+8496
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SprawdŸ_Pliki@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$5@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	03H
	DD	imagerel ?dtor$6@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	04H
	DD	imagerel ?dtor$7@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$10@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	07H
	DD	imagerel ?dtor$11@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	08H
	DD	imagerel ?dtor$12@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$15@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	0bH
	DD	imagerel ?dtor$16@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	0cH
	DD	imagerel ?dtor$17@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$20@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	0fH
	DD	imagerel ?dtor$21@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	010H
	DD	imagerel ?dtor$22@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$25@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	013H
	DD	imagerel ?dtor$26@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	014H
	DD	imagerel ?dtor$27@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$30@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	017H
	DD	imagerel ?dtor$31@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	018H
	DD	imagerel ?dtor$32@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$34@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01aH
	DD	imagerel ?dtor$35@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$37@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01cH
	DD	imagerel ?dtor$38@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01dH
	DD	imagerel ?dtor$39@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01eH
	DD	imagerel ?dtor$40@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01fH
	DD	imagerel ?dtor$41@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	020H
	DD	imagerel ?dtor$42@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	021H
	DD	imagerel ?dtor$43@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$45@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	023H
	DD	imagerel ?dtor$46@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	024H
	DD	imagerel ?dtor$47@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	025H
	DD	imagerel ?dtor$48@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	023H
	DD	imagerel ?dtor$50@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	027H
	DD	imagerel ?dtor$51@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	028H
	DD	imagerel ?dtor$52@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	029H
	DD	imagerel ?dtor$53@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	02aH
	DD	imagerel ?dtor$54@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	02bH
	DD	imagerel ?dtor$55@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	02cH
	DD	imagerel ?dtor$56@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	02dH
	DD	imagerel ?dtor$57@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	02eH
	DD	imagerel ?dtor$58@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$60@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	030H
	DD	imagerel ?dtor$61@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	031H
	DD	imagerel ?dtor$62@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	030H
	DD	imagerel ?dtor$64@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	033H
	DD	imagerel ?dtor$65@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	034H
	DD	imagerel ?dtor$66@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	035H
	DD	imagerel ?dtor$67@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	036H
	DD	imagerel ?dtor$68@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	037H
	DD	imagerel ?dtor$69@?0??SprawdŸ_Pliki@@YAXXZ@4HA
	DD	038H
	DD	imagerel ?dtor$70@?0??SprawdŸ_Pliki@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?SprawdŸ_Pliki@@YAXXZ DD 019930522H
	DD	03aH
	DD	imagerel $stateUnwindMap$?SprawdŸ_Pliki@@YAXXZ
	DD	00H
	DD	00H
	DD	07cH
	DD	imagerel $ip2state$?SprawdŸ_Pliki@@YAXXZ
	DD	0178H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SprawdŸ_Pliki@@YAXXZ DD 0d3f19H
	DD	061c42eH
	DD	060742aH
	DD	05f6426H
	DD	05e3422H
	DD	05a0116H
	DD	0e006f008H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?SprawdŸ_Pliki@@YAXXZ
	DD	02c2H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?SprawdŸ_ustawienia@@YAXXZ DD imagerel ?SprawdŸ_ustawienia@@YAXXZ
	DD	0ffffffffH
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+124
	DD	00H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+151
	DD	01H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+213
	DD	02H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+261
	DD	03H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+348
	DD	04H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+431
	DD	03H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+517
	DD	0ffffffffH
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+559
	DD	05H
	DD	imagerel ?SprawdŸ_ustawienia@@YAXXZ+1027
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?SprawdŸ_ustawienia@@YAXXZ DD 0ffffffffH
	DD	imagerel ?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	00H
	DD	imagerel ?dtor$5@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	01H
	DD	imagerel ?dtor$7@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	03H
	DD	imagerel ?dtor$1@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$2@?0??SprawdŸ_ustawienia@@YAXXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?SprawdŸ_ustawienia@@YAXXZ DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$?SprawdŸ_ustawienia@@YAXXZ
	DD	00H
	DD	00H
	DD	0aH
	DD	imagerel $ip2state$?SprawdŸ_ustawienia@@YAXXZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?SprawdŸ_ustawienia@@YAXXZ DD 093319H
	DD	0347425H
	DD	0336421H
	DD	032341dH
	DD	0300110H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?SprawdŸ_ustawienia@@YAXXZ
	DD	0172H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	0ffffffffH
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+84
	DD	00H
	DD	imagerel ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ+176
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD imagerel ?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	0ffffffffH
	DD	imagerel ?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z+346
	DD	00H
	DD	imagerel ?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z+497
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
	DD	048H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z DD 091a11H
	DD	0f00da211H
	DD	0d009e00bH
	DD	07005c007H
	DD	050036004H
	DD	03002H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z DD 081501H
	DD	087415H
	DD	076415H
	DD	063415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z DD 0af701H
	DD	01374f7H
	DD	0f0159219H
	DD	0d011e013H
	DD	0600dc00fH
	DD	0300b500cH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021H
	DD	imagerel $LN1673
	DD	imagerel $LN1673+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020021H
	DD	0bf400H
	DD	imagerel $LN1673
	DD	imagerel $LN1673+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 021H
	DD	imagerel $LN1673
	DD	imagerel $LN1673+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 020521H
	DD	0bf405H
	DD	imagerel $LN1673
	DD	imagerel $LN1673+307
	DD	imagerel $unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z DD 082a01H
	DD	0ae42aH
	DD	096425H
	DD	070043208H
	DD	030025003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+122
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 020421H
	DD	03404H
	DD	imagerel $LN32
	DD	imagerel $LN32+122
	DD	imagerel $unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ DD 010401H
	DD	0204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 021H
	DD	imagerel $LN85
	DD	imagerel $LN85+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020021H
	DD	087400H
	DD	imagerel $LN85
	DD	imagerel $LN85+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 043921H
	DD	066439H
	DD	087405H
	DD	imagerel $LN85
	DD	imagerel $LN85+49
	DD	imagerel $unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 021H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040021H
	DD	07e400H
	DD	063400H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 040d21H
	DD	07e40dH
	DD	063405H
	DD	imagerel $LN46
	DD	imagerel $LN46+86
	DD	imagerel $unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z DD 060f01H
	DD	09640fH
	DD	08540fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 021H
	DD	imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 020521H
	DD	043405H
	DD	imagerel $LN33
	DD	imagerel $LN33+21
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020021H
	DD	077400H
	DD	imagerel $LN52
	DD	imagerel $LN52+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 041c21H
	DD	06641cH
	DD	077405H
	DD	imagerel $LN52
	DD	imagerel $LN52+22
	DD	imagerel $unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 021H
	DD	imagerel $LN55
	DD	imagerel $LN55+54
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 020521H
	DD	066405H
	DD	imagerel $LN55
	DD	imagerel $LN55+54
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 021H
	DD	imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN47
	DD	imagerel $LN47+44
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z DD 062b01H
	DD	0a542bH
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+71
	DD	00H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+99
	DD	01H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+149
	DD	02H
	DD	imagerel ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+206
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+60
	DD	00H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+91
	DD	01H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+141
	DD	02H
	DD	imagerel ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+198
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+82
	DD	00H
	DD	imagerel ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ+174
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+60
	DD	00H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+91
	DD	01H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+141
	DD	02H
	DD	imagerel ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ+198
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 041411H
	DD	0d3414H
	DD	070029206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 061c19H
	DD	0d340dH
	DD	0e009520dH
	DD	060067007H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 061a19H
	DD	0e007520bH
	DD	060047005H
	DD	030025003H
	DD	imagerel __GSHandlerCheck
	DD	028H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	0ffffffffH
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+228
	DD	00H
	DD	imagerel ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ+672
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 072d19H
	DD	016741fH
	DD	015341bH
	DD	012010fH
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020021H
	DD	067400H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020521H
	DD	067405H
	DD	imagerel $LN26
	DD	imagerel $LN26+51
	DD	imagerel $unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	0ffffffffH
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+257
	DD	00H
	DD	imagerel ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z+618
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z DD 093019H
	DD	0196422H
	DD	018341eH
	DD	0120112H
	DD	07005e007H
	DD	05004H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
	DD	082H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD imagerel ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 041919H
	DD	012340aH
	DD	07006d20aH
	DD	imagerel __GSHandlerCheck
	DD	060H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+75
	DD	00H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+103
	DD	01H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+153
	DD	02H
	DD	imagerel ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+178
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	00H
	DD	imagerel ?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
	DD	01H
	DD	imagerel ?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	03H
	DD	imagerel $stateUnwindMap$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	05H
	DD	imagerel $ip2state$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 041d11H
	DD	09341dH
	DD	0700b520fH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 021H
	DD	imagerel $LN58
	DD	imagerel $LN58+56
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 020521H
	DD	027405H
	DD	imagerel $LN58
	DD	imagerel $LN58+56
	DD	imagerel $unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z DD 010201H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z DD 052b01H
	DD	02642bH
	DD	033406H
	DD	07006H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 020021H
	DD	0a7400H
	DD	imagerel $LN131
	DD	imagerel $LN131+43
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$6$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 020021H
	DD	0be400H
	DD	imagerel $LN131+530
	DD	imagerel $LN131+561
	DD	imagerel $chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 060f21H
	DD	04f40fH
	DD	0be40aH
	DD	096405H
	DD	imagerel $LN131+530
	DD	imagerel $LN131+561
	DD	imagerel $chain$2$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 020521H
	DD	0a7405H
	DD	imagerel $LN131
	DD	imagerel $LN131+43
	DD	imagerel $unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z DD 030701H
	DD	050034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	0ffffffffH
	DD	imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z+25
	DD	00H
	DD	imagerel ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z+115
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z DD 041419H
	DD	083414H
	DD	070025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ DD 020501H
	DD	013405H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+39
	DD	00H
	DD	imagerel ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ+66
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 020f19H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+57
	DD	00H
	DD	imagerel ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z+110
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 060021H
	DD	04e400H
	DD	0a7400H
	DD	095400H
	DD	imagerel $LN154
	DD	imagerel $LN154+58
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 064221H
	DD	0a7442H
	DD	095436H
	DD	04e405H
	DD	imagerel $LN154
	DD	imagerel $LN154+58
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 030701H
	DD	060034207H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 021H
	DD	imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 020521H
	DD	066405H
	DD	imagerel $LN32
	DD	imagerel $LN32+35
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	066405H
	DD	imagerel $LN24
	DD	imagerel $LN24+25
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	07340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 020521H
	DD	083405H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 021H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 020521H
	DD	083405H
	DD	imagerel $LN24
	DD	imagerel $LN24+35
	DD	imagerel $unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z DD 040a01H
	DD	09640aH
	DD	07006520aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z DD 064101H
	DD	0a5441H
	DD	070043208H
	DD	030026003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 021H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020021H
	DD	087400H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 043921H
	DD	076439H
	DD	087405H
	DD	imagerel $LN77
	DD	imagerel $LN77+49
	DD	imagerel $unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	0ffffffffH
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+120
	DD	00H
	DD	imagerel ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ+391
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	030H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ DD 082d19H
	DD	013741fH
	DD	012641bH
	DD	0113417H
	DD	05004d20bH
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
	DD	062H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z DD 061e19H
	DD	0d640fH
	DD	0c340fH
	DD	0700b720fH
	DD	imagerel __GSHandlerCheck
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ DD 060f01H
	DD	08640fH
	DD	07340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	0ffffffffH
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+97
	DD	00H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+145
	DD	01H
	DD	imagerel ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z+181
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 019930522H
	DD	02H
	DD	imagerel $stateUnwindMap$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	00H
	DD	00H
	DD	04H
	DD	imagerel $ip2state$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z DD 041411H
	DD	0a3414H
	DD	070027206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+30
	DD	00H
	DD	imagerel ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z+81
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ DD 041919H
	DD	0e340aH
	DD	07006920aH
	DD	imagerel __GSHandlerCheck
	DD	040H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	0ffffffffH
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+25
	DD	00H
	DD	imagerel ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z+44
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z DD 020f11H
	DD	030025206H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?allocate@?$allocator@D@std@@QEAAPEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 021H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 020021H
	DD	087400H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 043921H
	DD	076439H
	DD	087405H
	DD	imagerel $LN51
	DD	imagerel $LN51+30
	DD	imagerel $unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z+55
	DD	00H
	DD	imagerel ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z+229
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z DD 062719H
	DD	0106418H
	DD	0f3414H
	DD	07004b208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+113
	DD	00H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+167
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+181
	DD	02H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+338
	DD	01H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+379
	DD	04H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+399
	DD	05H
	DD	imagerel ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z+424
	DD	0ffffffffH
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	00H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	01H
	DD	imagerel $tryMap$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	0bH
	DD	imagerel $ip2state$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD 021H
	DD	imagerel $LN93
	DD	imagerel $LN93+62
	DD	imagerel $unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD 020521H
	DD	066405H
	DD	imagerel $LN93
	DD	imagerel $LN93+62
	DD	imagerel $unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z DD 081501H
	DD	097415H
	DD	085415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z+45
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z DD 0a2411H
	DD	0e5424H
	DD	0d341fH
	DD	0f00d5211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z+38
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z DD 082011H
	DD	0c5420H
	DD	0b341bH
	DD	0e009520dH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z DD 040a01H
	DD	08340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 040a01H
	DD	06340aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA DD 020601H
	DD	050023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	0ffffffffH
	DD	imagerel ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z+38
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	00H
	DD	00H
	DD	02H
	DD	imagerel $ip2state$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
	DD	028H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z DD 082011H
	DD	0c5420H
	DD	0b341bH
	DD	0e009520dH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 021H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 040021H
	DD	075400H
	DD	063400H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 040a21H
	DD	07540aH
	DD	063405H
	DD	imagerel $LN26
	DD	imagerel $LN26+60
	DD	imagerel $unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z DD 061001H
	DD	097410H
	DD	086410H
	DD	0e00c3210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+55
	DD	00H
	DD	imagerel ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z+229
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z DD 062719H
	DD	0106418H
	DD	0f3414H
	DD	07004b208H
	DD	imagerel __GSHandlerCheck_EH
	DD	imagerel $cppxdata$??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
	DD	052H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 084e21H
	DD	0de44eH
	DD	0b6445H
	DD	04f40eH
	DD	0cc405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z+47
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z DD 050a01H
	DD	0d006420aH
	DD	050037004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z DD 084c01H
	DD	0a644cH
	DD	093443H
	DD	0e0053209H
	DD	050027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$5$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 021H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 060021H
	DD	04e400H
	DD	057400H
	DD	065400H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 064521H
	DD	057445H
	DD	065439H
	DD	04e405H
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
	DD	imagerel ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z+39
	DD	imagerel $unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z DD 050b01H
	DD	0f007620bH
	DD	06003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 084e21H
	DD	05e44eH
	DD	0e7445H
	DD	04f40eH
	DD	06d405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z+45
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z DD 050a01H
	DD	0c006620aH
	DD	050036004H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 084e21H
	DD	04e44eH
	DD	0e5442H
	DD	05d40eH
	DD	066405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z+46
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z DD 050b01H
	DD	0f007620bH
	DD	07003c005H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0bad_cast@std@@QEAA@AEBV01@@Z DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020021H
	DD	063400H
	DD	imagerel $LN64
	DD	imagerel $LN64+72
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 021H
	DD	imagerel $LN64
	DD	imagerel $LN64+72
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 020521H
	DD	063405H
	DD	imagerel $LN64
	DD	imagerel $LN64+72
	DD	imagerel $unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z DD 040a01H
	DD	07640aH
	DD	07006320aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 021H
	DD	imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 041521H
	DD	09f415H
	DD	086405H
	DD	imagerel $LN52
	DD	imagerel $LN52+59
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z DD 061001H
	DD	0b7410H
	DD	0a3410H
	DD	0e00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$2$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 021H
	DD	imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 041521H
	DD	096415H
	DD	083405H
	DD	imagerel $LN36
	DD	imagerel $LN36+48
	DD	imagerel $unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z DD 061001H
	DD	0be410H
	DD	0a7410H
	DD	0f00c5210H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z DD 081401H
	DD	086414H
	DD	075414H
	DD	063414H
	DD	070103214H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA DD 020a19H
	DD	05006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0ffffffffH
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+88
	DD	00H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+103
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+133
	DD	02H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+144
	DD	03H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+179
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+203
	DD	04H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+408
	DD	01H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+476
	DD	06H
	DD	imagerel ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z+501
	DD	0ffffffffH
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	00H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+13
	DD	05H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	048H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 04H
	DD	04H
	DD	05H
	DD	01H
	DD	imagerel $handlerMap$0$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0ffffffffH
	DD	imagerel ?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	01H
	DD	imagerel ?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA
	DD	01H
	DD	imagerel __imp___std_terminate
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 019930522H
	DD	07H
	DD	imagerel $stateUnwindMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	01H
	DD	imagerel $tryMap$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	0dH
	DD	imagerel $ip2state$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
	DD	050H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z DD 0a2019H
	DD	0176420H
	DD	016341cH
	DD	0f00cd210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$1$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD 021H
	DD	imagerel $LN91
	DD	imagerel $LN91+62
	DD	imagerel $unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$0$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD 020521H
	DD	066405H
	DD	imagerel $LN91
	DD	imagerel $LN91+62
	DD	imagerel $unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z DD 081501H
	DD	097415H
	DD	085415H
	DD	073415H
	DD	0e0113215H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	0ffffffffH
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+92
	DD	00H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+107
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+115
	DD	02H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+237
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+239
	DD	02H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+323
	DD	01H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+373
	DD	04H
	DD	imagerel ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z+398
	DD	0ffffffffH
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	00H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 019930522H
	DD	05H
	DD	imagerel $stateUnwindMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	01H
	DD	imagerel $tryMap$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	0cH
	DD	imagerel $ip2state$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
	DD	040H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z DD 0a2019H
	DD	0136420H
	DD	012341cH
	DD	0f00c9210H
	DD	0d008e00aH
	DD	07004c006H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA DD 020a19H
	DD	05006320aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0ffffffffH
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+103
	DD	00H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+157
	DD	01H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+171
	DD	02H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+354
	DD	01H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+395
	DD	04H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+415
	DD	05H
	DD	imagerel ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z+439
	DD	0ffffffffH
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	00H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+13
	DD	03H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA+42
	DD	00H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$handlerMap$0$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 040H
	DD	00H
	DD	00H
	DD	imagerel ?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	038H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 02H
	DD	02H
	DD	03H
	DD	01H
	DD	imagerel $handlerMap$0$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 0ffffffffH
	DD	imagerel ?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	0ffffffffH
	DD	imagerel ?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA
	DD	01H
	DD	00H
	DD	01H
	DD	00H
	DD	0ffffffffH
	DD	imagerel __imp___std_terminate
	DD	04H
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 019930522H
	DD	06H
	DD	imagerel $stateUnwindMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	01H
	DD	imagerel $tryMap$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	0bH
	DD	imagerel $ip2state$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z DD 081f19H
	DD	0f341fH
	DD	0f00d7211H
	DD	0c009e00bH
	DD	060067007H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z DD 010401H
	DD	04204H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 084e21H
	DD	0d644eH
	DD	0c5442H
	DD	04e40eH
	DD	05c405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z+41
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z DD 040901H
	DD	0f0055209H
	DD	030027003H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$4$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 021H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+52
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$chain$3$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 084e21H
	DD	06644eH
	DD	0e5442H
	DD	04f40eH
	DD	057405H
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
	DD	imagerel ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z+52
	DD	imagerel $unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z DD 050c01H
	DD	0e008620cH
	DD	0c004d006H
	DD	03002H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ+13
	DD	00H
	DD	imagerel ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ+40
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 0ffffffffH
	DD	imagerel __imp___std_terminate
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ DD 060f01H
	DD	07640fH
	DD	06340fH
	DD	0700b320fH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z DD 0a1a01H
	DD	09741aH
	DD	08641aH
	DD	07541aH
	DD	06341aH
	DD	0e016321aH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	0ffffffffH
	DD	imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z+58
	DD	00H
	DD	imagerel ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z+74
	DD	0ffffffffH
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 0ffffffffH
	DD	imagerel ?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 019930522H
	DD	01H
	DD	imagerel $stateUnwindMap$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	00H
	DD	00H
	DD	03H
	DD	imagerel $ip2state$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
	DD	020H
	DD	00H
	DD	01H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z DD 041811H
	DD	093418H
	DD	07006520aH
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD imagerel ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	0ffffffffH
xdata	ENDS
;	COMDAT CONST
CONST	SEGMENT
$cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 019930522H
	DD	00H
	DD	00H
	DD	00H
	DD	00H
	DD	01H
	DD	imagerel $ip2state$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
	DD	020H
	DD	00H
	DD	05H
CONST	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ DD 010d19H
	DD	06204H
	DD	imagerel __CxxFrameHandler3
	DD	imagerel $cppxdata$??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ DD 020601H
	DD	030023206H
xdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z DD 020601H
	DD	030023206H
xdata	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
;	COMDAT time
_TEXT	SEGMENT
_Time$dead$ = 8
time	PROC						; COMDAT

; 535  :             return _time64(_Time);

  00000	33 c9		 xor	 ecx, ecx
  00002	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__time64
time	ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
;	COMDAT memcpy_s
_TEXT	SEGMENT
_Destination$ = 48
_DestinationSize$dead$ = 56
_Source$ = 64
_SourceSize$dead$ = 72
memcpy_s PROC						; COMDAT

; 41   :     {

  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 42   :         if (_SourceSize == 0)
; 43   :         {
; 44   :             return 0;
; 45   :         }
; 46   : 
; 47   :         _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Destination != NULL, EINVAL);

  00004	48 85 c9	 test	 rcx, rcx
  00007	74 16		 je	 SHORT $LN10@memcpy_s

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  00009	4d 85 c0	 test	 r8, r8
  0000c	74 0d		 je	 SHORT $LN5@memcpy_s

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  0000e	41 0f b6 00	 movzx	 eax, BYTE PTR [r8]
  00012	88 01		 mov	 BYTE PTR [rcx], al

; 60   :         return 0;

  00014	33 c0		 xor	 eax, eax

; 61   :     }

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	c3		 ret	 0
$LN5@memcpy_s:

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  0001b	33 c0		 xor	 eax, eax
  0001d	88 01		 mov	 BYTE PTR [rcx], al
$LN10@memcpy_s:

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  0001f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00025	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
  00031	b8 16 00 00 00	 mov	 eax, 22

; 61   :     }

  00036	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003a	c3		 ret	 0
memcpy_s ENDP
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@QEBDH@Z
_TEXT	SEGMENT
this$ = 8
_Message$ = 16
__formal$ = 24
??0exception@std@@QEAA@QEBDH@Z PROC			; std::exception::exception, COMDAT

; 60   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax
  0000a	33 c0		 xor	 eax, eax
  0000c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 61   :         _Data._What = _Message;
; 62   :     }

  00010	48 8b c1	 mov	 rax, rcx
  00013	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00017	c3		 ret	 0
??0exception@std@@QEAA@QEBDH@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0exception@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Other$ = 56
??0exception@std@@QEAA@AEBV01@@Z PROC			; std::exception::exception, COMDAT

; 66   :     {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx
  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]
  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy

; 68   :     }

  0002d	48 8b c3	 mov	 rax, rbx
  00030	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00034	5b		 pop	 rbx
  00035	c3		 ret	 0
??0exception@std@@QEAA@AEBV01@@Z ENDP			; std::exception::exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??1exception@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1exception@std@@UEAA@XZ PROC				; std::exception::~exception, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1exception@std@@UEAA@XZ ENDP				; std::exception::~exception
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ?what@exception@std@@UEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?what@exception@std@@UEBAPEBDXZ PROC			; std::exception::what, COMDAT

; 89   :         return _Data._What ? _Data._What : "Unknown exception";

  00000	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00004	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BC@EOODALEL@Unknown?5exception?$AA@
  0000b	48 85 d2	 test	 rdx, rdx
  0000e	48 0f 45 c2	 cmovne	 rax, rdx

; 90   :     }

  00012	c3		 ret	 0
?what@exception@std@@UEBAPEBDXZ ENDP			; std::exception::what
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??_Gexception@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gexception@std@@UEAAPEAXI@Z PROC			; std::exception::`scalar deleting destructor', COMDAT
$LN8:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN6@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN6@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gexception@std@@UEAAPEAXI@Z ENDP			; std::exception::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\limits
;	COMDAT ?max@?$numeric_limits@_J@std@@SA_JXZ
_TEXT	SEGMENT
?max@?$numeric_limits@_J@std@@SA_JXZ PROC		; std::numeric_limits<__int64>::max, COMDAT

; 973  : 		return (LLONG_MAX);

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 974  : 		}

  0000a	c3		 ret	 0
?max@?$numeric_limits@_J@std@@SA_JXZ ENDP		; std::numeric_limits<__int64>::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_new.h
;	COMDAT ??2@YAPEAX_KPEAX@Z
_TEXT	SEGMENT
_Size$dead$ = 8
_Where$ = 16
??2@YAPEAX_KPEAX@Z PROC					; operator new, COMDAT

; 92   :         (void)_Size;
; 93   :         return _Where;

  00000	48 8b c2	 mov	 rax, rdx

; 94   :     }

  00003	c3		 ret	 0
??2@YAPEAX_KPEAX@Z ENDP					; operator new
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?compare@?$char_traits@D@std@@SAHQEBD0_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?compare@?$char_traits@D@std@@SAHQEBD0_K@Z PROC		; std::char_traits<char>::compare, COMDAT

; 474  : 		{	// compare [_First1, _First1 + _Count) with [_First2, ...)

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00004	e8 00 00 00 00	 call	 memcmp

; 476  : 		}

  00009	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000d	c3		 ret	 0
?compare@?$char_traits@D@std@@SAHQEBD0_K@Z ENDP		; std::char_traits<char>::compare
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?length@?$char_traits@D@std@@SA_KQEBD@Z
_TEXT	SEGMENT
_First$ = 8
?length@?$char_traits@D@std@@SA_KQEBD@Z PROC		; std::char_traits<char>::length, COMDAT

; 480  : 		return (_CSTD strlen(_First));

  00000	48 83 c8 ff	 or	 rax, -1
$LL3@length:
  00004	48 ff c0	 inc	 rax
  00007	80 3c 01 00	 cmp	 BYTE PTR [rcx+rax], 0
  0000b	75 f7		 jne	 SHORT $LL3@length

; 481  : 		}

  0000d	c3		 ret	 0
?length@?$char_traits@D@std@@SA_KQEBD@Z ENDP		; std::char_traits<char>::length
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 48
_First2$ = 56
_Count$ = 64
?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z PROC	; std::char_traits<char>::copy, COMDAT

; 485  : 		{	// copy [_First2, _First2 + _Count) to [_First1, ...)

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00009	e8 00 00 00 00	 call	 memcpy
  0000e	48 8b c3	 mov	 rax, rbx

; 487  : 		}

  00011	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00015	5b		 pop	 rbx
  00016	c3		 ret	 0
?copy@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z ENDP	; std::char_traits<char>::copy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z
_TEXT	SEGMENT
_First$ = 8
_Count$ = 16
_Ch$ = 24
?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z PROC	; std::char_traits<char>::find, COMDAT

; 499  : 		{	// look for _Ch in [_First, _First + _Count)

  00000	48 8b c2	 mov	 rax, rdx

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00003	41 0f be 10	 movsx	 edx, BYTE PTR [r8]
  00007	4c 8b c0	 mov	 r8, rax
  0000a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memchr
?find@?$char_traits@D@std@@SAPEBDQEBD_KAEBD@Z ENDP	; std::char_traits<char>::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z
_TEXT	SEGMENT
_First1$ = 8
_First2$ = 16
_Count$ = 24
?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z PROC	; std::char_traits<char>::move, COMDAT

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_memmove
?move@?$char_traits@D@std@@SAPEADQEADQEBD_K@Z ENDP	; std::char_traits<char>::move
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z
_TEXT	SEGMENT
_First$ = 48
_Count$ = 56
_Ch$ = 64
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z PROC	; std::char_traits<char>::assign, COMDAT

; 511  : 		{	// assign _Count * _Ch to [_First, ...)

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b c2	 mov	 rax, rdx
  00009	48 8b d9	 mov	 rbx, rcx

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0000c	41 0f be d0	 movsx	 edx, r8b
  00010	4c 8b c0	 mov	 r8, rax
  00013	e8 00 00 00 00	 call	 memset
  00018	48 8b c3	 mov	 rax, rbx

; 513  : 		}

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?assign@?$char_traits@D@std@@SAPEADQEAD_KD@Z ENDP	; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?assign@?$char_traits@D@std@@SAXAEADAEBD@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z PROC		; std::char_traits<char>::assign, COMDAT

; 517  : 		_Left = _Right;

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	88 01		 mov	 BYTE PTR [rcx], al

; 518  : 		}

  00005	c3		 ret	 0
?assign@?$char_traits@D@std@@SAXAEADAEBD@Z ENDP		; std::char_traits<char>::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eq@?$char_traits@D@std@@SA_NAEBD0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq@?$char_traits@D@std@@SA_NAEBD0@Z PROC		; std::char_traits<char>::eq, COMDAT

; 522  : 		return (_Left == _Right);

  00000	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00003	38 01		 cmp	 BYTE PTR [rcx], al
  00005	0f 94 c0	 sete	 al

; 523  : 		}

  00008	c3		 ret	 0
?eq@?$char_traits@D@std@@SA_NAEBD0@Z ENDP		; std::char_traits<char>::eq
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?to_char_type@?$char_traits@D@std@@SADAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?to_char_type@?$char_traits@D@std@@SADAEBH@Z PROC	; std::char_traits<char>::to_char_type, COMDAT

; 532  : 		return ((_Elem)_Meta);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 533  : 		}

  00003	c3		 ret	 0
?to_char_type@?$char_traits@D@std@@SADAEBH@Z ENDP	; std::char_traits<char>::to_char_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?to_int_type@?$char_traits@D@std@@SAHAEBD@Z
_TEXT	SEGMENT
_Ch$ = 8
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z PROC	; std::char_traits<char>::to_int_type, COMDAT

; 537  : 		return ((unsigned char)_Ch);

  00000	0f b6 01	 movzx	 eax, BYTE PTR [rcx]

; 538  : 		}

  00003	c3		 ret	 0
?to_int_type@?$char_traits@D@std@@SAHAEBD@Z ENDP	; std::char_traits<char>::to_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z PROC	; std::char_traits<char>::eq_int_type, COMDAT

; 542  : 		return (_Left == _Right);

  00000	8b 02		 mov	 eax, DWORD PTR [rdx]
  00002	39 01		 cmp	 DWORD PTR [rcx], eax
  00004	0f 94 c0	 sete	 al

; 543  : 		}

  00007	c3		 ret	 0
?eq_int_type@?$char_traits@D@std@@SA_NAEBH0@Z ENDP	; std::char_traits<char>::eq_int_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?not_eof@?$char_traits@D@std@@SAHAEBH@Z
_TEXT	SEGMENT
_Meta$ = 8
?not_eof@?$char_traits@D@std@@SAHAEBH@Z PROC		; std::char_traits<char>::not_eof, COMDAT

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  00000	8b 01		 mov	 eax, DWORD PTR [rcx]
  00002	33 c9		 xor	 ecx, ecx
  00004	83 f8 ff	 cmp	 eax, -1
  00007	0f 44 c1	 cmove	 eax, ecx

; 548  : 		}

  0000a	c3		 ret	 0
?not_eof@?$char_traits@D@std@@SAHAEBH@Z ENDP		; std::char_traits<char>::not_eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?eof@?$char_traits@D@std@@SAHXZ
_TEXT	SEGMENT
?eof@?$char_traits@D@std@@SAHXZ PROC			; std::char_traits<char>::eof, COMDAT

; 552  : 		return (EOF);

  00000	83 c8 ff	 or	 eax, -1

; 553  : 		}

  00003	c3		 ret	 0
?eof@?$char_traits@D@std@@SAHXZ ENDP			; std::char_traits<char>::eof
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Orphan_all@_Container_base0@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@_Container_base0@std@@QEAAXXZ PROC		; std::_Container_base0::_Orphan_all, COMDAT

; 65   : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@_Container_base0@std@@QEAAXXZ ENDP		; std::_Container_base0::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z
_TEXT	SEGMENT
this$dead$ = 8
__formal$dead$ = 16
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z PROC		; std::_Iterator_base0::_Adopt, COMDAT

; 76   : 		}

  00000	c2 00 00	 ret	 0
?_Adopt@_Iterator_base0@std@@QEAAXPEBX@Z ENDP		; std::_Iterator_base0::_Adopt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?_Allocate@std@@YAPEAX_K0_N@Z
_TEXT	SEGMENT
_Count$ = 48
_Sz$dead$ = 56
_Try_aligned_allocation$dead$ = 64
?_Allocate@std@@YAPEAX_K0_N@Z PROC			; std::_Allocate, COMDAT

; 49   : 	{	// allocate storage for _Count elements of size _Sz

$LN11:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 50   : 	void *_Ptr = 0;
; 51   : 
; 52   : 	if (_Count == 0)

  00004	48 85 c9	 test	 rcx, rcx
  00007	75 07		 jne	 SHORT $LN2@Allocate

; 53   : 		{
; 54   : 		return (_Ptr);

  00009	33 c0		 xor	 eax, eax

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);
; 96   : 	}

  0000b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000f	c3		 ret	 0
$LN2@Allocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00010	33 c0		 xor	 eax, eax
  00012	84 c0		 test	 al, al
  00014	74 07		 je	 SHORT $LN3@Allocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00016	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0001c	cc		 int	 3
$LN3@Allocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0001d	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00024	72 2c		 jb	 SHORT $LN4@Allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00026	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	77 07		 ja	 SHORT $LN5@Allocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0002f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00035	cc		 int	 3
$LN5@Allocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00036	48 8b c8	 mov	 rcx, rax
  00039	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0003e	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  00042	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00046	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  0004a	48 8b c1	 mov	 rax, rcx

; 94   : 	_SCL_SECURE_ALWAYS_VALIDATE(_Ptr != 0);
; 95   : 	return (_Ptr);
; 96   : 	}

  0004d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00051	c3		 ret	 0
$LN4@Allocate:
  00052	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00056	e9 00 00 00 00	 jmp	 ??2@YAPEAX_K@Z		; operator new
$LN10@Allocate:
?_Allocate@std@@YAPEAX_K0_N@Z ENDP			; std::_Allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?_Deallocate@std@@YAXPEAX_K1@Z
_TEXT	SEGMENT
_Ptr$ = 48
_Count$ = 56
_Sz$dead$ = 64
?_Deallocate@std@@YAXPEAX_K1@Z PROC			; std::_Deallocate, COMDAT

; 101  : 	{	// deallocate storage for _Count elements of size _Sz

$LN17:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)
; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00004	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0000b	72 1e		 jb	 SHORT $LN4@Deallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0000d	f6 c1 1f	 test	 cl, 31
  00010	75 22		 jne	 SHORT $_Invalid_parameter$18

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00012	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00016	48 3b c1	 cmp	 rax, rcx
  00019	73 19		 jae	 SHORT $_Invalid_parameter$18
  0001b	48 2b c8	 sub	 rcx, rax
  0001e	48 83 e9 08	 sub	 rcx, 8
  00022	48 83 f9 1f	 cmp	 rcx, 31
  00026	77 0c		 ja	 SHORT $_Invalid_parameter$18

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	48 8b c8	 mov	 rcx, rax
$LN4@Deallocate:

; 156  : 	}

  0002b	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0002f	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$_Invalid_parameter$18:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00034	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0003a	cc		 int	 3
$LN16@Deallocate:
?_Deallocate@std@@YAXPEAX_K1@Z ENDP			; std::_Deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Convert_size@_K@std@@YA_K_K@Z
_TEXT	SEGMENT
_Len$ = 8
??$_Convert_size@_K@std@@YA_K_K@Z PROC			; std::_Convert_size<unsigned __int64>, COMDAT

; 1162 : 	return (_Len);

  00000	48 8b c1	 mov	 rax, rcx

; 1163 : 	}

  00003	c3		 ret	 0
??$_Convert_size@_K@std@@YA_K_K@Z ENDP			; std::_Convert_size<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h
;	COMDAT ??0bad_cast@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0bad_cast@std@@QEAA@XZ PROC				; std::bad_cast::bad_cast, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h

; 59   :         : _Data()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 60   :     {
; 61   :         _Data._What = _Message;

  00006	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_08EPJLHIJG@bad?5cast?$AA@
  0000d	48 89 41 08	 mov	 QWORD PTR [rcx+8], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_typeinfo.h

; 127  :     {

  00011	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00018	48 89 01	 mov	 QWORD PTR [rcx], rax

; 128  :     }

  0001b	48 8b c1	 mov	 rax, rcx
  0001e	c3		 ret	 0
??0bad_cast@std@@QEAA@XZ ENDP				; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??_Gbad_cast@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_Gbad_cast@std@@UEAAPEAXI@Z PROC			; std::bad_cast::`scalar deleting destructor', COMDAT
$LN11:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 83   :     {

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00011	48 8b f9	 mov	 rdi, rcx
  00014	48 89 01	 mov	 QWORD PTR [rcx], rax
  00017	8b da		 mov	 ebx, edx

; 84   :         __std_exception_destroy(&_Data);

  00019	48 83 c1 08	 add	 rcx, 8
  0001d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_destroy
  00023	f6 c3 01	 test	 bl, 1
  00026	74 0d		 je	 SHORT $LN9@scalar
  00028	ba 18 00 00 00	 mov	 edx, 24
  0002d	48 8b cf	 mov	 rcx, rdi
  00030	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN9@scalar:
  00035	48 8b c7	 mov	 rax, rdi
  00038	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5f		 pop	 rdi
  00042	c3		 ret	 0
??_Gbad_cast@std@@UEAAPEAXI@Z ENDP			; std::bad_cast::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??1bad_cast@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 8
??1bad_cast@std@@UEAA@XZ PROC				; std::bad_cast::~bad_cast, COMDAT

; 83   :     {

  00000	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7exception@std@@6B@
  00007	48 89 01	 mov	 QWORD PTR [rcx], rax

; 84   :         __std_exception_destroy(&_Data);

  0000a	48 83 c1 08	 add	 rcx, 8
  0000e	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp___std_exception_destroy
??1bad_cast@std@@UEAA@XZ ENDP				; std::bad_cast::~bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??1locale@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1locale@std@@QEAA@XZ PROC				; std::locale::~locale, COMDAT

; 403  : 		{	// destroy the object

$LN6:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 404  : 		if (_Ptr != 0)

  0000d	48 8b 49 08	 mov	 rcx, QWORD PTR [rcx+8]
  00011	48 85 c9	 test	 rcx, rcx
  00014	74 1b		 je	 SHORT $LN4@locale

; 405  : 			delete _Ptr->_Decref();

  00016	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00019	ff 50 10	 call	 QWORD PTR [rax+16]
  0001c	90		 npad	 1
  0001d	48 85 c0	 test	 rax, rax
  00020	74 0f		 je	 SHORT $LN4@locale
  00022	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00025	ba 01 00 00 00	 mov	 edx, 1
  0002a	48 8b c8	 mov	 rcx, rax
  0002d	41 ff 10	 call	 QWORD PTR [r8]
  00030	90		 npad	 1
$LN4@locale:

; 406  : 		}

  00031	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00035	c3		 ret	 0
??1locale@std@@QEAA@XZ ENDP				; std::locale::~locale
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z
_TEXT	SEGMENT
this$ = 48
_Id$ = 56
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z PROC	; std::locale::_Getfacet, COMDAT

; 430  : 		{	// look up a facet in locale object

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0000d	33 ff		 xor	 edi, edi
  0000f	48 8b 51 08	 mov	 rdx, QWORD PTR [rcx+8]
  00013	48 3b 5a 18	 cmp	 rbx, QWORD PTR [rdx+24]
  00017	73 0f		 jae	 SHORT $LN6@Getfacet
  00019	48 8b 42 10	 mov	 rax, QWORD PTR [rdx+16]
  0001d	48 8b 04 d8	 mov	 rax, QWORD PTR [rax+rbx*8]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00021	48 85 c0	 test	 rax, rax
  00024	75 22		 jne	 SHORT $LN4@Getfacet
  00026	eb 03		 jmp	 SHORT $LN10@Getfacet
$LN6@Getfacet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00028	48 8b c7	 mov	 rax, rdi
$LN10@Getfacet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0002b	40 38 7a 24	 cmp	 BYTE PTR [rdx+36], dil
  0002f	74 17		 je	 SHORT $LN4@Getfacet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  00037	48 3b 58 18	 cmp	 rbx, QWORD PTR [rax+24]
  0003b	73 08		 jae	 SHORT $LN8@Getfacet
  0003d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00041	48 8b 3c d8	 mov	 rdi, QWORD PTR [rax+rbx*8]
$LN8@Getfacet:
  00045	48 8b c7	 mov	 rax, rdi
$LN4@Getfacet:

; 439  : 				? _Ptr0->_Facetvec[_Id]	// get from current locale
; 440  : 				: 0);	// no entry in current locale
; 441  : 			}
; 442  : 		}

  00048	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
?_Getfacet@locale@std@@QEBAPEBVfacet@12@_K@Z ENDP	; std::locale::_Getfacet
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z PROC		; std::_Fgetc<char>, COMDAT

; 47   : 	{	// get a char element from a C stream

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 48   : 	int _Meta;
; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  00009	48 8b ca	 mov	 rcx, rdx
  0000c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  00012	83 f8 ff	 cmp	 eax, -1
  00015	75 08		 jne	 SHORT $LN2@Fgetc

; 50   : 		return (false);

  00017	32 c0		 xor	 al, al

; 55   : 		}
; 56   : 	}

  00019	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001d	5b		 pop	 rbx
  0001e	c3		 ret	 0
$LN2@Fgetc:

; 51   : 	else
; 52   : 		{	// got one, convert to char
; 53   : 		_Byte = (char)_Meta;

  0001f	88 03		 mov	 BYTE PTR [rbx], al

; 54   : 		return (true);

  00021	b0 01		 mov	 al, 1

; 55   : 		}
; 56   : 	}

  00023	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00027	5b		 pop	 rbx
  00028	c3		 ret	 0
??$_Fgetc@D@std@@YA_NAEADPEAU_iobuf@@@Z ENDP		; std::_Fgetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z PROC		; std::_Fputc<char>, COMDAT

; 92   : 	{	// put a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00004	0f be c9	 movsx	 ecx, cl
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 94   : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Fputc@D@std@@YA_NDPEAU_iobuf@@@Z ENDP		; std::_Fputc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z
_TEXT	SEGMENT
_Byte$ = 48
_File$ = 56
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z PROC		; std::_Ungetc<char>, COMDAT

; 116  : 	{	// put back a char element to a C stream

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  00004	0f b6 09	 movzx	 ecx, BYTE PTR [rcx]
  00007	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  0000d	83 f8 ff	 cmp	 eax, -1
  00010	0f 95 c0	 setne	 al

; 118  : 	}

  00013	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00017	c3		 ret	 0
??$_Ungetc@D@std@@YA_NAEBDPEAU_iobuf@@@Z ENDP		; std::_Ungetc<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z
_TEXT	SEGMENT
this$ = 48
__formal$dead$ = 56
??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z PROC ; std::random_device::random_device, COMDAT

; 6420 : 	explicit random_device(const string& = "")

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 6442 : 		return (_Random_device());

  00009	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ

; 6421 : 		{	// construct
; 6422 : 		(*this)();	// force early failure if bad engine
; 6423 : 		}

  0000f	48 8b c3	 mov	 rax, rbx
  00012	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00016	5b		 pop	 rbx
  00017	c3		 ret	 0
??0random_device@std@@QEAA@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@1@@Z ENDP ; std::random_device::random_device
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?min@random_device@std@@SAIXZ
_TEXT	SEGMENT
?min@random_device@std@@SAIXZ PROC			; std::random_device::min, COMDAT

; 6427 : 		return (0);

  00000	33 c0		 xor	 eax, eax

; 6428 : 		}

  00002	c3		 ret	 0
?min@random_device@std@@SAIXZ ENDP			; std::random_device::min
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?max@random_device@std@@SAIXZ
_TEXT	SEGMENT
?max@random_device@std@@SAIXZ PROC			; std::random_device::max, COMDAT

; 6432 : 		return ((result_type)-1);

  00000	83 c8 ff	 or	 eax, -1			; ffffffffH

; 6433 : 		}

  00003	c3		 ret	 0
?max@random_device@std@@SAIXZ ENDP			; std::random_device::max
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?entropy@random_device@std@@QEAANXZ
_TEXT	SEGMENT
this$dead$ = 8
?entropy@random_device@std@@QEAANXZ PROC		; std::random_device::entropy, COMDAT

; 6437 : 		return (32.0);

  00000	f2 0f 10 05 00
	00 00 00	 movsd	 xmm0, QWORD PTR __real@4040000000000000

; 6438 : 		}

  00008	c3		 ret	 0
?entropy@random_device@std@@QEAANXZ ENDP		; std::random_device::entropy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??Rrandom_device@std@@QEAAIXZ
_TEXT	SEGMENT
this$dead$ = 8
??Rrandom_device@std@@QEAAIXZ PROC			; std::random_device::operator(), COMDAT

; 6442 : 		return (_Random_device());

  00000	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Random_device@std@@YAIXZ
??Rrandom_device@std@@QEAAIXZ ENDP			; std::random_device::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ??__EG³os@@YAXXZ
text$di	SEGMENT
??__EG³os@@YAXXZ PROC					; `dynamic initializer for 'G³os'', COMDAT

; 69   : string G³os;

  00000	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??__FG³os@@YAXXZ ; `dynamic atexit destructor for 'G³os''
  00007	e9 00 00 00 00	 jmp	 atexit
??__EG³os@@YAXXZ ENDP					; `dynamic initializer for 'G³os''
text$di	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??__FG³os@@YAXXZ
text$yd	SEGMENT
??__FG³os@@YAXXZ PROC					; `dynamic atexit destructor for 'G³os'', COMDAT
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3707 : 		this->_Orphan_all();

  00004	e8 00 00 00 00	 call	 ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00009	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  00010	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00014	72 35		 jb	 SHORT $LN30@dynamic
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00016	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0001d	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00020	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00026	72 1e		 jb	 SHORT $LN33@dynamic

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00028	f6 c1 1f	 test	 cl, 31
  0002b	75 3e		 jne	 SHORT $_Invalid_parameter$53

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0002d	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00031	48 3b c1	 cmp	 rax, rcx
  00034	73 35		 jae	 SHORT $_Invalid_parameter$53
  00036	48 2b c8	 sub	 rcx, rax
  00039	48 83 e9 08	 sub	 rcx, 8
  0003d	48 83 f9 1f	 cmp	 rcx, 31
  00041	77 28		 ja	 SHORT $_Invalid_parameter$53

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00043	48 8b c8	 mov	 rcx, rax
$LN33@dynamic:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00046	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN30@dynamic:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0004b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00053	f3 0f 7f 05 10
	00 00 00	 movdqu	 XMMWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0005b	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A, 0
  00062	48 83 c4 28	 add	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2247 : 		}

  00066	e9 00 00 00 00	 jmp	 ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
$_Invalid_parameter$53:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0006b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00071	cc		 int	 3
$LN52@dynamic:
??__FG³os@@YAXXZ ENDP					; `dynamic atexit destructor for 'G³os''
text$yd	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT main
_TEXT	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main	PROC						; COMDAT

; 73   : {

$LN112:
  00000	40 55		 push	 rbp
  00002	48 8d ac 24 40
	fe ff ff	 lea	 rbp, QWORD PTR [rsp-448]
  0000a	48 81 ec c0 02
	00 00		 sub	 rsp, 704		; 000002c0H
  00011	48 c7 44 24 50
	fe ff ff ff	 mov	 QWORD PTR $T9[rsp], -2
  0001a	48 89 9c 24 d0
	02 00 00	 mov	 QWORD PTR [rsp+720], rbx
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 85 b0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00033	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0

; 74   : 	//Inicjowanie funkcji
; 75   : 	setlocale(LC_ALL, "polish"); // W celu polskich liter w konsoli

  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06JGCGFIEG@polish?$AA@
  00042	33 c9		 xor	 ecx, ecx
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setlocale
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\time.h

; 535  :             return _time64(_Time);

  0004a	33 c9		 xor	 ecx, ecx
  0004c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__time64
  00052	48 8b c8	 mov	 rcx, rax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 76   : 	srand((unsigned int)time(nullptr)); //Zainicjowanie generatorza LCG (Liniowy Generator Kongruentny) dla ma³o wa¿nych liczb

  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_srand

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  0005b	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle
  00066	48 8b d8	 mov	 rbx, rax

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00069	48 8d 54 24 58	 lea	 rdx, QWORD PTR hCCI$10[rsp]
  0006e	48 8b c8	 mov	 rcx, rax
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00077	83 7c 24 5c 01	 cmp	 DWORD PTR hCCI$10[rsp+4], 1
  0007c	74 16		 je	 SHORT $LN12@main

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny

  0007e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR hCCI$10[rsp+4], 1

; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00086	48 8d 54 24 58	 lea	 rdx, QWORD PTR hCCI$10[rsp]
  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN12@main:

; 77   : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 78   : 
; 79   : 	SprawdŸ_ustawienia(); //Wczytanie ustawieñ z pliku

  00094	e8 00 00 00 00	 call	 ?SprawdŸ_ustawienia@@YAXXZ ; SprawdŸ_ustawienia

; 80   : 	SprawdŸ_Pliki(); //Wczytanie plików audio

  00099	e8 00 00 00 00	 call	 ?SprawdŸ_Pliki@@YAXXZ	; SprawdŸ_Pliki
  0009e	33 d2		 xor	 edx, edx
  000a0	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  000a6	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  000ad	e8 00 00 00 00	 call	 memset

; 81   : 
; 82   : 	//Inicjowanie zmiennych lokalnych
; 83   : 	ofstream log_ogólny; //Utworzenie typu do celu zapisu do pliku

  000b2	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  000b9	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  000be	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000bf	41 b8 0a 00 00
	00		 mov	 r8d, 10
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@GMFAENOC@log_og?slny?4txt?$AA@
  000cc	48 8d 8d a8 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-248]
  000d3	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1139 : 			_Myios::setstate(ios_base::failbit);

  000d8	45 33 c0	 xor	 r8d, r8d

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000db	48 85 c0	 test	 rax, rax

; 1139 : 			_Myios::setstate(ios_base::failbit);

  000de	48 8b 85 a0 00
	00 00		 mov	 rax, QWORD PTR log_ogólny$[rbp-256]
  000e5	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000e9	48 8d 85 a0 00
	00 00		 lea	 rax, QWORD PTR log_ogólny$[rbp-256]

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  000f0	75 0f		 jne	 SHORT $LN18@main

; 1139 : 			_Myios::setstate(ios_base::failbit);

  000f2	48 03 c8	 add	 rcx, rax
  000f5	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  000f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1140 : 		else

  000ff	eb 0b		 jmp	 SHORT $LN19@main
$LN18@main:

; 1141 : 			_Myios::clear();	// added with C++11

  00101	48 03 c8	 add	 rcx, rax
  00104	33 d2		 xor	 edx, edx
  00106	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN19@main:
  0010c	33 d2		 xor	 edx, edx
  0010e	41 b8 18 01 00
	00		 mov	 r8d, 280		; 00000118H
  00114	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  00118	e8 00 00 00 00	 call	 memset

; 1196 : 		{	// construct unopened

  0011d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  00124	48 89 45 80	 mov	 QWORD PTR log$[rbp-256], rax
  00128	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  0012f	48 89 45 90	 mov	 QWORD PTR log$[rbp-240], rax
  00133	48 8d 4d 38	 lea	 rcx, QWORD PTR log$[rbp-72]
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0013d	90		 npad	 1
  0013e	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 1142 : 		}
; 1143 : 
; 1144 : 	void open(const string& _Str,
; 1145 : 		ios_base::openmode _Mode = ios_base::out,
; 1146 : 		int _Prot = (int)ios_base::_Openprot)
; 1147 : 		{	// open a C stream with specified mode
; 1148 : 		open(_Str.c_str(), _Mode, _Prot);
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1152 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1153 : 		{	// open a C stream with specified mode (old style)
; 1154 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1155 : 		}
; 1156 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1157 : 
; 1158 : 	void close()
; 1159 : 		{	// close the C stream
; 1160 : 		if (_Filebuffer.close() == 0)
; 1161 : 			_Myios::setstate(ios_base::failbit);
; 1162 : 		}
; 1163 : 
; 1164 : private:
; 1165 : 	_Myfb _Filebuffer;	// the file buffer
; 1166 : 	};
; 1167 : 
; 1168 : 	// basic_ofstream TEMPLATE OPERATORS
; 1169 : template<class _Elem,
; 1170 : 	class _Traits> inline
; 1171 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1172 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1173 : 	{	// swap _Left and _Right basic_ofstreams
; 1174 : 	_Left.swap(_Right);
; 1175 : 	}
; 1176 : 
; 1177 : 		// TEMPLATE CLASS basic_fstream
; 1178 : template<class _Elem,
; 1179 : 	class _Traits>
; 1180 : 	class basic_fstream
; 1181 : 		: public basic_iostream<_Elem, _Traits>
; 1182 : 	{	// input/output stream associated with a C stream
; 1183 : public:
; 1184 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1185 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1186 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1187 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1188 : 	typedef _Elem char_type;
; 1189 : 	typedef _Traits traits_type;
; 1190 : 	typedef typename _Traits::int_type int_type;
; 1191 : 	typedef typename _Traits::pos_type pos_type;
; 1192 : 	typedef typename _Traits::off_type off_type;
; 1193 : 
; 1194 : 	basic_fstream()
; 1195 : 		: _Mybase(&_Filebuffer)

  00146	45 33 c0	 xor	 r8d, r8d
  00149	48 8d 55 98	 lea	 rdx, QWORD PTR log$[rbp-232]
  0014d	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  00151	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00157	90		 npad	 1

; 1196 : 		{	// construct unopened

  00158	48 8b 45 80	 mov	 rax, QWORD PTR log$[rbp-256]
  0015c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00160	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00167	48 89 44 0d 80	 mov	 QWORD PTR log$[rbp+rcx-256], rax
  0016c	48 8b 45 80	 mov	 rax, QWORD PTR log$[rbp-256]
  00170	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00174	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  0017a	89 54 0c 7c	 mov	 DWORD PTR log$[rsp+rcx-4], edx
  0017e	48 8d 45 98	 lea	 rax, QWORD PTR log$[rbp-232]
  00182	48 89 44 24 58	 mov	 QWORD PTR this$[rsp], rax

; 155  : 		: _Mysb()

  00187	48 8d 4d 98	 lea	 rcx, QWORD PTR log$[rbp-232]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00191	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  00192	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00199	48 89 45 98	 mov	 QWORD PTR log$[rbp-232], rax

; 625  : 		_Closef = _Which == _Openfl;

  0019d	c6 45 14 00	 mov	 BYTE PTR log$[rbp-108], 0

; 626  : 		_Wrotesome = false;

  001a1	c6 45 09 00	 mov	 BYTE PTR log$[rbp-119], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  001a5	48 8d 4d 98	 lea	 rcx, QWORD PTR log$[rbp-232]
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  001af	48 c7 45 18 00
	00 00 00	 mov	 QWORD PTR log$[rbp-104], 0

; 652  : 		_State = _Stinit;

  001b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  001be	48 89 45 0c	 mov	 QWORD PTR log$[rbp-116], rax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  001c2	48 c7 45 00 00
	00 00 00	 mov	 QWORD PTR log$[rbp-128], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 86   : 	int iloœæ_pieniêdzy = kwota_pocz¹tkowa, kwota_zak³adu, wylosowana_liczba, wygrana; //Zmienne do których wczytuje siê wartoœci liczbowe pobrane od u¿ytkownika takie jak kwota zak³adu a przechowuje iloœæ posiadanych pieniêdzy a tak¿e przechowuje wyniki funkcji losowania liczby z ruletki i kwote wygran¹ z zak³adu

  001ca	8b 05 00 00 00
	00		 mov	 eax, DWORD PTR ?kwota_pocz¹tkowa@@3HA ; kwota_pocz¹tkowa
  001d0	89 44 24 44	 mov	 DWORD PTR iloœæ_pieniêdzy$[rsp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  001d4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  001dc	f3 0f 7f 44 24
	70		 movdqu	 XMMWORD PTR typ_zak³adu$[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001e2	c6 44 24 60 00	 mov	 BYTE PTR typ_zak³adu$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 90   : 	Wczytaj_z_pliku(log_ogólny, log, co_kontynuowaæ, iloœæ_pieniêdzy, kwota_zak³adu, wylosowana_liczba, typ_zak³adu); //Wczytanie stanu gry z pliku

  001e7	48 8d 44 24 60	 lea	 rax, QWORD PTR typ_zak³adu$[rsp]
  001ec	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  001f1	48 8d 44 24 48	 lea	 rax, QWORD PTR wylosowana_liczba$[rsp]
  001f6	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  001fb	48 8d 44 24 4c	 lea	 rax, QWORD PTR kwota_zak³adu$[rsp]
  00200	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00205	4c 8d 4c 24 44	 lea	 r9, QWORD PTR iloœæ_pieniêdzy$[rsp]
  0020a	4c 8d 44 24 40	 lea	 r8, QWORD PTR co_kontynuowaæ$[rsp]
  0020f	48 8d 55 80	 lea	 rdx, QWORD PTR log$[rbp-256]
  00213	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  0021a	e8 00 00 00 00	 call	 ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ; Wczytaj_z_pliku
  0021f	90		 npad	 1
$LL4@main:

; 91   : 
; 92   : 	do
; 93   : 	{
; 94   : 		Pêtla_g³ówna(wygrana, kwota_zak³adu, iloœæ_pieniêdzy, log_ogólny, log, co_kontynuowaæ, typ_zak³adu, wylosowana_liczba); //Funkcja obs³uguj¹ca wszystkie elementy gry

  00220	48 8d 44 24 48	 lea	 rax, QWORD PTR wylosowana_liczba$[rsp]
  00225	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0022a	48 8d 44 24 60	 lea	 rax, QWORD PTR typ_zak³adu$[rsp]
  0022f	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00234	48 8d 44 24 40	 lea	 rax, QWORD PTR co_kontynuowaæ$[rsp]
  00239	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0023e	48 8d 45 80	 lea	 rax, QWORD PTR log$[rbp-256]
  00242	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00247	4c 8d 8d a0 00
	00 00		 lea	 r9, QWORD PTR log_ogólny$[rbp-256]
  0024e	4c 8d 44 24 44	 lea	 r8, QWORD PTR iloœæ_pieniêdzy$[rsp]
  00253	48 8d 54 24 4c	 lea	 rdx, QWORD PTR kwota_zak³adu$[rsp]
  00258	48 8d 4c 24 58	 lea	 rcx, QWORD PTR wygrana$[rsp]
  0025d	e8 00 00 00 00	 call	 ?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ; Pêtla_g³ówna

; 95   : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  00262	c6 44 24 40 6e	 mov	 BYTE PTR co_kontynuowaæ$[rsp], 110 ; 0000006eH

; 96   : 	} while (Czy_Kontynuowaæ(iloœæ_pieniêdzy)); //Pêtla dza³aj¹ca do czasu wartoœci fa³sz zwróconej przez funkcjê Czy_kontynuowaæ

  00267	48 8d 4c 24 44	 lea	 rcx, QWORD PTR iloœæ_pieniêdzy$[rsp]
  0026c	e8 00 00 00 00	 call	 ?Czy_Kontynuowaæ@@YA_NAEBH@Z ; Czy_Kontynuowaæ
  00271	84 c0		 test	 al, al
  00273	75 ab		 jne	 SHORT $LL4@main

; 97   : 
; 98   : 	Koniec_gry(log_ogólny, log, iloœæ_pieniêdzy); //Zakoñczenie gry i wskazanie wyniku

  00275	4c 8d 44 24 44	 lea	 r8, QWORD PTR iloœæ_pieniêdzy$[rsp]
  0027a	48 8d 55 80	 lea	 rdx, QWORD PTR log$[rbp-256]
  0027e	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  00285	e8 00 00 00 00	 call	 ?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ; Koniec_gry

; 99   : 
; 100  : 	system("pause"); //Wywo³anie funkcji wymagaj¹cej do zamkniêcia naciœniêcie dowolnego klawisza

  0028a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_05PDJBBECF@pause?$AA@
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_system
  00297	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00298	48 8b 44 24 78	 mov	 rax, QWORD PTR typ_zak³adu$[rsp+24]
  0029d	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  002a1	72 3c		 jb	 SHORT $LN87@main

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002a3	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  002a6	48 8b 4c 24 60	 mov	 rcx, QWORD PTR typ_zak³adu$[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  002ab	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  002b1	72 27		 jb	 SHORT $LN90@main

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  002b3	f6 c1 1f	 test	 cl, 31
  002b6	75 1b		 jne	 SHORT $_Invalid_parameter$113

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002b8	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  002bc	48 3b c1	 cmp	 rax, rcx
  002bf	73 12		 jae	 SHORT $_Invalid_parameter$113
  002c1	48 2b c8	 sub	 rcx, rax
  002c4	48 83 e9 08	 sub	 rcx, 8
  002c8	48 83 f9 1f	 cmp	 rcx, 31
  002cc	77 05		 ja	 SHORT $_Invalid_parameter$113

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  002ce	48 8b c8	 mov	 rcx, rax
  002d1	eb 07		 jmp	 SHORT $LN90@main
$_Invalid_parameter$113:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002d9	cc		 int	 3
$LN90@main:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  002da	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN87@main:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  002df	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  002e7	f3 0f 7f 44 24
	70		 movdqu	 XMMWORD PTR typ_zak³adu$[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  002ed	c6 44 24 60 00	 mov	 BYTE PTR typ_zak³adu$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 102  : 	return 0; //Zwrócenie wartoœæ 0, czyli porogram zakoñczy³ siê bez b³êdu

  002f2	48 8d 4d 80	 lea	 rcx, QWORD PTR log$[rbp-256]
  002f6	e8 00 00 00 00	 call	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  002fb	90		 npad	 1
  002fc	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rbp-256]
  00303	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00308	33 c0		 xor	 eax, eax

; 103  : }

  0030a	48 8b 8d b0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00311	48 33 cc	 xor	 rcx, rsp
  00314	e8 00 00 00 00	 call	 __security_check_cookie
  00319	48 8b 9c 24 d0
	02 00 00	 mov	 rbx, QWORD PTR [rsp+720]
  00321	48 81 c4 c0 02
	00 00		 add	 rsp, 704		; 000002c0H
  00328	5d		 pop	 rbp
  00329	c3		 ret	 0
$LN111@main:
main	ENDP
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$0 PROC
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$5 PROC
  0000c	40 55		 push	 rbp
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b ea	 mov	 rbp, rdx
  00015	8b 45 44	 mov	 eax, DWORD PTR $T1[rbp]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 18		 je	 SHORT $LN28@main$dtor$
  0001f	83 65 44 fe	 and	 DWORD PTR $T1[rbp], -2
  00023	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rbp]
  0002a	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN28@main$dtor$:
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
main$dtor$5 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$6 PROC
  0003d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00044	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00048	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$6 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$8 PROC
  0004f	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00056	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$8 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$1 PROC
  0005d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00064	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$2 PROC
  00069	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR typ_zak³adu$[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$0 PROC
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR log_ogólny$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$0 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$5 PROC
  0000c	40 55		 push	 rbp
  0000e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00012	48 8b ea	 mov	 rbp, rdx
  00015	8b 45 44	 mov	 eax, DWORD PTR $T1[rbp]
  00018	83 e0 01	 and	 eax, 1
  0001b	85 c0		 test	 eax, eax
  0001d	74 18		 je	 SHORT $LN28@main$dtor$
  0001f	83 65 44 fe	 and	 DWORD PTR $T1[rbp], -2
  00023	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rbp]
  0002a	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN28@main$dtor$:
  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5d		 pop	 rbp
  0003c	c3		 ret	 0
main$dtor$5 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$6 PROC
  0003d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00044	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00048	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$6 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$8 PROC
  0004f	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00056	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
main$dtor$8 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$1 PROC
  0005d	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR log$[rdx]
  00064	e9 00 00 00 00	 jmp	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
main$dtor$1 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
co_kontynuowaæ$ = 64
$T1 = 68
iloœæ_pieniêdzy$ = 68
wylosowana_liczba$ = 72
kwota_zak³adu$ = 76
$T9 = 80
this$ = 88
hCCI$10 = 88
wygrana$ = 88
typ_zak³adu$ = 96
log$ = 128
log_ogólny$ = 416
__$ArrayPad$ = 688
main$dtor$2 PROC
  00069	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR typ_zak³adu$[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
main$dtor$2 ENDP
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN18:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 a8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+168]

; 1121 : 		{	// destroy the object

  0001b	48 8b 87 58 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-168]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 58
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-168], rax
  00035	48 8b 87 58 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-168]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 58 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-168]
  00046	89 94 39 54 ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-172], edx

; 1122 : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 1122 : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN18:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 b8 00
	00 00		 lea	 rdi, QWORD PTR [rcx+184]

; 1342 : 		{	// destroy the object

  0001b	48 8b 87 48 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-184]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 48
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-184], rax
  00035	48 8b 87 48 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-184]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  00046	89 94 39 44 ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-188], edx

; 1343 : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 1343 : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 18 01 00
	00		 mov	 r8d, 280		; 00000118H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ
_TEXT	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ PROC ; Obstaw, COMDAT

; 106  : {

$LN2010:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	53		 push	 rbx
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T295[rsp], -2
  00013	48 8b d9	 mov	 rbx, rcx
  00016	33 c0		 xor	 eax, eax
  00018	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0001c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00020	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00028	88 01		 mov	 BYTE PTR [rcx], al
  0002a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
$LL4@Obstaw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 110  : 		cout << "Jak¹ opcje chcesz obstawic ? (zgodnie z poni¿szym opisem) :" << endl; //Zadanie pytania u¿ytkownikowi

  00032	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DM@FGCBIOFJ@Jak?$LJ?5opcje?5chcesz?5obstawic?5?$DP?5?$CIzg@
  00039	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00040	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00045	48 8b c8	 mov	 rcx, rax
  00048	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0004f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 111  : 		cout << "p - parzyste" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00055	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KLINIBPG@p?5?9?5parzyste?$AA@
  0005c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00063	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00068	48 8b c8	 mov	 rcx, rax
  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 112  : 		cout << "n - nieparzyste" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00078	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@GNAADEAG@n?5?9?5nieparzyste?$AA@
  0007f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00086	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0008b	48 8b c8	 mov	 rcx, rax
  0008e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00095	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 113  : 		cout << "r - czerwone(red)" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  0009b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@GOMOHEMO@r?5?9?5czerwone?$CIred?$CJ?$AA@
  000a2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000a9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 114  : 		cout << "b - czarne(black)" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  000be	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@LKBFHLDI@b?5?9?5czarne?$CIblack?$CJ?$AA@
  000c5	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000d1	48 8b c8	 mov	 rcx, rax
  000d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 115  : 		cout << "g - górna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@FMNKHOJE@g?5?9?5g?srna?5po?$LDowa?$AA@
  000e8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000f4	48 8b c8	 mov	 rcx, rax
  000f7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000fe	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 116  : 		cout << "d - dolna po³owa" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00104	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@CHNPGJIO@d?5?9?5dolna?5po?$LDowa?$AA@
  0010b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00112	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00117	48 8b c8	 mov	 rcx, rax
  0011a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00121	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 117  : 		cout << "k1, k2, k3 - kolumna 1, kolumna 2, kolumna 3" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  00127	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CN@EJBDEIIK@k1?0?5k2?0?5k3?5?9?5kolumna?51?0?5kolumna?5@
  0012e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00135	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0013a	48 8b c8	 mov	 rcx, rax
  0013d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 118  : 		cout << "w1, w2, ..., w12 - wiersz trzech numerów" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  0014a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@KMEGGBFA@w1?0?5w2?0?5?4?4?4?0?5w12?5?9?5wiersz?5trzech@
  00151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00158	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0015d	48 8b c8	 mov	 rcx, rax
  00160	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00167	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 119  : 		cout << "0 - 36 - pojedyncze pole o odpowiednim numerze" << endl; //Wskazaæ mo¿liw¹ odpowiedŸ

  0016d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@FOKBNGLG@0?5?9?536?5?9?5pojedyncze?5pole?5o?5odpow@
  00174	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0017b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00180	48 8b c8	 mov	 rcx, rax
  00183	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  00190	48 8b d3	 mov	 rdx, rbx
  00193	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  0019a	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0019f	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001a2	48 8b 53 18	 mov	 rdx, QWORD PTR [rbx+24]
  001a6	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  001aa	72 03		 jb	 SHORT $LN54@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001ac	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN54@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  001af	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001b3	48 83 f9 01	 cmp	 rcx, 1
  001b7	75 0f		 jne	 SHORT $LN2009@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001b9	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001bc	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  001c2	0f 84 01 08 00
	00		 je	 $LN5@Obstaw
$LN2009@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001c8	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001cb	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  001cf	72 03		 jb	 SHORT $LN85@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001d1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN85@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001d4	48 83 f9 01	 cmp	 rcx, 1
  001d8	75 0f		 jne	 SHORT $LN2008@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001da	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001dd	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  001e3	0f 84 e0 07 00
	00		 je	 $LN5@Obstaw
$LN2008@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001e9	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001ec	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  001f0	72 03		 jb	 SHORT $LN116@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001f2	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN116@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001f5	48 83 f9 01	 cmp	 rcx, 1
  001f9	75 0f		 jne	 SHORT $LN2007@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001fb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001fe	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  00204	0f 84 bf 07 00
	00		 je	 $LN5@Obstaw
$LN2007@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0020a	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0020d	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  00211	72 03		 jb	 SHORT $LN147@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00213	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN147@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00216	48 83 f9 01	 cmp	 rcx, 1
  0021a	75 0f		 jne	 SHORT $LN2006@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0021c	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0021f	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  00225	0f 84 9e 07 00
	00		 je	 $LN5@Obstaw
$LN2006@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0022b	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0022e	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  00232	72 03		 jb	 SHORT $LN178@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00234	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN178@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00237	48 83 f9 01	 cmp	 rcx, 1
  0023b	75 0f		 jne	 SHORT $LN2005@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0023d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00240	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  00246	0f 84 7d 07 00
	00		 je	 $LN5@Obstaw
$LN2005@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0024c	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0024f	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  00253	72 03		 jb	 SHORT $LN209@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00255	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN209@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00258	48 83 f9 01	 cmp	 rcx, 1
  0025c	75 0f		 jne	 SHORT $LN2004@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0025e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00261	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  00267	0f 84 5c 07 00
	00		 je	 $LN5@Obstaw
$LN2004@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0026d	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00270	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  00274	72 03		 jb	 SHORT $LN240@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00276	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN240@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00279	48 83 f9 02	 cmp	 rcx, 2
  0027d	75 10		 jne	 SHORT $LN2003@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0027f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00282	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02ICGBAFJO@k1?$AA@
  00289	0f 84 3a 07 00
	00		 je	 $LN5@Obstaw
$LN2003@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0028f	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00292	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  00296	72 03		 jb	 SHORT $LN271@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00298	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN271@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0029b	48 83 f9 02	 cmp	 rcx, 2
  0029f	75 10		 jne	 SHORT $LN2002@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002a1	0f b7 00	 movzx	 eax, WORD PTR [rax]
  002a4	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KJEMFGFN@k2?$AA@
  002ab	0f 84 18 07 00
	00		 je	 $LN5@Obstaw
$LN2002@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002b1	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002b4	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  002b8	72 03		 jb	 SHORT $LN302@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002ba	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN302@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002bd	48 83 f9 02	 cmp	 rcx, 2
  002c1	75 10		 jne	 SHORT $LN2001@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002c3	0f b7 00	 movzx	 eax, WORD PTR [rax]
  002c6	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02LAFHGHBM@k3?$AA@
  002cd	0f 84 f6 06 00
	00		 je	 $LN5@Obstaw
$LN2001@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002d3	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002d6	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  002db	72 03		 jb	 SHORT $LN333@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002dd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN333@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002e0	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  002e5	75 10		 jne	 SHORT $LN2000@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002e7	0f b7 00	 movzx	 eax, WORD PTR [rax]
  002ea	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02JHFNFPIK@w1?$AA@
  002f1	0f 84 d2 06 00
	00		 je	 $LN5@Obstaw
$LN2000@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002f7	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002fa	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  002ff	72 03		 jb	 SHORT $LN364@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00301	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN364@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00304	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00309	75 10		 jne	 SHORT $LN1999@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0030b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0030e	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02LMHAAMEJ@w2?$AA@
  00315	0f 84 ae 06 00
	00		 je	 $LN5@Obstaw
$LN1999@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0031b	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0031e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00323	72 03		 jb	 SHORT $LN395@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00325	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN395@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00328	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0032d	75 10		 jne	 SHORT $LN1998@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0032f	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00332	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KFGLDNAI@w3?$AA@
  00339	0f 84 8a 06 00
	00		 je	 $LN5@Obstaw
$LN1998@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0033f	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00342	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00347	72 03		 jb	 SHORT $LN426@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00349	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN426@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0034c	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00351	75 10		 jne	 SHORT $LN1997@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00353	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00356	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02OKCKKLMP@w4?$AA@
  0035d	0f 84 66 06 00
	00		 je	 $LN5@Obstaw
$LN1997@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00363	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00366	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0036b	72 03		 jb	 SHORT $LN457@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0036d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN457@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00370	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00375	75 10		 jne	 SHORT $LN1996@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00377	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0037a	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02PDDBJKIO@w5?$AA@
  00381	0f 84 42 06 00
	00		 je	 $LN5@Obstaw
$LN1996@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00387	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0038a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0038f	72 03		 jb	 SHORT $LN488@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00391	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN488@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00394	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00399	75 10		 jne	 SHORT $LN1995@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0039b	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0039e	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02NIBMMJEN@w6?$AA@
  003a5	0f 84 1e 06 00
	00		 je	 $LN5@Obstaw
$LN1995@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  003ab	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003ae	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  003b3	72 03		 jb	 SHORT $LN519@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003b5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN519@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003b8	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  003bd	75 10		 jne	 SHORT $LN1994@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003bf	0f b7 00	 movzx	 eax, WORD PTR [rax]
  003c2	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02MBAHPIAM@w7?$AA@
  003c9	0f 84 fa 05 00
	00		 je	 $LN5@Obstaw
$LN1994@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  003cf	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003d2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  003d7	72 03		 jb	 SHORT $LN550@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003d9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN550@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  003dc	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  003e1	75 10		 jne	 SHORT $LN1993@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003e3	0f b7 00	 movzx	 eax, WORD PTR [rax]
  003e6	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02EGJPOEMD@w8?$AA@
  003ed	0f 84 d6 05 00
	00		 je	 $LN5@Obstaw
$LN1993@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  003f3	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003f6	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  003fb	72 03		 jb	 SHORT $LN581@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  003fd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN581@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00400	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00405	75 10		 jne	 SHORT $LN1992@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00407	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0040a	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02FPIENFIC@w9?$AA@
  00411	0f 84 b2 05 00
	00		 je	 $LN5@Obstaw
$LN1992@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00417	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0041a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0041f	72 03		 jb	 SHORT $LN612@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00421	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN612@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00424	48 83 7b 10 03	 cmp	 QWORD PTR [rbx+16], 3
  00429	75 1c		 jne	 SHORT $LN1991@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0042b	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0042e	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_03NCLMABJC@w10?$AA@
  00435	75 10		 jne	 SHORT $LN1991@Obstaw
  00437	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0043b	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03NCLMABJC@w10?$AA@+2
  00441	0f 84 82 05 00
	00		 je	 $LN5@Obstaw
$LN1991@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00447	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0044a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0044f	72 03		 jb	 SHORT $LN643@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00451	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN643@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00454	48 83 7b 10 03	 cmp	 QWORD PTR [rbx+16], 3
  00459	75 1c		 jne	 SHORT $LN1990@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0045b	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0045e	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_03MLKHDAND@w11?$AA@
  00465	75 10		 jne	 SHORT $LN1990@Obstaw
  00467	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0046b	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03MLKHDAND@w11?$AA@+2
  00471	0f 84 52 05 00
	00		 je	 $LN5@Obstaw
$LN1990@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00477	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0047a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0047f	72 03		 jb	 SHORT $LN674@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00481	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN674@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00484	48 83 7b 10 03	 cmp	 QWORD PTR [rbx+16], 3
  00489	75 1c		 jne	 SHORT $LN1989@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0048b	0f b7 01	 movzx	 eax, WORD PTR [rcx]
  0048e	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_03OAIKGDBA@w12?$AA@
  00495	75 10		 jne	 SHORT $LN1989@Obstaw
  00497	0f b6 41 02	 movzx	 eax, BYTE PTR [rcx+2]
  0049b	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03OAIKGDBA@w12?$AA@+2
  004a1	0f 84 22 05 00
	00		 je	 $LN5@Obstaw
$LN1989@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004a7	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004aa	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  004af	72 03		 jb	 SHORT $LN705@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004b1	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN705@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004b4	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  004b9	75 0f		 jne	 SHORT $LN1988@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004bb	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004be	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01GBGANLPD@0?$AA@
  004c4	0f 84 ff 04 00
	00		 je	 $LN5@Obstaw
$LN1988@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004ca	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004cd	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  004d2	72 03		 jb	 SHORT $LN736@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004d4	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN736@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004d7	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  004dc	75 0f		 jne	 SHORT $LN1987@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004de	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  004e1	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01HIHLOKLC@1?$AA@
  004e7	0f 84 dc 04 00
	00		 je	 $LN5@Obstaw
$LN1987@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004ed	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004f0	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  004f5	72 03		 jb	 SHORT $LN767@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  004f7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN767@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  004fa	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  004ff	75 0f		 jne	 SHORT $LN1986@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00501	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00504	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01FDFGLJHB@2?$AA@
  0050a	0f 84 b9 04 00
	00		 je	 $LN5@Obstaw
$LN1986@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00510	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00513	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00518	72 03		 jb	 SHORT $LN798@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0051a	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN798@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0051d	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  00522	75 0f		 jne	 SHORT $LN1985@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00524	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00527	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EKENIIDA@3?$AA@
  0052d	0f 84 96 04 00
	00		 je	 $LN5@Obstaw
$LN1985@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00533	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00536	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0053b	72 03		 jb	 SHORT $LN829@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0053d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN829@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00540	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  00545	75 0f		 jne	 SHORT $LN1984@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00547	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0054a	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01FAMBOPH@4?$AA@
  00550	0f 84 73 04 00
	00		 je	 $LN5@Obstaw
$LN1984@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00556	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00559	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0055e	72 03		 jb	 SHORT $LN860@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00560	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN860@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00563	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  00568	75 0f		 jne	 SHORT $LN1983@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0056a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0056d	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01BMBHCPLG@5?$AA@
  00573	0f 84 50 04 00
	00		 je	 $LN5@Obstaw
$LN1983@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00579	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0057c	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00581	72 03		 jb	 SHORT $LN891@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00583	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN891@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00586	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  0058b	75 0f		 jne	 SHORT $LN1982@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0058d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00590	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01DHDKHMHF@6?$AA@
  00596	0f 84 2d 04 00
	00		 je	 $LN5@Obstaw
$LN1982@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0059c	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0059f	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  005a4	72 03		 jb	 SHORT $LN922@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005a6	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN922@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005a9	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  005ae	75 0f		 jne	 SHORT $LN1981@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005b0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005b3	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01COCBENDE@7?$AA@
  005b9	0f 84 0a 04 00
	00		 je	 $LN5@Obstaw
$LN1981@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  005bf	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005c2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  005c7	72 03		 jb	 SHORT $LN953@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005c9	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN953@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005cc	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  005d1	75 0f		 jne	 SHORT $LN1980@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005d3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005d6	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KJLJFBPL@8?$AA@
  005dc	0f 84 e7 03 00
	00		 je	 $LN5@Obstaw
$LN1980@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  005e2	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005e5	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  005ea	72 03		 jb	 SHORT $LN984@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005ec	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN984@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  005ef	48 83 7b 10 01	 cmp	 QWORD PTR [rbx+16], 1
  005f4	75 0f		 jne	 SHORT $LN1979@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  005f6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  005f9	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LAKCGALK@9?$AA@
  005ff	0f 84 c4 03 00
	00		 je	 $LN5@Obstaw
$LN1979@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00605	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00608	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0060d	72 03		 jb	 SHORT $LN1015@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0060f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1015@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00612	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00617	75 10		 jne	 SHORT $LN1978@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00619	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0061c	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02PKFBJPLJ@10?$AA@
  00623	0f 84 a0 03 00
	00		 je	 $LN5@Obstaw
$LN1978@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00629	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0062c	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00631	72 03		 jb	 SHORT $LN1046@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00633	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1046@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00636	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0063b	75 10		 jne	 SHORT $LN1977@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0063d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00640	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02ODEKKOPI@11?$AA@
  00647	0f 84 7c 03 00
	00		 je	 $LN5@Obstaw
$LN1977@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0064d	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00650	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00655	72 03		 jb	 SHORT $LN1077@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00657	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1077@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0065a	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0065f	75 10		 jne	 SHORT $LN1976@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00661	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00664	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02MIGHPNDL@12?$AA@
  0066b	0f 84 58 03 00
	00		 je	 $LN5@Obstaw
$LN1976@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00671	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00674	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00679	72 03		 jb	 SHORT $LN1108@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0067b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1108@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0067e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00683	75 10		 jne	 SHORT $LN1975@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00685	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00688	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02NBHMMMHK@13?$AA@
  0068f	0f 84 34 03 00
	00		 je	 $LN5@Obstaw
$LN1975@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00695	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00698	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0069d	72 03		 jb	 SHORT $LN1139@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0069f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1139@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006a2	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  006a7	75 10		 jne	 SHORT $LN1974@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006a9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  006ac	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02JODNFKLN@14?$AA@
  006b3	0f 84 10 03 00
	00		 je	 $LN5@Obstaw
$LN1974@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  006b9	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006bc	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  006c1	72 03		 jb	 SHORT $LN1170@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  006c3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1170@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006c6	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  006cb	75 10		 jne	 SHORT $LN1973@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006cd	0f b7 00	 movzx	 eax, WORD PTR [rax]
  006d0	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02IHCGGLPM@15?$AA@
  006d7	0f 84 ec 02 00
	00		 je	 $LN5@Obstaw
$LN1973@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  006dd	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006e0	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  006e5	72 03		 jb	 SHORT $LN1201@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  006e7	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1201@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  006ea	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  006ef	75 10		 jne	 SHORT $LN1972@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  006f1	0f b7 00	 movzx	 eax, WORD PTR [rax]
  006f4	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KMALDIDP@16?$AA@
  006fb	0f 84 c8 02 00
	00		 je	 $LN5@Obstaw
$LN1972@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00701	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00704	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00709	72 03		 jb	 SHORT $LN1232@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0070b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1232@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0070e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00713	75 10		 jne	 SHORT $LN1971@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00715	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00718	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02LFBAAJHO@17?$AA@
  0071f	0f 84 a4 02 00
	00		 je	 $LN5@Obstaw
$LN1971@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00725	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00728	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0072d	72 03		 jb	 SHORT $LN1263@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0072f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1263@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00732	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00737	75 10		 jne	 SHORT $LN1970@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00739	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0073c	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02DCIIBFLB@18?$AA@
  00743	0f 84 80 02 00
	00		 je	 $LN5@Obstaw
$LN1970@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00749	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0074c	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00751	72 03		 jb	 SHORT $LN1294@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00753	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1294@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00756	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0075b	75 10		 jne	 SHORT $LN1969@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0075d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00760	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02CLJDCEPA@19?$AA@
  00767	0f 84 5c 02 00
	00		 je	 $LN5@Obstaw
$LN1969@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0076d	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00770	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00775	72 03		 jb	 SHORT $LN1325@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00777	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1325@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0077a	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0077f	75 10		 jne	 SHORT $LN1968@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00781	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00784	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02PIBHCBOA@20?$AA@
  0078b	0f 84 38 02 00
	00		 je	 $LN5@Obstaw
$LN1968@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00791	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00794	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00799	72 03		 jb	 SHORT $LN1356@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0079b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1356@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0079e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  007a3	75 10		 jne	 SHORT $LN1967@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007a5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  007a8	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02OBAMBAKB@21?$AA@
  007af	0f 84 14 02 00
	00		 je	 $LN5@Obstaw
$LN1967@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007b5	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007b8	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  007bd	72 03		 jb	 SHORT $LN1387@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007bf	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1387@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007c2	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  007c7	75 10		 jne	 SHORT $LN1966@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007c9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  007cc	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02MKCBEDGC@22?$AA@
  007d3	0f 84 f0 01 00
	00		 je	 $LN5@Obstaw
$LN1966@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007d9	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007dc	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  007e1	72 03		 jb	 SHORT $LN1418@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007e3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1418@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  007e6	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  007eb	75 10		 jne	 SHORT $LN1965@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  007ed	0f b7 00	 movzx	 eax, WORD PTR [rax]
  007f0	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02NDDKHCCD@23?$AA@
  007f7	0f 84 cc 01 00
	00		 je	 $LN5@Obstaw
$LN1965@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007fd	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00800	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00805	72 03		 jb	 SHORT $LN1449@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00807	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1449@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0080a	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0080f	75 10		 jne	 SHORT $LN1964@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00811	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00814	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02JMHLOEOE@24?$AA@
  0081b	0f 84 a8 01 00
	00		 je	 $LN5@Obstaw
$LN1964@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00821	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00824	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00829	72 03		 jb	 SHORT $LN1480@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0082b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1480@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0082e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00833	75 10		 jne	 SHORT $LN1963@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00835	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00838	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02IFGANFKF@25?$AA@
  0083f	0f 84 84 01 00
	00		 je	 $LN5@Obstaw
$LN1963@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00845	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00848	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  0084d	72 03		 jb	 SHORT $LN1511@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0084f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1511@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00852	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00857	75 10		 jne	 SHORT $LN1962@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00859	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0085c	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KOENIGGG@26?$AA@
  00863	0f 84 60 01 00
	00		 je	 $LN5@Obstaw
$LN1962@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00869	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0086c	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00871	72 03		 jb	 SHORT $LN1542@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00873	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1542@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00876	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0087b	75 10		 jne	 SHORT $LN1961@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0087d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00880	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02LHFGLHCH@27?$AA@
  00887	0f 84 3c 01 00
	00		 je	 $LN5@Obstaw
$LN1961@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0088d	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00890	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00895	72 03		 jb	 SHORT $LN1573@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00897	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1573@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0089a	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0089f	75 10		 jne	 SHORT $LN1960@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008a1	0f b7 00	 movzx	 eax, WORD PTR [rax]
  008a4	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02DAMOKLOI@28?$AA@
  008ab	0f 84 18 01 00
	00		 je	 $LN5@Obstaw
$LN1960@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008b1	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008b4	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  008b9	72 03		 jb	 SHORT $LN1604@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008bb	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1604@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008be	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  008c3	75 10		 jne	 SHORT $LN1959@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008c5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  008c8	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02CJNFJKKJ@29?$AA@
  008cf	0f 84 f4 00 00
	00		 je	 $LN5@Obstaw
$LN1959@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008d5	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008d8	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  008dd	72 03		 jb	 SHORT $LN1635@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008df	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1635@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  008e2	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  008e7	75 10		 jne	 SHORT $LN1958@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  008e9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  008ec	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02PJNFELNH@30?$AA@
  008f3	0f 84 d0 00 00
	00		 je	 $LN5@Obstaw
$LN1958@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008f9	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008fc	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00901	72 03		 jb	 SHORT $LN1666@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00903	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1666@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00906	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0090b	75 10		 jne	 SHORT $LN1957@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0090d	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00910	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02OAMOHKJG@31?$AA@
  00917	0f 84 ac 00 00
	00		 je	 $LN5@Obstaw
$LN1957@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0091d	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00920	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00925	72 03		 jb	 SHORT $LN1697@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00927	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1697@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0092a	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  0092f	75 10		 jne	 SHORT $LN1956@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00931	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00934	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02MLODCJFF@32?$AA@
  0093b	0f 84 88 00 00
	00		 je	 $LN5@Obstaw
$LN1956@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00941	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00944	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00949	72 03		 jb	 SHORT $LN1728@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0094b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1728@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0094e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00953	75 0c		 jne	 SHORT $LN1955@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00955	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00958	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02NCPIBIBE@33?$AA@
  0095f	74 68		 je	 SHORT $LN5@Obstaw
$LN1955@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00961	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00964	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00969	72 03		 jb	 SHORT $LN1759@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0096b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1759@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0096e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00973	75 0c		 jne	 SHORT $LN1954@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00975	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00978	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02JNLJIOND@34?$AA@
  0097f	74 48		 je	 SHORT $LN5@Obstaw
$LN1954@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00981	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00984	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00989	72 03		 jb	 SHORT $LN1790@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0098b	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1790@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0098e	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  00993	75 0c		 jne	 SHORT $LN1953@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00995	0f b7 00	 movzx	 eax, WORD PTR [rax]
  00998	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02IEKCLPJC@35?$AA@
  0099f	74 28		 je	 SHORT $LN5@Obstaw
$LN1953@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  009a1	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009a4	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  009a9	72 03		 jb	 SHORT $LN1821@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  009ab	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1821@Obstaw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  009ae	48 83 7b 10 02	 cmp	 QWORD PTR [rbx+16], 2
  009b3	0f 85 79 f6 ff
	ff		 jne	 $LL4@Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  009b9	0f b7 00	 movzx	 eax, WORD PTR [rax]
  009bc	66 3b 05 00 00
	00 00		 cmp	 ax, WORD PTR ??_C@_02KPIPOMFB@36?$AA@
  009c3	0f 85 69 f6 ff
	ff		 jne	 $LL4@Obstaw
$LN5@Obstaw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 182  : 	return zaklad_typ; //Zwracam typ zak³adu podany przez u¿ytkownika

  009c9	48 8b c3	 mov	 rax, rbx

; 183  : }

  009cc	48 83 c4 30	 add	 rsp, 48			; 00000030H
  009d0	5b		 pop	 rbx
  009d1	c3		 ret	 0
  009d2	cc		 int	 3
?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ENDP ; Obstaw
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Obstaw'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN8@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Obstaw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T295 = 40
__$ReturnUdt$ = 64
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA PROC ; `Obstaw'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN8@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN8@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0??Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ@4HA ENDP ; `Obstaw'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z
_TEXT	SEGMENT
$T15 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloœæ_pieniêdzy$ = 104
?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z PROC		; Wczytaj_Kwotê_Zak³adu, COMDAT

; 186  : {

$LN154:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T15[rsp], -2
  0000f	48 89 5c 24 70	 mov	 QWORD PTR [rsp+112], rbx
  00014	48 89 74 24 78	 mov	 QWORD PTR [rsp+120], rsi
  00019	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00020	48 33 c4	 xor	 rax, rsp
  00023	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00028	48 8b da	 mov	 rbx, rdx
  0002b	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0002e	33 f6		 xor	 esi, esi
  00030	48 89 74 24 38	 mov	 QWORD PTR kwota_zak³adu_s$[rsp+16], rsi

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00035	48 c7 44 24 40
	0f 00 00 00	 mov	 QWORD PTR kwota_zak³adu_s$[rsp+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0003e	40 88 74 24 28	 mov	 BYTE PTR kwota_zak³adu_s$[rsp], sil
  00043	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 191  : 		cout << "Masz " << iloœæ_pieniêdzy << "$, jak¹ kwotê chcesz obstawiæ wynik?" << endl; //Podanie akualnego stanu konta i zadanie pytania o kwotê zak³adu

  00050	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05OMMBNPEF@Masz?5?$AA@
  00057	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0005e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00063	48 8b c8	 mov	 rcx, rax
  00066	8b 13		 mov	 edx, DWORD PTR [rbx]
  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0006e	48 8b c8	 mov	 rcx, rax
  00071	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@BGACGNBA@$?0?5jak?$LJ?5kwot?j?5chcesz?5obstawi?f?5wy@
  00078	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0007d	48 8b c8	 mov	 rcx, rax
  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  0008d	48 8d 54 24 28	 lea	 rdx, QWORD PTR kwota_zak³adu_s$[rsp]
  00092	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  00099	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0009e	48 8d 4c 24 28	 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000a3	48 83 7c 24 40
	10		 cmp	 QWORD PTR kwota_zak³adu_s$[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  000a9	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 193  : 		kwota_zak³adu = atoi(kwota_zak³adu_s.c_str()); //Zmiana stringaa na inta i wpisanie do zmiennej kwota_zak³adu

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  000b5	89 07		 mov	 DWORD PTR [rdi], eax

; 194  : 		if (kwota_zak³adu > 0 && kwota_zak³adu <= iloœæ_pieniêdzy) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000b7	85 c0		 test	 eax, eax
  000b9	7e 0a		 jle	 SHORT $LN153@Wczytaj_Kw
  000bb	3b 03		 cmp	 eax, DWORD PTR [rbx]
  000bd	0f 8e ae 00 00
	00		 jle	 $LN141@Wczytaj_Kw

; 195  : 			break; //Je¿eli tak to zatrzymuje pêtle
; 196  : 		else //W przeciwym wypadku
; 197  : 			if (kwota_zak³adu == 0) //Je¿eli wynikiem zamiany na liczbê jest zero (wynikiem zamiany jest zero kiedy tekst to zero lub kiedy jest b³¹d zamiany) to

  000c3	85 c0		 test	 eax, eax
$LN153@Wczytaj_Kw:
  000c5	75 4c		 jne	 SHORT $LN9@Wczytaj_Kw

; 198  : 			{
; 199  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekœcie i przypisanie jej wartoœci true
; 200  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000c7	0f b7 c6	 movzx	 eax, si
  000ca	44 0f b7 44 24
	38		 movzx	 r8d, WORD PTR kwota_zak³adu_s$[rsp+16]
  000d0	66 41 3b f0	 cmp	 si, r8w
  000d4	73 34		 jae	 SHORT $LN147@Wczytaj_Kw
  000d6	4c 8b 4c 24 40	 mov	 r9, QWORD PTR kwota_zak³adu_s$[rsp+24]
  000db	4c 8b 54 24 28	 mov	 r10, QWORD PTR kwota_zak³adu_s$[rsp]
$LL6@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  000e0	48 8d 54 24 28	 lea	 rdx, QWORD PTR kwota_zak³adu_s$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e5	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  000e9	49 0f 43 d2	 cmovae	 rdx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 201  : 					if (kwota_zak³adu_s[i] != '0') //Je¿eli znak na i-tej pozycji

  000ed	0f b7 c8	 movzx	 ecx, ax
  000f0	80 3c 11 30	 cmp	 BYTE PTR [rcx+rdx], 48	; 00000030H
  000f4	75 0b		 jne	 SHORT $LN140@Wczytaj_Kw

; 198  : 			{
; 199  : 				bool czy_zero = true; //Utworzenie zmiennej informuj¹cej czy znaleziono zero w tekœcie i przypisanie jej wartoœci true
; 200  : 				for (unsigned short i = 0; i < (unsigned short)kwota_zak³adu_s.size(); ++i) //Rozpoczêcie pêtli numerowanej przez zmienn¹ i przez wszystkie znaki wczytanego tekst

  000f6	66 ff c0	 inc	 ax
  000f9	66 41 3b c0	 cmp	 ax, r8w
  000fd	72 e1		 jb	 SHORT $LL6@Wczytaj_Kw

; 194  : 		if (kwota_zak³adu > 0 && kwota_zak³adu <= iloœæ_pieniêdzy) //Sprawdzenie czy kwota zak³¹du jest wiêksza od zeri i mniejsza lub równa dostêpnej gotówce

  000ff	eb 09		 jmp	 SHORT $LN147@Wczytaj_Kw
$LN140@Wczytaj_Kw:

; 202  : 					{
; 203  : 						cout << "Wprowadzi³eæ nieprawid³ow¹ wartoœæ" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ tekstowego

  00101	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CD@OGNPPNBN@Wprowadzi?$LDe?f?5nieprawid?$LDow?$LJ?5warto@

; 204  : 						if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 205  : 						czy_zero = false; //Zmiana wartoœci zmiennej czy znaleziono zero w tekœcie na false
; 206  : 						break; //Zatrzymanie pêtli
; 207  : 					}
; 208  : 				if (czy_zero) //Sprawdzenie czy znaleziono same zera w tekœcie, je¿eli tak to

  00108	eb 25		 jmp	 SHORT $LN152@Wczytaj_Kw
$LN147@Wczytaj_Kw:

; 209  : 				{
; 210  : 					cout << "Nie mo¿esz obstawiæ zerowego zak³adu" << endl; //Poinformowanie u¿ytkownika, ¿e nie mo¿e obstawiæ zerowego zak³adu

  0010a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@LJDHNEHM@Nie?5mo?$LPesz?5obstawi?f?5zerowego?5zak@

; 211  : 					if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 212  : 				}
; 213  : 			}

  00111	eb 1c		 jmp	 SHORT $LN152@Wczytaj_Kw
$LN9@Wczytaj_Kw:

; 214  : 			else if (kwota_zak³adu > iloœæ_pieniêdzy) //Je¿eli u¿ytkownik chce obstawiæ za wiêcej ni¿ ma, to

  00113	3b 03		 cmp	 eax, DWORD PTR [rbx]
  00115	7e 09		 jle	 SHORT $LN15@Wczytaj_Kw

; 215  : 			{
; 216  : 				cout << "Nie masz tyle pieniêdzy" << endl; //Poinformowanie go o tym

  00117	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BI@CMKDFAEK@Nie?5masz?5tyle?5pieni?jdzy?$AA@

; 217  : 				if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 218  : 			}

  0011e	eb 0f		 jmp	 SHORT $LN152@Wczytaj_Kw
$LN15@Wczytaj_Kw:

; 219  : 			else if (kwota_zak³adu < 0) //Je¿eli u¿ytkownik chce obstawiæ za ujemn¹ kwotê, to

  00120	85 c0		 test	 eax, eax
  00122	0f 89 28 ff ff
	ff		 jns	 $LL2@Wczytaj_Kw

; 220  : 			{
; 221  : 				cout << "Nie mo¿esz obstawiæ ujemn¹ kwot¹ zak³adu" << endl; //Poinformowanie go o tym

  00128	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CJ@PMIHJCIC@Nie?5mo?$LPesz?5obstawi?f?5ujemn?$LJ?5kwot?$LJ@
$LN152@Wczytaj_Kw:
  0012f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00136	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0013b	48 8b c8	 mov	 rcx, rax
  0013e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00145	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 222  : 				if (stan_dŸwiêków) cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  0014b	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  00153	0f 84 f7 fe ff
	ff		 je	 $LL2@Wczytaj_Kw
  00159	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PBGHHLMH@?$AH?$AA@
  00160	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00167	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 223  : 			}
; 224  : 	}

  0016c	e9 df fe ff ff	 jmp	 $LL2@Wczytaj_Kw
$LN141@Wczytaj_Kw:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00171	48 8b 44 24 40	 mov	 rax, QWORD PTR kwota_zak³adu_s$[rsp+24]
  00176	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0017a	72 3c		 jb	 SHORT $LN117@Wczytaj_Kw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0017c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR kwota_zak³adu_s$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00181	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00184	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0018a	72 27		 jb	 SHORT $LN120@Wczytaj_Kw

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0018c	f6 c1 1f	 test	 cl, 31
  0018f	75 1b		 jne	 SHORT $_Invalid_parameter$155

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00191	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00195	48 3b c1	 cmp	 rax, rcx
  00198	73 12		 jae	 SHORT $_Invalid_parameter$155
  0019a	48 2b c8	 sub	 rcx, rax
  0019d	48 83 e9 08	 sub	 rcx, 8
  001a1	48 83 f9 1f	 cmp	 rcx, 31
  001a5	77 05		 ja	 SHORT $_Invalid_parameter$155

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001a7	48 8b c8	 mov	 rcx, rax
  001aa	eb 07		 jmp	 SHORT $LN120@Wczytaj_Kw
$_Invalid_parameter$155:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001b2	cc		 int	 3
$LN120@Wczytaj_Kw:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001b3	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN117@Wczytaj_Kw:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 225  : }

  001b8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  001bd	48 33 cc	 xor	 rcx, rsp
  001c0	e8 00 00 00 00	 call	 __security_check_cookie
  001c5	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001ca	48 8b 74 24 78	 mov	 rsi, QWORD PTR [rsp+120]
  001cf	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001d3	5f		 pop	 rdi
  001d4	c3		 ret	 0
$LN151@Wczytaj_Kw:
?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z ENDP		; Wczytaj_Kwotê_Zak³adu
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T15 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloœæ_pieniêdzy$ = 104
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA PROC ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA ENDP ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T15 = 32
kwota_zak³adu_s$ = 40
__$ArrayPad$ = 72
kwota_zak³adu$ = 96
iloœæ_pieniêdzy$ = 104
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA PROC ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR kwota_zak³adu_s$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z@4HA ENDP ; `Wczytaj_Kwotê_Zak³adu'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Zakrêæ_Ruletk¹@@YAHXZ
_TEXT	SEGMENT
$T2 = 32
hCCI$6 = 40
hCCI$7 = 40
$T3 = 40
__$ArrayPad$ = 48
?Zakrêæ_Ruletk¹@@YAHXZ PROC				; Zakrêæ_Ruletk¹, COMDAT

; 228  : {

$LN43:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	53		 push	 rbx
  00004	57		 push	 rdi
  00005	41 57		 push	 r15
  00007	48 81 ec 80 00
	00 00		 sub	 rsp, 128		; 00000080H
  0000e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00015	48 33 c4	 xor	 rax, rsp
  00018	48 89 44 24 30	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 229  : 	int iloœæ_zakrêceñ = rand() % (iloœæ_max_dodatkowych_obrotów_ruletki + 1) + iloœæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoœci) iloœæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloœæ obrotów ruletki) zanim nastêpi finalny obrót

  0001d	49 89 6b 08	 mov	 QWORD PTR [r11+8], rbp
  00021	49 89 73 10	 mov	 QWORD PTR [r11+16], rsi
  00025	4d 89 63 18	 mov	 QWORD PTR [r11+24], r12
  00029	4d 89 6b e0	 mov	 QWORD PTR [r11-32], r13
  0002d	0f 29 74 24 60	 movaps	 XMMWORD PTR [rsp+96], xmm6
  00032	0f 29 7c 24 50	 movaps	 XMMWORD PTR [rsp+80], xmm7
  00037	45 0f 29 43 a8	 movaps	 XMMWORD PTR [r11-88], xmm8
  0003c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand
  00042	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA ; iloœæ_max_dodatkowych_obrotów_ruletki
  00049	99		 cdq
  0004a	44 0f bf 25 00
	00 00 00	 movsx	 r12d, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki
  00052	ff c1		 inc	 ecx

; 230  : 	double czas_przeskoku_kulki_szybki_opóŸnienie = czas_przeskoku_kulki_szybki / (iloœæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  00054	f2 44 0f 10 05
	00 00 00 00	 movsd	 xmm8, QWORD PTR __real@4042800000000000
  0005d	f7 f9		 idiv	 ecx
  0005f	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00066	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H

; 229  : 	int iloœæ_zakrêceñ = rand() % (iloœæ_max_dodatkowych_obrotów_ruletki + 1) + iloœæ_minimalna_obrotów_ruletki; //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ pseudolosow¹ (o niskiej pseoudolosowoœci) iloœæ obrotów ruletk¹ ((od 0 do max dodatkowych obrotów ruletki) + minimalna iloœæ obrotów ruletki) zanim nastêpi finalny obrót

  0006b	44 03 e2	 add	 r12d, edx
  0006e	66 0f 6e f8	 movd	 xmm7, eax
  00072	66 41 0f 6e c4	 movd	 xmm0, r12d

; 230  : 	double czas_przeskoku_kulki_szybki_opóŸnienie = czas_przeskoku_kulki_szybki / (iloœæ_zakrêceñ * 37.0); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  00077	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  0007b	f3 0f e6 ff	 cvtdq2pd xmm7, xmm7
  0007f	f2 41 0f 59 c0	 mulsd	 xmm0, xmm8
  00084	f2 0f 5e f8	 divsd	 xmm7, xmm0

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 343  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 344  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0008e	48 8b c8	 mov	 rcx, rax
  00091	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$7[rsp]
  00096	48 8b d8	 mov	 rbx, rax
  00099	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 345  : 	hCCI.bVisible = FALSE; //Zmiena widocznoœci kursora na niewidoczny

  0009f	33 ed		 xor	 ebp, ebp

; 346  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  000a1	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$7[rsp]
  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	89 6c 24 2c	 mov	 DWORD PTR hCCI$7[rsp+4], ebp
  000ad	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo

; 231  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 232  : 	for (int i = 0; i < iloœæ_zakrêceñ; ++i) //Wykonanie iloœæ_zakrêceñ obrotów ruletk¹

  000b3	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:?Ruletka_ko³o@@3QBHB
  000ba	8b fd		 mov	 edi, ebp
  000bc	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:?Ruletka_plansza_kolor_col@@3QBHB
  000c3	45 85 e4	 test	 r12d, r12d
  000c6	0f 8e d5 00 00
	00		 jle	 $LN3@Zakr?

; 233  : 		for (int ii = 0; ii < 37; ++ii) //Przejœcie przez wszystkie pozycje ruletki

  000cc	4c 89 74 24 70	 mov	 QWORD PTR [rsp+112], r14
$LL4@Zakr?:
  000d1	66 0f 6e f7	 movd	 xmm6, edi
  000d5	8b f5		 mov	 esi, ebp
  000d7	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  000db	4d 8b f7	 mov	 r14, r15
  000de	f2 41 0f 59 f0	 mulsd	 xmm6, xmm8
  000e3	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL7@Zakr?:

; 234  : 		{
; 235  : 			Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[ii]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  000f0	49 63 1e	 movsxd	 rbx, DWORD PTR [r14]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  000f3	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  000fe	41 0f b7 54 9d
	00		 movzx	 edx, WORD PTR [r13+rbx*4]
  00104	48 8b c8	 mov	 rcx, rax
  00107	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 236  : 			cout << Ruletka_ko³o[ii]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  0010d	41 8b 16	 mov	 edx, DWORD PTR [r14]
  00110	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00117	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0011d	66 0f 6e c6	 movd	 xmm0, esi

; 237  : 			Sleep((DWORD)(czas_przeskoku_kulki_szybki_opóŸnienie*((double)i*37.0 + (double)ii))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  00121	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00125	f2 0f 58 c6	 addsd	 xmm0, xmm6
  00129	f2 0f 59 c7	 mulsd	 xmm0, xmm7
  0012d	f2 48 0f 2c c8	 cvttsd2si rcx, xmm0
  00132	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00138	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00143	48 8b c8	 mov	 rcx, rax
  00146	ba 07 00 00 00	 mov	 edx, 7
  0014b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 238  : 			Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 239  : 			cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejœcie pomiêdzy liczbami na ruletce

  00151	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00158	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0015f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00164	48 8b c8	 mov	 rcx, rax
  00167	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
  0016e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00173	48 8b c8	 mov	 rcx, rax
  00176	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0017d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00182	ff c6		 inc	 esi
  00184	49 83 c6 04	 add	 r14, 4
  00188	83 fe 25	 cmp	 esi, 37			; 00000025H
  0018b	0f 8c 5f ff ff
	ff		 jl	 $LL7@Zakr?

; 231  : 	Hide_Cursor(); //Ukrycie kursora tekstowego w konsoli
; 232  : 	for (int i = 0; i < iloœæ_zakrêceñ; ++i) //Wykonanie iloœæ_zakrêceñ obrotów ruletk¹

  00191	ff c7		 inc	 edi
  00193	41 3b fc	 cmp	 edi, r12d
  00196	0f 8c 35 ff ff
	ff		 jl	 $LL4@Zakr?
  0019c	4c 8b 74 24 70	 mov	 r14, QWORD PTR [rsp+112]
$LN3@Zakr?:

; 240  : 		}
; 241  : 	int wylosowana_pozycja = Wylosuj(0, 36); //Deklarowanie i przpisanie zmiennej liczbowj zawieraj¹c¹ losow¹ lub pseudolosow¹ liczbê (o wysokiej pseoudolosowoœci) pozycjê na ruletce

  001a1	48 8d 54 24 20	 lea	 rdx, QWORD PTR $T2[rsp]
  001a6	c7 44 24 20 24
	00 00 00	 mov	 DWORD PTR $T2[rsp], 36	; 00000024H
  001ae	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T3[rsp]
  001b3	89 6c 24 28	 mov	 DWORD PTR $T3[rsp], ebp
  001b7	e8 00 00 00 00	 call	 ?Wylosuj@@YAHAEBH0@Z	; Wylosuj

; 242  : 	double czas_przeskoku_kulki_wolny_przyspieszenie = (czas_przeskoku_kulki_wolny - czas_przeskoku_kulki_szybki) / (double)(wylosowana_pozycja); //Deklarowanie i przpisanie zmiennej zmiennoprzecinkowej zawieraj¹c¹ czas o ile kolejna wartoœæ na kole ruletki powinna byæ szybciej pokazana

  001bc	0f bf 15 00 00
	00 00		 movsx	 edx, WORD PTR ?czas_przeskoku_kulki_wolny@@3FA ; czas_przeskoku_kulki_wolny
  001c3	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki

; 243  : 	for (int i = 0; i < wylosowana_pozycja; ++i) //Przejœcie przez pozycje do pozycji o 1 mniejszej od wylosowanej pozyji na ruletce

  001ca	44 0f 28 44 24
	40		 movaps	 xmm8, XMMWORD PTR [rsp+64]
  001d0	2b d1		 sub	 edx, ecx
  001d2	0f 28 7c 24 50	 movaps	 xmm7, XMMWORD PTR [rsp+80]
  001d7	4c 8b a4 24 b0
	00 00 00	 mov	 r12, QWORD PTR [rsp+176]
  001df	66 0f 6e c0	 movd	 xmm0, eax
  001e3	66 0f 6e f2	 movd	 xmm6, edx
  001e7	48 63 f8	 movsxd	 rdi, eax
  001ea	f3 0f e6 f6	 cvtdq2pd xmm6, xmm6
  001ee	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  001f2	f2 0f 5e f0	 divsd	 xmm6, xmm0
  001f6	85 c0		 test	 eax, eax
  001f8	0f 8e b4 00 00
	00		 jle	 $LN9@Zakr?

; 244  : 	{
; 245  : 		Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[i]]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  001fe	48 8b f5	 mov	 rsi, rbp
$LL10@Zakr?:
  00201	49 63 1c b7	 movsxd	 rbx, DWORD PTR [r15+rsi*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00205	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0020a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00210	41 0f b7 54 9d
	00		 movzx	 edx, WORD PTR [r13+rbx*4]
  00216	48 8b c8	 mov	 rcx, rax
  00219	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 246  : 		cout << Ruletka_ko³o[i]; //Wypisanie numeru na kole ruletki na którym znajduje siê pêtla

  0021f	41 8b 14 b7	 mov	 edx, DWORD PTR [r15+rsi*4]
  00223	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0022a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 247  : 		Sleep((DWORD)(czas_przeskoku_kulki_szybki + (czas_przeskoku_kulki_wolny_przyspieszenie*i))); //Przestój który zwiêksza siê co zmianê pozycji pêtli

  00230	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  00237	66 0f 6e cd	 movd	 xmm1, ebp
  0023b	f3 0f e6 c9	 cvtdq2pd xmm1, xmm1
  0023f	66 0f 6e c0	 movd	 xmm0, eax
  00243	f3 0f e6 c0	 cvtdq2pd xmm0, xmm0
  00247	f2 0f 59 ce	 mulsd	 xmm1, xmm6
  0024b	f2 0f 58 c8	 addsd	 xmm1, xmm0
  0024f	f2 48 0f 2c c9	 cvttsd2si rcx, xmm1
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  0025a	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0025f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00265	48 8b c8	 mov	 rcx, rax
  00268	ba 07 00 00 00	 mov	 edx, 7
  0026d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 248  : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 249  : 		cout << "\b\b" << "  " << "\b\b"; //Cofniêcie kursora tekstowego do lewej strony konsoli aby zape³niæ podem spacjami czyli niewidocznym znakiem wiersza konsoli aby widaæ przejœcie pomiêdzy liczbami na ruletce

  00273	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0027a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  00281	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00286	48 8b c8	 mov	 rcx, rax
  00289	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KNHHEEKP@?5?5?$AA@
  00290	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00295	48 8b c8	 mov	 rcx, rax
  00298	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02MGHEPNFN@?$AI?$AI?$AA@
  0029f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002a4	ff c5		 inc	 ebp
  002a6	48 ff c6	 inc	 rsi
  002a9	48 3b f7	 cmp	 rsi, rdi
  002ac	0f 8c 4f ff ff
	ff		 jl	 $LL10@Zakr?
$LN9@Zakr?:

; 250  : 	}
; 251  : 	cout << "Wylosowano numer "; //Poinformowanie o zakoñczeniu (wyœwietlania) losowania

  002b2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002b9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  002c0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 252  : 	Change_Col(Ruletka_plansza_kolor_col[Ruletka_ko³o[wylosowana_pozycja]]);//Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  002c5	49 63 1c bf	 movsxd	 rbx, DWORD PTR [r15+rdi*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002c9	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  002ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002d4	41 0f b7 54 9d
	00		 movzx	 edx, WORD PTR [r13+rbx*4]
  002da	48 8b c8	 mov	 rcx, rax
  002dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 253  : 	cout << Ruletka_ko³o[wylosowana_pozycja]; //Wypisanie liczby na wylosowanej pozycji ruletki

  002e3	41 8b 14 bf	 mov	 edx, DWORD PTR [r15+rdi*4]
  002e7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  002f4	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  002f9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  002ff	48 8b c8	 mov	 rcx, rax
  00302	ba 07 00 00 00	 mov	 edx, 7
  00307	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 254  : 	Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 255  : 	cout << ". "; //Zakoñczenie tekstu kropk¹

  0030d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00314	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KHOJGJKF@?4?5?$AA@
  0031b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00320	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  0032b	48 8b c8	 mov	 rcx, rax
  0032e	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$6[rsp]
  00333	48 8b d8	 mov	 rbx, rax
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  0033c	83 7c 24 2c 01	 cmp	 DWORD PTR hCCI$6[rsp+4], 1
  00341	0f 28 74 24 60	 movaps	 xmm6, XMMWORD PTR [rsp+96]
  00346	4c 8b 6c 24 78	 mov	 r13, QWORD PTR [rsp+120]
  0034b	48 8b b4 24 a8
	00 00 00	 mov	 rsi, QWORD PTR [rsp+168]
  00353	48 8b ac 24 a0
	00 00 00	 mov	 rbp, QWORD PTR [rsp+160]
  0035b	74 16		 je	 SHORT $LN41@Zakr?

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny
; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  0035d	48 8d 54 24 28	 lea	 rdx, QWORD PTR hCCI$6[rsp]
  00362	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR hCCI$6[rsp+4], 1
  0036a	48 8b cb	 mov	 rcx, rbx
  0036d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN41@Zakr?:

; 256  : 	Show_Cursor(); //Pokazanie kursora tekstowego w konsoli
; 257  : 
; 258  : 	return Ruletka_ko³o[wylosowana_pozycja]; //Zwracam wartoœæ bêd¹c¹ na wylosowanym polu ruletki

  00373	41 8b 04 bf	 mov	 eax, DWORD PTR [r15+rdi*4]

; 259  : }

  00377	48 8b 4c 24 30	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0037c	48 33 cc	 xor	 rcx, rsp
  0037f	e8 00 00 00 00	 call	 __security_check_cookie
  00384	48 81 c4 80 00
	00 00		 add	 rsp, 128		; 00000080H
  0038b	41 5f		 pop	 r15
  0038d	5f		 pop	 rdi
  0038e	5b		 pop	 rbx
  0038f	c3		 ret	 0
?Zakrêæ_Ruletk¹@@YAHXZ ENDP				; Zakrêæ_Ruletk¹
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z
_TEXT	SEGMENT
kwota$ = 48
typ_zak³adu$ = 56
wylosowana_liczba$ = 64
?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z PROC ; SprawdŸ_Zak³ad, COMDAT

; 262  : {

$LN545:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 295  : 			if (wylosowana_liczba > 18) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 19 do 36, je¿eli tak to wygrana jest 1:1

  0000f	8b 19		 mov	 ebx, DWORD PTR [rcx]
  00011	48 8b f1	 mov	 rsi, rcx
  00014	49 63 08	 movsxd	 rcx, DWORD PTR [r8]
  00017	49 8b f8	 mov	 rdi, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0001a	4c 8b 42 18	 mov	 r8, QWORD PTR [rdx+24]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001e	48 8b c2	 mov	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 265  : 	if (wylosowana_liczba == 0) //Warunek sprawdzaj¹cy czy wylosowano 0

  00021	85 c9		 test	 ecx, ecx
  00023	0f 85 47 01 00
	00		 jne	 $LN2@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00029	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0002d	72 03		 jb	 SHORT $LN75@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0002f	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN75@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00032	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00036	49 83 f9 01	 cmp	 r9, 1
  0003a	75 19		 jne	 SHORT $LN4@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0003c	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003f	3a 0d 00 00 00
	00		 cmp	 cl, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  00045	75 0e		 jne	 SHORT $LN4@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 267  : 		if (typ_zak³adu == "p") wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00047	8b c3		 mov	 eax, ebx
  00049	99		 cdq
  0004a	2b c2		 sub	 eax, edx
  0004c	d1 f8		 sar	 eax, 1
  0004e	8b d8		 mov	 ebx, eax

; 268  : 		else if (typ_zak³adu == "n") wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00050	e9 ed 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN4@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00055	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00058	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0005c	72 03		 jb	 SHORT $LN104@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0005e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN104@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00061	49 83 f9 01	 cmp	 r9, 1
  00065	75 19		 jne	 SHORT $LN6@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00067	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0006a	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  00070	75 0e		 jne	 SHORT $LN6@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 268  : 		else if (typ_zak³adu == "n") wygrana /= 2; //Je¿eli typ zak³adu by³ p to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  00072	8b c3		 mov	 eax, ebx
  00074	99		 cdq
  00075	2b c2		 sub	 eax, edx
  00077	d1 f8		 sar	 eax, 1
  00079	8b d8		 mov	 ebx, eax

; 269  : 		else if (typ_zak³adu == "r") wygrana /= 2; //Je¿eli typ zak³adu by³ r to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  0007b	e9 c2 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN6@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00080	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00083	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00087	72 03		 jb	 SHORT $LN133@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00089	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN133@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0008c	49 83 f9 01	 cmp	 r9, 1
  00090	75 19		 jne	 SHORT $LN8@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00092	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00095	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  0009b	75 0e		 jne	 SHORT $LN8@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 269  : 		else if (typ_zak³adu == "r") wygrana /= 2; //Je¿eli typ zak³adu by³ r to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  0009d	8b c3		 mov	 eax, ebx
  0009f	99		 cdq
  000a0	2b c2		 sub	 eax, edx
  000a2	d1 f8		 sar	 eax, 1
  000a4	8b d8		 mov	 ebx, eax

; 270  : 		else if (typ_zak³adu == "b") wygrana /= 2; //Je¿eli typ zak³adu by³ b to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000a6	e9 97 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN8@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000ab	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000ae	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  000b2	72 03		 jb	 SHORT $LN162@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000b4	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN162@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000b7	49 83 f9 01	 cmp	 r9, 1
  000bb	75 19		 jne	 SHORT $LN10@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000bd	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000c0	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  000c6	75 0e		 jne	 SHORT $LN10@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 270  : 		else if (typ_zak³adu == "b") wygrana /= 2; //Je¿eli typ zak³adu by³ b to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000c8	8b c3		 mov	 eax, ebx
  000ca	99		 cdq
  000cb	2b c2		 sub	 eax, edx
  000cd	d1 f8		 sar	 eax, 1
  000cf	8b d8		 mov	 ebx, eax

; 271  : 		else if (typ_zak³adu == "g") wygrana /= 2; //Je¿eli typ zak³adu by³ g to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000d1	e9 6c 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN10@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000d6	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d9	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  000dd	72 03		 jb	 SHORT $LN191@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000df	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN191@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000e2	49 83 f9 01	 cmp	 r9, 1
  000e6	75 19		 jne	 SHORT $LN12@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000e8	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000eb	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  000f1	75 0e		 jne	 SHORT $LN12@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 271  : 		else if (typ_zak³adu == "g") wygrana /= 2; //Je¿eli typ zak³adu by³ g to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000f3	8b c3		 mov	 eax, ebx
  000f5	99		 cdq
  000f6	2b c2		 sub	 eax, edx
  000f8	d1 f8		 sar	 eax, 1
  000fa	8b d8		 mov	 ebx, eax

; 272  : 		else if (typ_zak³adu == "d") wygrana /= 2; //Je¿eli typ zak³adu by³ d to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  000fc	e9 41 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN12@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00101	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00104	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00108	72 03		 jb	 SHORT $LN220@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0010a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN220@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0010d	49 83 f9 01	 cmp	 r9, 1
  00111	75 19		 jne	 SHORT $LN14@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00113	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00116	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  0011c	75 0e		 jne	 SHORT $LN14@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 272  : 		else if (typ_zak³adu == "d") wygrana /= 2; //Je¿eli typ zak³adu by³ d to wygrana, a dok³adniej zwrot wynosi po³owê zak³adu

  0011e	8b c3		 mov	 eax, ebx
  00120	99		 cdq
  00121	2b c2		 sub	 eax, edx
  00123	d1 f8		 sar	 eax, 1
  00125	8b d8		 mov	 ebx, eax

; 273  : 		else if (typ_zak³adu[0] == 'k') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  00127	e9 16 02 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN14@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0012c	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0012f	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00133	72 03		 jb	 SHORT $LN243@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00135	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN243@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 273  : 		else if (typ_zak³adu[0] == 'k') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  00138	80 38 6b	 cmp	 BYTE PTR [rax], 107	; 0000006bH
  0013b	0f 84 ff 01 00
	00		 je	 $LN53@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00141	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00144	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00148	72 03		 jb	 SHORT $LN258@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0014a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN258@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 274  : 		else if (typ_zak³adu[0] == 'w') wygrana *= 0; //Je¿eli typ zak³adu by³ k to przegra³o siê zak³ad

  0014d	80 38 77	 cmp	 BYTE PTR [rax], 119	; 00000077H
  00150	0f 84 ea 01 00
	00		 je	 $LN53@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00156	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0015a	72 03		 jb	 SHORT $LN273@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0015c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN273@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 275  : 		else if (typ_zak³adu[0] == '0') wygrana *= 35; //Je¿eli typ zak³adu by³ 0 to przegra³o siê zak³ad

  0015f	80 3a 30	 cmp	 BYTE PTR [rdx], 48	; 00000030H
  00162	0f 85 da 01 00
	00		 jne	 $LN54@SprawdŸ_Z
  00168	6b db 23	 imul	 ebx, ebx, 35		; 00000023H

; 276  : 	}
; 277  : 	else //Je¿eli wylosowana liczba nie jest zerem to

  0016b	e9 d2 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN2@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00170	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00174	72 03		 jb	 SHORT $LN294@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00176	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN294@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00179	4c 8b 4a 10	 mov	 r9, QWORD PTR [rdx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0017d	49 83 f9 01	 cmp	 r9, 1
  00181	75 1f		 jne	 SHORT $LN21@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00183	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00186	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  0018c	75 14		 jne	 SHORT $LN21@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 280  : 			if (wylosowana_liczba % 2 == 0) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest parzysta, je¿eli tak to wygrana jest 1:1

  0018e	8b c3		 mov	 eax, ebx
  00190	41 84 c9	 test	 cl, r9b
  00193	bb 00 00 00 00	 mov	 ebx, 0
  00198	0f 45 c3	 cmovne	 eax, ebx
  0019b	8b d8		 mov	 ebx, eax

; 281  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest parzysta to przegra³o siê zak³ad
; 282  : 		else if (typ_zak³adu == "n") //Je¿eli typ zak³adu to n

  0019d	e9 a0 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN21@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001a2	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001a5	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  001a9	72 03		 jb	 SHORT $LN323@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001ab	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN323@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ae	49 83 f9 01	 cmp	 r9, 1
  001b2	75 2b		 jne	 SHORT $LN25@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001b4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001b7	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  001bd	75 20		 jne	 SHORT $LN25@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 283  : 			if (wylosowana_liczba % 2 == 1) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest nieparzysta, je¿eli tak to wygrana jest 1:1

  001bf	81 e1 01 00 00
	80		 and	 ecx, -2147483647	; ffffffff80000001H
  001c5	7d 07		 jge	 SHORT $LN541@SprawdŸ_Z
  001c7	ff c9		 dec	 ecx
  001c9	83 c9 fe	 or	 ecx, -2
  001cc	ff c1		 inc	 ecx
$LN541@SprawdŸ_Z:
  001ce	8b c3		 mov	 eax, ebx
  001d0	33 db		 xor	 ebx, ebx
  001d2	83 f9 01	 cmp	 ecx, 1
  001d5	0f 45 c3	 cmovne	 eax, ebx
  001d8	8b d8		 mov	 ebx, eax

; 284  : 			else wygrana *= 0; //Je¿eli obstawiony numer nie jest nieparzysta to przegra³o siê zak³ad
; 285  : 		else if (typ_zak³adu == "r") //Je¿eli typ zak³adu to n

  001da	e9 63 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN25@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001df	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001e2	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  001e6	72 03		 jb	 SHORT $LN352@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001e8	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN352@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001eb	49 83 f9 01	 cmp	 r9, 1
  001ef	75 24		 jne	 SHORT $LN29@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001f1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f4	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  001fa	75 19		 jne	 SHORT $LN29@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 286  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czerwona, je¿eli tak to wygrana jest 1:1

  001fc	8b c3		 mov	 eax, ebx
  001fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?Ruletka_plansza_kolor@@3QBDB
  00205	33 db		 xor	 ebx, ebx
  00207	80 3c 11 72	 cmp	 BYTE PTR [rcx+rdx], 114	; 00000072H
  0020b	0f 45 c3	 cmovne	 eax, ebx
  0020e	8b d8		 mov	 ebx, eax

; 287  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czerwony to przegra³o siê zak³ad
; 288  : 		else if (typ_zak³adu == "b") //Je¿eli typ zak³adu to n

  00210	e9 2d 01 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN29@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00215	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00218	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0021c	72 03		 jb	 SHORT $LN381@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0021e	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN381@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00221	49 83 f9 01	 cmp	 r9, 1
  00225	75 24		 jne	 SHORT $LN33@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00227	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0022a	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  00230	75 19		 jne	 SHORT $LN33@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 289  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'b') wygrana *= 1; //To sprawdzam czy wylosowana liczba jest czarna, je¿eli tak to wygrana jest 1:1

  00232	8b c3		 mov	 eax, ebx
  00234	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?Ruletka_plansza_kolor@@3QBDB
  0023b	33 db		 xor	 ebx, ebx
  0023d	80 3c 11 62	 cmp	 BYTE PTR [rcx+rdx], 98	; 00000062H
  00241	0f 45 c3	 cmovne	 eax, ebx
  00244	8b d8		 mov	 ebx, eax

; 290  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie jest czarny to przegra³o siê zak³ad
; 291  : 		else if (typ_zak³adu == "g") //Je¿eli typ zak³adu to g

  00246	e9 f7 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN33@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0024b	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0024e	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00252	72 03		 jb	 SHORT $LN410@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00254	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN410@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00257	49 83 f9 01	 cmp	 r9, 1
  0025b	75 1c		 jne	 SHORT $LN37@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0025d	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00260	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  00266	75 11		 jne	 SHORT $LN37@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 292  : 			if (wylosowana_liczba < 19) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 1 do 18, je¿eli tak to wygrana jest 1:1

  00268	8b c3		 mov	 eax, ebx
  0026a	33 db		 xor	 ebx, ebx
  0026c	83 f9 13	 cmp	 ecx, 19
  0026f	0f 4d c3	 cmovge	 eax, ebx
  00272	8b d8		 mov	 ebx, eax

; 293  : 			else wygrana *= 0; //Je¿eli wylosowana liczba nie nale¿y do przedzia³u [1,18] to przegra³o siê zak³ad
; 294  : 		else if (typ_zak³adu == "d") //Je¿eli typ zak³adu to d

  00274	e9 c9 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN37@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00279	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0027c	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00280	72 03		 jb	 SHORT $LN439@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00282	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN439@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00285	49 83 f9 01	 cmp	 r9, 1
  00289	75 1c		 jne	 SHORT $LN41@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0028b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0028e	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  00294	75 11		 jne	 SHORT $LN41@SprawdŸ_Z
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 295  : 			if (wylosowana_liczba > 18) wygrana *= 1; //To sprawdzam czy wylosowana liczba jest od 19 do 36, je¿eli tak to wygrana jest 1:1

  00296	8b c3		 mov	 eax, ebx
  00298	33 db		 xor	 ebx, ebx
  0029a	83 f9 12	 cmp	 ecx, 18
  0029d	0f 4e c3	 cmovle	 eax, ebx
  002a0	8b d8		 mov	 ebx, eax

; 297  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  002a2	e9 9b 00 00 00	 jmp	 $LN54@SprawdŸ_Z
$LN41@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002a7	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002aa	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  002ae	72 03		 jb	 SHORT $LN462@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002b0	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN462@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 297  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  002b3	80 38 6b	 cmp	 BYTE PTR [rax], 107	; 0000006bH
  002b6	75 30		 jne	 SHORT $LN45@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002b8	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  002bc	72 03		 jb	 SHORT $LN477@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002be	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN477@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 298  : 			if ((wylosowana_liczba - 1) % 3 == typ_zak³adu[1] - 49) wygrana *= 2; //To sprawdzam czy wylosowana liczba jest z obstawionej kolumny, je¿eli tak to wygrana jest 2:1

  002c1	44 0f be 42 01	 movsx	 r8d, BYTE PTR [rdx+1]
  002c6	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  002cb	41 83 e8 31	 sub	 r8d, 49			; 00000031H
  002cf	ff c9		 dec	 ecx
  002d1	f7 e9		 imul	 ecx
  002d3	8b c2		 mov	 eax, edx
  002d5	c1 e8 1f	 shr	 eax, 31
  002d8	03 d0		 add	 edx, eax
  002da	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  002dd	2b c8		 sub	 ecx, eax
  002df	41 3b c8	 cmp	 ecx, r8d
  002e2	75 5c		 jne	 SHORT $LN53@SprawdŸ_Z
  002e4	03 db		 add	 ebx, ebx

; 300  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  002e6	eb 5a		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN45@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002e8	48 8b c2	 mov	 rax, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002eb	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  002ef	72 03		 jb	 SHORT $LN492@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002f1	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN492@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 300  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  002f4	80 38 77	 cmp	 BYTE PTR [rax], 119	; 00000077H
  002f7	75 2c		 jne	 SHORT $LN49@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002f9	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  002fd	72 03		 jb	 SHORT $LN507@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002ff	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN507@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 301  : 			if (((wylosowana_liczba - 1) / 3 + 1) == typ_zak³adu[1] - 48) wygrana *= 11; //To sprawdzam czy wylosowana liczba jest z obstawionego wiersza, je¿eli tak to wygrana jest 11:1

  00302	44 0f be 42 01	 movsx	 r8d, BYTE PTR [rdx+1]
  00307	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  0030c	41 83 e8 31	 sub	 r8d, 49			; 00000031H
  00310	ff c9		 dec	 ecx
  00312	f7 e9		 imul	 ecx
  00314	8b c2		 mov	 eax, edx
  00316	c1 e8 1f	 shr	 eax, 31
  00319	03 d0		 add	 edx, eax
  0031b	41 3b d0	 cmp	 edx, r8d
  0031e	75 20		 jne	 SHORT $LN53@SprawdŸ_Z
  00320	6b db 0b	 imul	 ebx, ebx, 11

; 303  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  00323	eb 1d		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN49@SprawdŸ_Z:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00325	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00329	72 03		 jb	 SHORT $LN523@SprawdŸ_Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0032b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN523@SprawdŸ_Z:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 303  : 		else if (wylosowana_liczba == atoi(typ_zak³adu.c_str())) wygrana *= 35; //Je¿eli typ zak³adu to liczba, to sprawdzam czy wylosowana liczba jest równa obstawionej liczbie, je¿eli tak to wygrana jest 35:1

  0032e	48 8b ca	 mov	 rcx, rdx
  00331	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00337	39 07		 cmp	 DWORD PTR [rdi], eax
  00339	75 05		 jne	 SHORT $LN53@SprawdŸ_Z
  0033b	6b db 23	 imul	 ebx, ebx, 35		; 00000023H
  0033e	eb 02		 jmp	 SHORT $LN54@SprawdŸ_Z
$LN53@SprawdŸ_Z:

; 304  : 		else wygrana *= 0; //Je¿eli wylosowana liczba nie jest równa obstawionej liczbie to przegra³o siê zak³ad

  00340	33 db		 xor	 ebx, ebx
$LN54@SprawdŸ_Z:

; 305  : 	}
; 306  : 
; 307  : 	if (wygrana >= kwota) cout << "Obstawiles poprawnie, wygrywasz " << wygrana << "$." << endl; //Je¿eli wygrana jest wiêksza lub równa obstawionej kwocie to informujê o tym, ¿e wygra³

  00342	8b 3e		 mov	 edi, DWORD PTR [rsi]
  00344	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0034b	3b df		 cmp	 ebx, edi
  0034d	7c 10		 jl	 SHORT $LN55@SprawdŸ_Z
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CB@MBIMKPJH@Obstawiles?5poprawnie?0?5wygrywasz?5@
  00356	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0035b	8b d3		 mov	 edx, ebx
  0035d	eb 29		 jmp	 SHORT $LN543@SprawdŸ_Z
$LN55@SprawdŸ_Z:

; 308  : 	else if (wygrana == kwota / 2) cout << "Obstawiles niepoprawnie lecz uda³o Ci siê, dostajesz po³owê zak³adu " << wygrana << "$." << endl; //Je¿eli wygrana jest równa po³owie obstawionej kwocie to informujê o tym, ¿e przegra³ po³owe stawki

  0035f	8b c7		 mov	 eax, edi
  00361	99		 cdq
  00362	2b c2		 sub	 eax, edx
  00364	d1 f8		 sar	 eax, 1
  00366	3b d8		 cmp	 ebx, eax
  00368	75 10		 jne	 SHORT $LN57@SprawdŸ_Z
  0036a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EF@FAPGEAPP@Obstawiles?5niepoprawnie?5lecz?5uda@
  00371	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00376	8b d3		 mov	 edx, ebx
  00378	eb 0e		 jmp	 SHORT $LN543@SprawdŸ_Z
$LN57@SprawdŸ_Z:

; 309  : 	else cout << "Obstawiles niepoprawnie, przegra³eœ " << kwota << "$." << endl; //Je¿eli wygrana jest równa zero to informujê o tym, ¿e przegra³

  0037a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CF@EMPIFKEH@Obstawiles?5niepoprawnie?0?5przegra@
  00381	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00386	8b d7		 mov	 edx, edi
$LN543@SprawdŸ_Z:
  00388	48 8b c8	 mov	 rcx, rax
  0038b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00391	48 8b c8	 mov	 rcx, rax
  00394	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02DEPNMBPN@$?4?$AA@
  0039b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003a0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  003a7	48 8b c8	 mov	 rcx, rax
  003aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 310  : 
; 311  : 	return wygrana; //Zwracam wartoœ wygranej lub zwrotu
; 312  : }

  003b0	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  003b5	8b c3		 mov	 eax, ebx
  003b7	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  003bc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  003c0	5f		 pop	 rdi
  003c1	c3		 ret	 0
?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ENDP ; SprawdŸ_Zak³ad
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Czy_Kontynuowaæ@@YA_NAEBH@Z
_TEXT	SEGMENT
$T65 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloœæ_pieniêdzy$ = 96
?Czy_Kontynuowaæ@@YA_NAEBH@Z PROC			; Czy_Kontynuowaæ, COMDAT

; 315  : {

$LN534:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T65[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001b	48 33 c4	 xor	 rax, rsp
  0001e	48 89 44 24 48	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00023	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00026	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR tak_nie$[rsp+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002f	bb 0f 00 00 00	 mov	 ebx, 15
  00034	48 89 5c 24 40	 mov	 QWORD PTR tak_nie$[rsp+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00039	c6 44 24 28 00	 mov	 BYTE PTR tak_nie$[rsp], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 318  : 	if (iloœæ_pieniêdzy == 0) //Je¿eli posiadana iloœæ gotówki jest róna 0

  0003e	83 39 00	 cmp	 DWORD PTR [rcx], 0
  00041	75 3d		 jne	 SHORT $LL2@Czy_Kontyn

; 319  : 	{
; 320  : 		cout << "Nie mo¿esz kontynuowaæ, przegra³eœ wszystko" << endl; //Poinformowanie u¿ytkownika, ¿e jest bankrutem

  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CM@BIICBBPD@Nie?5mo?$LPesz?5kontynuowa?f?0?5przegra?$LD@
  0004a	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00051	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00056	48 8b c8	 mov	 rcx, rax
  00059	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00066	40 32 ff	 xor	 dil, dil
  00069	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tak_nie$[rsp]
  0006e	e9 9e 02 00 00	 jmp	 $LN13@Czy_Kontyn
  00073	0f 1f 40 00 66
	0f 1f 84 00 00
	00 00 00	 npad	 13
$LL2@Czy_Kontyn:
$_Invalid_parameter$535:

; 321  : 		return false; //Zwrot wartoœci false, co oznacza, ¿e kolejna runda siê nie odbêdzie
; 322  : 	}
; 323  : 
; 324  : 	while (true) //Rozpoczêcie pêtli nieskoñczonej
; 325  : 	{
; 326  : 		cout << "Na koncie masz " << iloœæ_pieniêdzy << "$, czy chcesz grac dalej('t' - tak, 'n' - nie) ?" << endl; //Pointormowanie o stanie konta i zapytanie o to czy gra dalej

  00080	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@KCLBOCHC@Na?5koncie?5masz?5?$AA@
  00087	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0008e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00093	48 8b c8	 mov	 rcx, rax
  00096	8b 17		 mov	 edx, DWORD PTR [rdi]
  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0009e	48 8b c8	 mov	 rcx, rax
  000a1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@MONJHHJM@$?0?5czy?5chcesz?5grac?5dalej?$CI?8t?8?5?9?5t@
  000a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 138  : 	return (_STD move(_Istr) >> _Str);

  000bd	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]
  000c2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cin@std@@3V?$basic_istream@DU?$char_traits@D@std@@@1@A
  000c9	e8 00 00 00 00	 call	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000ce	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1607 : 		if (_Large_string_engaged())

  000d3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000d8	48 8b 5c 24 40	 mov	 rbx, QWORD PTR tak_nie$[rsp+24]
  000dd	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  000e1	48 0f 43 c1	 cmovae	 rax, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  000e5	4c 8b 44 24 38	 mov	 r8, QWORD PTR tak_nie$[rsp+16]
  000ea	49 83 f8 01	 cmp	 r8, 1
  000ee	75 1c		 jne	 SHORT $LN112@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000f0	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f3	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01PFHFFBPC@t?$AA@
  000f9	75 04		 jne	 SHORT $LN529@Czy_Kontyn
  000fb	33 c0		 xor	 eax, eax
  000fd	eb 05		 jmp	 SHORT $LN530@Czy_Kontyn
$LN529@Czy_Kontyn:
  000ff	1b c0		 sbb	 eax, eax
  00101	83 c8 01	 or	 eax, 1
$LN530@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00104	85 c0		 test	 eax, eax
  00106	0f 84 d9 01 00
	00		 je	 $LN503@Czy_Kontyn
$LN112@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0010c	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00111	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  00115	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00119	49 83 f8 03	 cmp	 r8, 3
  0011d	75 34		 jne	 SHORT $LN141@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0011f	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00122	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@
  00128	75 1c		 jne	 SHORT $LN527@Czy_Kontyn
  0012a	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  0012e	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@+1
  00134	75 10		 jne	 SHORT $LN527@Czy_Kontyn
  00136	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  0013a	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PFPKAEFD@tak?$AA@+2
  00140	75 04		 jne	 SHORT $LN527@Czy_Kontyn
  00142	33 c0		 xor	 eax, eax
  00144	eb 05		 jmp	 SHORT $LN528@Czy_Kontyn
$LN527@Czy_Kontyn:
  00146	1b c0		 sbb	 eax, eax
  00148	83 c8 01	 or	 eax, 1
$LN528@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0014b	85 c0		 test	 eax, eax
  0014d	0f 84 92 01 00
	00		 je	 $LN503@Czy_Kontyn
$LN141@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00153	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00158	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  0015c	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00160	49 83 f8 03	 cmp	 r8, 3
  00164	75 34		 jne	 SHORT $LN170@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00166	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00169	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@
  0016f	75 1c		 jne	 SHORT $LN525@Czy_Kontyn
  00171	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00175	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@+1
  0017b	75 10		 jne	 SHORT $LN525@Czy_Kontyn
  0017d	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  00181	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FFMIKLGN@Tak?$AA@+2
  00187	75 04		 jne	 SHORT $LN525@Czy_Kontyn
  00189	33 c0		 xor	 eax, eax
  0018b	eb 05		 jmp	 SHORT $LN526@Czy_Kontyn
$LN525@Czy_Kontyn:
  0018d	1b c0		 sbb	 eax, eax
  0018f	83 c8 01	 or	 eax, 1
$LN526@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00192	85 c0		 test	 eax, eax
  00194	0f 84 4b 01 00
	00		 je	 $LN503@Czy_Kontyn
$LN170@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0019a	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0019f	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  001a3	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001a7	49 83 f8 03	 cmp	 r8, 3
  001ab	75 34		 jne	 SHORT $LN199@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001ad	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  001b0	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@
  001b6	75 1c		 jne	 SHORT $LN523@Czy_Kontyn
  001b8	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  001bc	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@+1
  001c2	75 10		 jne	 SHORT $LN523@Czy_Kontyn
  001c4	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  001c8	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PIABMJCP@TAK?$AA@+2
  001ce	75 04		 jne	 SHORT $LN523@Czy_Kontyn
  001d0	33 c0		 xor	 eax, eax
  001d2	eb 05		 jmp	 SHORT $LN524@Czy_Kontyn
$LN523@Czy_Kontyn:
  001d4	1b c0		 sbb	 eax, eax
  001d6	83 c8 01	 or	 eax, 1
$LN524@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001d9	85 c0		 test	 eax, eax
  001db	0f 84 04 01 00
	00		 je	 $LN503@Czy_Kontyn
$LN199@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001e1	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001e6	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  001ea	48 0f 43 c1	 cmovae	 rax, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001ee	49 83 f8 01	 cmp	 r8, 1
  001f2	75 1c		 jne	 SHORT $LN228@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001f4	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001f7	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  001fd	75 04		 jne	 SHORT $LN521@Czy_Kontyn
  001ff	33 c0		 xor	 eax, eax
  00201	eb 05		 jmp	 SHORT $LN522@Czy_Kontyn
$LN521@Czy_Kontyn:
  00203	1b c0		 sbb	 eax, eax
  00205	83 c8 01	 or	 eax, 1
$LN522@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00208	85 c0		 test	 eax, eax
  0020a	0f 84 d5 00 00
	00		 je	 $LN503@Czy_Kontyn
$LN228@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00210	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00215	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  00219	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0021d	49 83 f8 03	 cmp	 r8, 3
  00221	75 34		 jne	 SHORT $LN257@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00223	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  00226	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@
  0022c	75 1c		 jne	 SHORT $LN519@Czy_Kontyn
  0022e	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00232	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@+1
  00238	75 10		 jne	 SHORT $LN519@Czy_Kontyn
  0023a	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  0023e	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FKMOMPJO@nie?$AA@+2
  00244	75 04		 jne	 SHORT $LN519@Czy_Kontyn
  00246	33 c0		 xor	 eax, eax
  00248	eb 05		 jmp	 SHORT $LN520@Czy_Kontyn
$LN519@Czy_Kontyn:
  0024a	1b c0		 sbb	 eax, eax
  0024c	83 c8 01	 or	 eax, 1
$LN520@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0024f	85 c0		 test	 eax, eax
  00251	0f 84 8e 00 00
	00		 je	 $LN503@Czy_Kontyn
$LN257@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00257	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0025c	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  00260	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00264	49 83 f8 03	 cmp	 r8, 3
  00268	75 30		 jne	 SHORT $LN286@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0026a	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  0026d	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@
  00273	75 1c		 jne	 SHORT $LN517@Czy_Kontyn
  00275	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  00279	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@+1
  0027f	75 10		 jne	 SHORT $LN517@Czy_Kontyn
  00281	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  00285	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03PKPMGAKA@Nie?$AA@+2
  0028b	75 04		 jne	 SHORT $LN517@Czy_Kontyn
  0028d	33 c0		 xor	 eax, eax
  0028f	eb 05		 jmp	 SHORT $LN518@Czy_Kontyn
$LN517@Czy_Kontyn:
  00291	1b c0		 sbb	 eax, eax
  00293	83 c8 01	 or	 eax, 1
$LN518@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00296	85 c0		 test	 eax, eax
  00298	74 4b		 je	 SHORT $LN503@Czy_Kontyn
$LN286@Czy_Kontyn:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0029a	48 8d 54 24 28	 lea	 rdx, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0029f	48 83 fb 10	 cmp	 rbx, 16

; 1607 : 		if (_Large_string_engaged())

  002a3	48 0f 43 d1	 cmovae	 rdx, rcx

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002a7	49 83 f8 03	 cmp	 r8, 3
  002ab	0f 85 cf fd ff
	ff		 jne	 $LL2@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002b1	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
  002b4	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@
  002ba	75 1c		 jne	 SHORT $LN515@Czy_Kontyn
  002bc	0f b6 42 01	 movzx	 eax, BYTE PTR [rdx+1]
  002c0	3a 05 01 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@+1
  002c6	75 10		 jne	 SHORT $LN515@Czy_Kontyn
  002c8	0f b6 42 02	 movzx	 eax, BYTE PTR [rdx+2]
  002cc	3a 05 02 00 00
	00		 cmp	 al, BYTE PTR ??_C@_03FHDFACOC@NIE?$AA@+2
  002d2	75 04		 jne	 SHORT $LN515@Czy_Kontyn
  002d4	33 c0		 xor	 eax, eax
  002d6	eb 05		 jmp	 SHORT $LN516@Czy_Kontyn
$LN515@Czy_Kontyn:
  002d8	1b c0		 sbb	 eax, eax
  002da	83 c8 01	 or	 eax, 1
$LN516@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  002dd	85 c0		 test	 eax, eax
  002df	0f 85 9b fd ff
	ff		 jne	 $LL2@Czy_Kontyn
$LN503@Czy_Kontyn:

; 1595 : 		value_type * _Result = _Bx._Buf;

  002e5	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002ea	48 83 fb 10	 cmp	 rbx, 16

; 1596 : 		if (_Large_string_engaged())

  002ee	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  002f2	80 38 74	 cmp	 BYTE PTR [rax], 116	; 00000074H
  002f5	74 17		 je	 SHORT $LN9@Czy_Kontyn
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  002f7	48 8d 44 24 28	 lea	 rax, QWORD PTR tak_nie$[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002fc	48 83 fb 10	 cmp	 rbx, 16

; 1596 : 		if (_Large_string_engaged())

  00300	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  00304	80 38 54	 cmp	 BYTE PTR [rax], 84	; 00000054H
  00307	74 05		 je	 SHORT $LN9@Czy_Kontyn
$_Invalid_parameter$536:

; 330  : 			else return false; //W przeciwym wypadku zwracam wartoœæ false

  00309	40 32 ff	 xor	 dil, dil
  0030c	eb 03		 jmp	 SHORT $LN13@Czy_Kontyn
$LN9@Czy_Kontyn:

; 329  : 			if (tak_nie[0] == 't' || tak_nie[0] == 'T') return true; //Je¿eli pasuje to sprawdzam czy pierwsza litera to t i zwracam wartoœæ true

  0030e	40 b7 01	 mov	 dil, 1
$LN13@Czy_Kontyn:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00311	48 83 fb 10	 cmp	 rbx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00315	72 3a		 jb	 SHORT $LN424@Czy_Kontyn

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00317	48 8d 43 01	 lea	 rax, QWORD PTR [rbx+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0031b	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00321	72 29		 jb	 SHORT $LN427@Czy_Kontyn

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00323	f6 44 24 28 1f	 test	 BYTE PTR tak_nie$[rsp], 31
  00328	75 1b		 jne	 SHORT $_Invalid_parameter$537

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0032a	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0032e	48 3b c1	 cmp	 rax, rcx
  00331	73 12		 jae	 SHORT $_Invalid_parameter$537
  00333	48 2b c8	 sub	 rcx, rax
  00336	48 83 e9 08	 sub	 rcx, 8
  0033a	48 83 f9 1f	 cmp	 rcx, 31
  0033e	77 05		 ja	 SHORT $_Invalid_parameter$537

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00340	48 8b c8	 mov	 rcx, rax
  00343	eb 07		 jmp	 SHORT $LN427@Czy_Kontyn
$_Invalid_parameter$537:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00345	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0034b	cc		 int	 3
$LN427@Czy_Kontyn:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0034c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN424@Czy_Kontyn:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 330  : 			else return false; //W przeciwym wypadku zwracam wartoœæ false

  00351	40 0f b6 c7	 movzx	 eax, dil

; 331  : 	}
; 332  : }

  00355	48 8b 4c 24 48	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0035a	48 33 cc	 xor	 rcx, rsp
  0035d	e8 00 00 00 00	 call	 __security_check_cookie
  00362	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00367	48 83 c4 50	 add	 rsp, 80			; 00000050H
  0036b	5f		 pop	 rdi
  0036c	c3		 ret	 0
$LN533@Czy_Kontyn:
?Czy_Kontynuowaæ@@YA_NAEBH@Z ENDP			; Czy_Kontynuowaæ
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T65 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloœæ_pieniêdzy$ = 96
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA PROC	; `Czy_Kontynuowaæ'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR tak_nie$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA ENDP	; `Czy_Kontynuowaæ'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T65 = 32
tak_nie$ = 40
__$ArrayPad$ = 72
iloœæ_pieniêdzy$ = 96
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA PROC	; `Czy_Kontynuowaæ'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR tak_nie$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Czy_Kontynuowaæ@@YA_NAEBH@Z@4HA ENDP	; `Czy_Kontynuowaæ'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Change_Col@@YAXAEBH@Z
_TEXT	SEGMENT
num_of_col$ = 48
?Change_Col@@YAXAEBH@Z PROC				; Change_Col, COMDAT

; 335  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00009	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0000e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  00014	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  00017	48 8b c8	 mov	 rcx, rax

; 338  : }

  0001a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001e	5b		 pop	 rbx

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0001f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_SetConsoleTextAttribute
?Change_Col@@YAXAEBH@Z ENDP				; Change_Col
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Hide_Cursor@@YAXXZ
_TEXT	SEGMENT
hCCI$ = 32
__$ArrayPad$ = 40
?Hide_Cursor@@YAXXZ PROC				; Hide_Cursor, COMDAT

; 341  : {

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 342  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00015	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 343  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 344  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00020	48 8b c8	 mov	 rcx, rax
  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00028	48 8b d8	 mov	 rbx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 345  : 	hCCI.bVisible = FALSE; //Zmiena widocznoœci kursora na niewidoczny
; 346  : 	SetConsoleCursorInfo(hConsoleOut, &hCCI); //Ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00031	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00036	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hCCI$[rsp+4], 0
  0003e	48 8b cb	 mov	 rcx, rbx
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo

; 347  : }

  00047	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  0004c	48 33 cc	 xor	 rcx, rsp
  0004f	e8 00 00 00 00	 call	 __security_check_cookie
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
?Hide_Cursor@@YAXXZ ENDP				; Hide_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Show_Cursor@@YAXXZ
_TEXT	SEGMENT
hCCI$ = 32
__$ArrayPad$ = 40
?Show_Cursor@@YAXXZ PROC				; Show_Cursor, COMDAT

; 350  : {

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0000d	48 33 c4	 xor	 rax, rsp
  00010	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 351  : 	HANDLE hConsoleOut = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00015	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0001a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 352  : 	CONSOLE_CURSOR_INFO hCCI; //Stworzenie zmiennej typu informacji o kursorze tekstowym w konsoli
; 353  : 	GetConsoleCursorInfo(hConsoleOut, &hCCI); //Przypisanie do zmiennej informacji o kursorze tekstowym w konsoli

  00020	48 8b c8	 mov	 rcx, rax
  00023	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  00028	48 8b d8	 mov	 rbx, rax
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetConsoleCursorInfo

; 354  : 	if (hCCI.bVisible != TRUE) //Sprawdzenie czy wartoœæ widocznoœci kursorsora tekstego w konsoli jest ró¿na od prawdy

  00031	83 7c 24 24 01	 cmp	 DWORD PTR hCCI$[rsp+4], 1
  00036	74 16		 je	 SHORT $LN2@Show_Curso

; 355  : 	{
; 356  : 		hCCI.bVisible = TRUE;//Je¿eli tak, to zmiena widocznoœci kursora na widoczny
; 357  : 		SetConsoleCursorInfo(hConsoleOut, &hCCI); //I ustawienie widocznoœci kursora zgodnie z poprzedni¹ zmienn¹

  00038	48 8d 54 24 20	 lea	 rdx, QWORD PTR hCCI$[rsp]
  0003d	c7 44 24 24 01
	00 00 00	 mov	 DWORD PTR hCCI$[rsp+4], 1
  00045	48 8b cb	 mov	 rcx, rbx
  00048	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleCursorInfo
$LN2@Show_Curso:

; 358  : 	}
; 359  : }

  0004e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00053	48 33 cc	 xor	 rcx, rsp
  00056	e8 00 00 00 00	 call	 __security_check_cookie
  0005b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0005f	5b		 pop	 rbx
  00060	c3		 ret	 0
?Show_Cursor@@YAXXZ ENDP				; Show_Cursor
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wylosuj@@YAHAEBH0@Z
_TEXT	SEGMENT
$T21 = 40
$T1 = 40
od_liczby$ = 112
do_liczby$ = 120
?Wylosuj@@YAHAEBH0@Z PROC				; Wylosuj, COMDAT

; 362  : {

$LN448:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000c	48 c7 40 b8 fe
	ff ff ff	 mov	 QWORD PTR [rax-72], -2
  00014	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00018	48 89 68 10	 mov	 QWORD PTR [rax+16], rbp
  0001c	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  00020	4c 8b f2	 mov	 r14, rdx
  00023	4c 8b f9	 mov	 r15, rcx

; 363  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  00026	8b 39		 mov	 edi, DWORD PTR [rcx]
  00028	8b 32		 mov	 esi, DWORD PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0002a	48 c7 40 d8 0f
	00 00 00	 mov	 QWORD PTR [rax-40], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00032	c6 40 c0 00	 mov	 BYTE PTR [rax-64], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00036	33 db		 xor	 ebx, ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00038	45 33 c0	 xor	 r8d, r8d
  0003b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00042	48 8d 48 c0	 lea	 rcx, QWORD PTR [rax-64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00046	48 89 58 d0	 mov	 QWORD PTR [rax-48], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00050	88 5c 24 28	 mov	 BYTE PTR $T1[rsp], bl
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 363  : 	if (od_liczby > do_liczby) //Je¿eli od jest wiêksze ni¿ do to

  00054	3b fe		 cmp	 edi, esi
  00056	0f 8e c3 00 00
	00		 jle	 $LN2@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00062	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR $T1[rsp+24]
  00068	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0006c	72 3c		 jb	 SHORT $LN90@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0006e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T1[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00073	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00076	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0007c	72 27		 jb	 SHORT $LN93@Wylosuj

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0007e	f6 c1 1f	 test	 cl, 31
  00081	75 1b		 jne	 SHORT $_Invalid_parameter$449

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00083	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00087	48 3b c1	 cmp	 rax, rcx
  0008a	73 12		 jae	 SHORT $_Invalid_parameter$449
  0008c	48 2b c8	 sub	 rcx, rax
  0008f	48 83 e9 08	 sub	 rcx, 8
  00093	48 83 f9 1f	 cmp	 rcx, 31
  00097	77 05		 ja	 SHORT $_Invalid_parameter$449

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00099	48 8b c8	 mov	 rcx, rax
  0009c	eb 07		 jmp	 SHORT $LN93@Wylosuj
$_Invalid_parameter$449:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000a4	cc		 int	 3
$LN93@Wylosuj:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000a5	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN90@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  000aa	41 bf 00 00 00
	80		 mov	 r15d, -2147483648	; ffffffff80000000H
  000b0	46 8d 34 3e	 lea	 r14d, DWORD PTR [rsi+r15]

; 2356 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2357 : 
; 2358 : 		_Uty _Uret = 0;
; 2359 : 
; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  000b4	41 2b fe	 sub	 edi, r14d
  000b7	41 03 ff	 add	 edi, r15d
  000ba	83 ff ff	 cmp	 edi, -1			; ffffffffH
  000bd	75 0f		 jne	 SHORT $LN135@Wylosuj
  000bf	90		 npad	 1
$LL165@Wylosuj:

; 6442 : 		return (_Random_device());

  000c0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  000c6	8b d0		 mov	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  000c8	84 db		 test	 bl, bl
  000ca	75 f4		 jne	 SHORT $LL165@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2362 : 		else

  000cc	eb 46		 jmp	 SHORT $LN176@Wylosuj
$LN135@Wylosuj:

; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  000ce	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
$LL175@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3487 : 			_Udiff _Ret = 0;	// random bits

  000d1	44 8b c3	 mov	 r8d, ebx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  000d4	8b c3		 mov	 eax, ebx

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  000d6	85 ff		 test	 edi, edi
  000d8	74 1a		 je	 SHORT $LN179@Wylosuj
  000da	66 0f 1f 44 00
	00		 npad	 6
$LL184@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  000e6	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  000e9	84 db		 test	 bl, bl
  000eb	75 f3		 jne	 SHORT $LL184@Wylosuj

; 3497 : 				_Mask |= _Bmask;

  000ed	83 c8 ff	 or	 eax, -1			; ffffffffH

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  000f0	84 db		 test	 bl, bl
  000f2	75 ec		 jne	 SHORT $LL184@Wylosuj
$LN179@Wylosuj:

; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  000f4	33 d2		 xor	 edx, edx
  000f6	f7 f6		 div	 esi
  000f8	44 8b ca	 mov	 r9d, edx
  000fb	8b c8		 mov	 ecx, eax
  000fd	33 d2		 xor	 edx, edx
  000ff	41 8b c0	 mov	 eax, r8d
  00102	f7 f6		 div	 esi
  00104	3b c1		 cmp	 eax, ecx
  00106	72 05		 jb	 SHORT $LN409@Wylosuj
  00108	44 3b cf	 cmp	 r9d, edi
  0010b	75 c4		 jne	 SHORT $LL175@Wylosuj
$LN409@Wylosuj:

; 3503 : 				return (_Ret % _Index);

  0010d	33 d2		 xor	 edx, edx
  0010f	41 8b c0	 mov	 eax, r8d
  00112	f7 f6		 div	 esi
$LN176@Wylosuj:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 379  : 		return distribution(generator); //Zwraca wygenerowan¹ liczbê z uwzglêdnieniem przedzia³u

  00114	4b 8d 04 3e	 lea	 rax, QWORD PTR [r14+r15]
  00118	03 c2		 add	 eax, edx
  0011a	e9 bb 00 00 00	 jmp	 $LN1@Wylosuj
$LN2@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  0011f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00125	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00126	48 8b 44 24 40	 mov	 rax, QWORD PTR $T21[rsp+24]
  0012b	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0012f	72 3c		 jb	 SHORT $LN281@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00131	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T21[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00136	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00139	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0013f	72 27		 jb	 SHORT $LN284@Wylosuj

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00141	f6 c1 1f	 test	 cl, 31
  00144	75 1b		 jne	 SHORT $_Invalid_parameter$450

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00146	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0014a	48 3b c1	 cmp	 rax, rcx
  0014d	73 12		 jae	 SHORT $_Invalid_parameter$450
  0014f	48 2b c8	 sub	 rcx, rax
  00152	48 83 e9 08	 sub	 rcx, 8
  00156	48 83 f9 1f	 cmp	 rcx, 31
  0015a	77 05		 ja	 SHORT $_Invalid_parameter$450

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0015c	48 8b c8	 mov	 rcx, rax
  0015f	eb 07		 jmp	 SHORT $LN284@Wylosuj
$_Invalid_parameter$450:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00161	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00167	cc		 int	 3
$LN284@Wylosuj:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00168	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN281@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2256 : 			_Min = _Min0;

  0016d	41 8b 2f	 mov	 ebp, DWORD PTR [r15]

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00170	41 8b 3e	 mov	 edi, DWORD PTR [r14]

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  00173	41 bf 00 00 00
	80		 mov	 r15d, -2147483648	; ffffffff80000000H
  00179	41 03 ef	 add	 ebp, r15d

; 2356 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2357 : 
; 2358 : 		_Uty _Uret = 0;
; 2359 : 
; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  0017c	2b fd		 sub	 edi, ebp
  0017e	41 03 ff	 add	 edi, r15d
  00181	83 ff ff	 cmp	 edi, -1			; ffffffffH
  00184	75 0e		 jne	 SHORT $LN325@Wylosuj
$LL355@Wylosuj:

; 6442 : 		return (_Random_device());

  00186	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  0018c	8b d0		 mov	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  0018e	84 db		 test	 bl, bl
  00190	75 f4		 jne	 SHORT $LL355@Wylosuj
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2362 : 		else

  00192	eb 40		 jmp	 SHORT $LN366@Wylosuj
$LN325@Wylosuj:

; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  00194	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
$LL365@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3487 : 			_Udiff _Ret = 0;	// random bits

  00197	44 8b c3	 mov	 r8d, ebx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  0019a	8b c3		 mov	 eax, ebx

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0019c	85 ff		 test	 edi, edi
  0019e	74 14		 je	 SHORT $LN369@Wylosuj
$LL374@Wylosuj:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  001a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  001a6	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  001a9	84 db		 test	 bl, bl
  001ab	75 f3		 jne	 SHORT $LL374@Wylosuj

; 3497 : 				_Mask |= _Bmask;

  001ad	83 c8 ff	 or	 eax, -1			; ffffffffH

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  001b0	84 db		 test	 bl, bl
  001b2	75 ec		 jne	 SHORT $LL374@Wylosuj
$LN369@Wylosuj:

; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  001b4	33 d2		 xor	 edx, edx
  001b6	f7 f6		 div	 esi
  001b8	44 8b ca	 mov	 r9d, edx
  001bb	8b c8		 mov	 ecx, eax
  001bd	33 d2		 xor	 edx, edx
  001bf	41 8b c0	 mov	 eax, r8d
  001c2	f7 f6		 div	 esi
  001c4	3b c1		 cmp	 eax, ecx
  001c6	72 05		 jb	 SHORT $LN412@Wylosuj
  001c8	44 3b cf	 cmp	 r9d, edi
  001cb	75 ca		 jne	 SHORT $LL365@Wylosuj
$LN412@Wylosuj:

; 3503 : 				return (_Ret % _Index);

  001cd	33 d2		 xor	 edx, edx
  001cf	41 8b c0	 mov	 eax, r8d
  001d2	f7 f6		 div	 esi
$LN366@Wylosuj:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 394  : 	return distribution(generator); //Zwraca wygenerowan¹ liczbê

  001d4	4a 8d 04 3a	 lea	 rax, QWORD PTR [rdx+r15]
  001d8	03 c5		 add	 eax, ebp
$LN1@Wylosuj:

; 395  : }

  001da	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  001df	48 8b 6c 24 78	 mov	 rbp, QWORD PTR [rsp+120]
  001e4	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  001ec	48 83 c4 50	 add	 rsp, 80			; 00000050H
  001f0	41 5f		 pop	 r15
  001f2	41 5e		 pop	 r14
  001f4	5f		 pop	 rdi
  001f5	c3		 ret	 0
$LN447@Wylosuj:
?Wylosuj@@YAHAEBH0@Z ENDP				; Wylosuj
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T21 = 40
$T1 = 40
od_liczby$ = 112
do_liczby$ = 120
?dtor$0@?0??Wylosuj@@YAHAEBH0@Z@4HA PROC		; `Wylosuj'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wylosuj@@YAHAEBH0@Z@4HA ENDP		; `Wylosuj'::`1'::dtor$0
$T21 = 40
$T1 = 40
od_liczby$ = 112
do_liczby$ = 120
?dtor$1@?0??Wylosuj@@YAHAEBH0@Z@4HA PROC		; `Wylosuj'::`1'::dtor$1
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T21[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wylosuj@@YAHAEBH0@Z@4HA ENDP		; `Wylosuj'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 40
$T1 = 40
od_liczby$ = 112
do_liczby$ = 120
?dtor$0@?0??Wylosuj@@YAHAEBH0@Z@4HA PROC		; `Wylosuj'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wylosuj@@YAHAEBH0@Z@4HA ENDP		; `Wylosuj'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T21 = 40
$T1 = 40
od_liczby$ = 112
do_liczby$ = 120
?dtor$1@?0??Wylosuj@@YAHAEBH0@Z@4HA PROC		; `Wylosuj'::`1'::dtor$1
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T21[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wylosuj@@YAHAEBH0@Z@4HA ENDP		; `Wylosuj'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Odczytaj_liczbê, COMDAT

; 397  : void Odczytaj_liczbê(const int & wylosowana_liczba, const string & typ_zak³adu) {

$LN2872:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 8d a8 08 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-504]
  00013	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  0001a	48 c7 45 90 fe
	ff ff ff	 mov	 QWORD PTR $T389[rbp-256], -2
  00022	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00026	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0002a	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 85 c0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0003f	48 8b da	 mov	 rbx, rdx
  00042	48 8b f1	 mov	 rsi, rcx
  00045	45 33 f6	 xor	 r14d, r14d
  00048	44 89 74 24 20	 mov	 DWORD PTR $T1[rsp], r14d

; 398  : 	if ((g³os_odczytu_numeru == 0) || (!G³osyKompletne)) return; //Je¿eli ustawienia wy³¹czaj¹ g³os lub brak plików g³osu to wyjdŸ z funkcji

  0004d	66 44 39 35 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, r14w ; g³os_odczytu_numeru
  00055	0f 84 6d 0f 00
	00		 je	 $LN3@Odczytaj_l
  0005b	44 38 35 00 00
	00 00		 cmp	 BYTE PTR ?G³osyKompletne@@3_NA, r14b ; G³osyKompletne
  00062	0f 84 60 0f 00
	00		 je	 $LN3@Odczytaj_l
  00068	33 d2		 xor	 edx, edx
  0006a	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00070	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  00077	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  0007c	4c 8d 3d 00 00
	00 00		 lea	 r15, OFFSET FLAT:__ImageBase
  00083	49 8d 87 00 00
	00 00		 lea	 rax, QWORD PTR ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@[r15]
  0008a	48 89 85 c0 00
	00 00		 mov	 QWORD PTR numers$[rbp-256], rax
  00091	4c 8d 2d 00 00
	00 00		 lea	 r13, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00098	4c 89 ad d0 00
	00 00		 mov	 QWORD PTR numers$[rbp-240], r13
  0009f	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-104]
  000a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000ac	90		 npad	 1
  000ad	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  000b5	45 33 c0	 xor	 r8d, r8d
  000b8	48 8d 95 d8 00
	00 00		 lea	 rdx, QWORD PTR numers$[rbp-232]
  000bf	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  000cc	90		 npad	 1

; 593  : 		{	// construct empty character buffer

  000cd	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  000d4	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000d8	4c 8d 25 00 00
	00 00		 lea	 r12, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000df	4c 89 a4 0d c0
	00 00 00	 mov	 QWORD PTR numers$[rbp+rcx-256], r12
  000e7	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  000ee	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000f2	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  000f8	89 94 0d bc 00
	00 00		 mov	 DWORD PTR numers$[rbp+rcx-260], edx

; 592  : 			_Stringbuffer(_Mode)

  000ff	48 8d 85 d8 00
	00 00		 lea	 rax, QWORD PTR numers$[rbp-232]
  00106	48 89 45 88	 mov	 QWORD PTR this$[rbp-256], rax

; 30   : 		{	// construct empty character buffer from mode

  0010a	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-232]
  00111	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00117	90		 npad	 1
  00118	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0011f	48 89 85 d8 00
	00 00		 mov	 QWORD PTR numers$[rbp-232], rax

; 311  : 		_Seekhigh = 0;

  00126	4c 89 b5 40 01
	00 00		 mov	 QWORD PTR numers$[rbp-128], r14

; 312  : 		_Mystate = _State;

  0012d	44 89 b5 48 01
	00 00		 mov	 DWORD PTR numers$[rbp-120], r14d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 401  : 	numers << wylosowana_liczba; //Wpisanie to typu wylosowanej liczby

  00134	8b 16		 mov	 edx, DWORD PTR [rsi]
  00136	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-240]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 402  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  00143	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T6[rsp]
  00148	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-256]
  0014f	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00154	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00155	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  0015c	4c 8b c7	 mov	 r8, rdi
  0015f	48 8b c8	 mov	 rcx, rax
  00162	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00167	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  0016a	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T13[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00170	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00173	0f 11 44 24 68	 movups	 XMMWORD PTR $T13[rsp], xmm0
  00178	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0017c	0f 11 4c 24 78	 movups	 XMMWORD PTR $T13[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00181	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00185	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0018d	44 88 30	 mov	 BYTE PTR [rax], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00190	45 8d 46 04	 lea	 r8d, QWORD PTR [r14+4]
  00194	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  0019b	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T13[rsp]
  001a0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  001a5	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  001a8	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T29[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  001ae	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  001b1	0f 11 44 24 48	 movups	 XMMWORD PTR $T29[rsp], xmm0
  001b6	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  001ba	0f 11 4c 24 58	 movups	 XMMWORD PTR $T29[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  001bf	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001c3	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001cb	44 88 30	 mov	 BYTE PTR [rax], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001ce	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T29[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001d3	48 83 7c 24 60
	10		 cmp	 QWORD PTR $T29[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  001d9	48 0f 43 4c 24
	48		 cmovae	 rcx, QWORD PTR $T29[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 402  : 	PlaySound((G³os + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Odczytanie wylosowanego numeru

  001df	45 33 c0	 xor	 r8d, r8d
  001e2	33 d2		 xor	 edx, edx
  001e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001ea	48 8b 44 24 60	 mov	 rax, QWORD PTR $T29[rsp+24]
  001ef	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  001f3	72 3c		 jb	 SHORT $LN280@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001f5	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  001f8	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T29[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001fd	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00203	72 27		 jb	 SHORT $LN283@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00205	f6 c1 1f	 test	 cl, 31
  00208	75 1b		 jne	 SHORT $_Invalid_parameter$2873

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0020a	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0020e	48 3b c1	 cmp	 rax, rcx
  00211	73 12		 jae	 SHORT $_Invalid_parameter$2873
  00213	48 2b c8	 sub	 rcx, rax
  00216	48 83 e9 08	 sub	 rcx, 8
  0021a	48 83 f9 1f	 cmp	 rcx, 31
  0021e	77 05		 ja	 SHORT $_Invalid_parameter$2873

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00220	48 8b c8	 mov	 rcx, rax
  00223	eb 07		 jmp	 SHORT $LN283@Odczytaj_l
$_Invalid_parameter$2873:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00225	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0022b	cc		 int	 3
$LN283@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0022c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN280@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00231	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00239	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T29[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0023f	c6 44 24 48 00	 mov	 BYTE PTR $T29[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00244	48 8b 45 80	 mov	 rax, QWORD PTR $T13[rbp-232]
  00248	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0024c	72 3c		 jb	 SHORT $LN326@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0024e	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00251	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T13[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00256	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0025c	72 27		 jb	 SHORT $LN329@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0025e	f6 c1 1f	 test	 cl, 31
  00261	75 1b		 jne	 SHORT $_Invalid_parameter$2874

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00263	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00267	48 3b c1	 cmp	 rax, rcx
  0026a	73 12		 jae	 SHORT $_Invalid_parameter$2874
  0026c	48 2b c8	 sub	 rcx, rax
  0026f	48 83 e9 08	 sub	 rcx, 8
  00273	48 83 f9 1f	 cmp	 rcx, 31
  00277	77 05		 ja	 SHORT $_Invalid_parameter$2874

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00279	48 8b c8	 mov	 rcx, rax
  0027c	eb 07		 jmp	 SHORT $LN329@Odczytaj_l
$_Invalid_parameter$2874:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00284	cc		 int	 3
$LN329@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00285	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN326@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0028a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00292	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T13[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00298	c6 44 24 68 00	 mov	 BYTE PTR $T13[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0029d	48 8b 44 24 40	 mov	 rax, QWORD PTR $T6[rsp+24]
  002a2	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  002a6	72 3c		 jb	 SHORT $LN372@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002a8	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  002ab	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T6[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  002b0	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  002b6	72 27		 jb	 SHORT $LN375@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  002b8	f6 c1 1f	 test	 cl, 31
  002bb	75 1b		 jne	 SHORT $_Invalid_parameter$2875

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002bd	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  002c1	48 3b c1	 cmp	 rax, rcx
  002c4	73 12		 jae	 SHORT $_Invalid_parameter$2875
  002c6	48 2b c8	 sub	 rcx, rax
  002c9	48 83 e9 08	 sub	 rcx, 8
  002cd	48 83 f9 1f	 cmp	 rcx, 31
  002d1	77 05		 ja	 SHORT $_Invalid_parameter$2875

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  002d3	48 8b c8	 mov	 rcx, rax
  002d6	eb 07		 jmp	 SHORT $LN375@Odczytaj_l
$_Invalid_parameter$2875:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002de	cc		 int	 3
$LN375@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  002df	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN372@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 403  : 	if (wylosowana_liczba != 0)

  002e4	4c 63 06	 movsxd	 r8, DWORD PTR [rsi]
  002e7	45 85 c0	 test	 r8d, r8d
  002ea	0f 84 87 0c 00
	00		 je	 $LN808@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002f0	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002f3	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
  002f7	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  002fb	72 03		 jb	 SHORT $LN406@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002fd	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN406@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00300	48 8b 53 10	 mov	 rdx, QWORD PTR [rbx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00304	48 83 fa 01	 cmp	 rdx, 1
  00308	75 19		 jne	 SHORT $LN414@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0030a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030d	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JBBJJEPG@p?$AA@
  00313	75 05		 jne	 SHORT $LN2867@Odczytaj_l
  00315	41 8b c6	 mov	 eax, r14d
  00318	eb 05		 jmp	 SHORT $LN2868@Odczytaj_l
$LN2867@Odczytaj_l:
  0031a	1b c0		 sbb	 eax, eax
  0031c	83 c8 01	 or	 eax, 1
$LN2868@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0031f	85 c0		 test	 eax, eax
  00321	74 33		 je	 SHORT $LN7@Odczytaj_l
$LN414@Odczytaj_l:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00323	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00326	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  0032a	72 03		 jb	 SHORT $LN435@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0032c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN435@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0032f	48 83 fa 01	 cmp	 rdx, 1
  00333	0f 85 e6 01 00
	00		 jne	 $LN443@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00339	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0033c	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01EFFIKLCJ@n?$AA@
  00342	75 05		 jne	 SHORT $LN2865@Odczytaj_l
  00344	41 8b c6	 mov	 eax, r14d
  00347	eb 05		 jmp	 SHORT $LN2866@Odczytaj_l
$LN2865@Odczytaj_l:
  00349	1b c0		 sbb	 eax, eax
  0034b	83 c8 01	 or	 eax, 1
$LN2866@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0034e	85 c0		 test	 eax, eax
  00350	0f 85 c9 01 00
	00		 jne	 $LN443@Odczytaj_l
$LN7@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 405  : 			if (wylosowana_liczba % 2 == 0) //Je¿eli wylosowana liczba modulo 2 jest 0 to

  00356	41 f6 c0 01	 test	 r8b, 1
  0035a	0f 85 e3 00 00
	00		 jne	 $LN8@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00360	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00368	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T63[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0036e	c6 44 24 28 00	 mov	 BYTE PTR $T63[rsp], 0
  00373	c7 44 24 20 0f
	00 00 00	 mov	 DWORD PTR $T1[rsp], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0037b	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00382	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  00386	48 83 fa 10	 cmp	 rdx, 16
  0038a	72 16		 jb	 SHORT $LN493@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0038c	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T63[rsp]
  00391	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00396	4c 89 74 24 38	 mov	 QWORD PTR $T63[rsp+16], r14
  0039b	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN493@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003a2	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  003aa	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  003b2	48 8b d7	 mov	 rdx, rdi
  003b5	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T63[rsp]
  003ba	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003bf	41 b8 05 00 00
	00		 mov	 r8d, 5
  003c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  003cc	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T63[rsp]
  003d1	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  003d6	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T63[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003db	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T63[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  003e1	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T63[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 406  : 				PlaySound((G³os + "p.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana licza jest parzysta

  003e7	45 33 c0	 xor	 r8d, r8d
  003ea	33 d2		 xor	 edx, edx
  003ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  003f2	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003f3	48 8b 44 24 40	 mov	 rax, QWORD PTR $T63[rsp+24]
  003f8	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  003fc	0f 82 75 0b 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00402	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00405	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T63[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0040a	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00410	72 27		 jb	 SHORT $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00412	f6 c1 1f	 test	 cl, 31
  00415	75 1b		 jne	 SHORT $_Invalid_parameter$2876

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00417	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0041b	48 3b c1	 cmp	 rax, rcx
  0041e	73 12		 jae	 SHORT $_Invalid_parameter$2876
  00420	48 2b c8	 sub	 rcx, rax
  00423	48 83 e9 08	 sub	 rcx, 8
  00427	48 83 f9 1f	 cmp	 rcx, 31
  0042b	77 05		 ja	 SHORT $_Invalid_parameter$2876
$LN2871@Odczytaj_l:

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0042d	48 8b c8	 mov	 rcx, rax
  00430	eb 07		 jmp	 SHORT $LN622@Odczytaj_l
$_Invalid_parameter$2876:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00432	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00438	cc		 int	 3
$LN622@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00439	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 407  : 			else

  0043e	e9 34 0b 00 00	 jmp	 $LN808@Odczytaj_l
$LN8@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00443	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0044b	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T86[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00451	c6 44 24 28 00	 mov	 BYTE PTR $T86[rsp], 0
  00456	c7 44 24 20 17
	00 00 00	 mov	 DWORD PTR $T1[rsp], 23
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0045e	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00465	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  00469	48 83 fa 10	 cmp	 rdx, 16
  0046d	72 16		 jb	 SHORT $LN682@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0046f	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T86[rsp]
  00474	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00479	4c 89 74 24 38	 mov	 QWORD PTR $T86[rsp+16], r14
  0047e	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN682@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00485	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  0048d	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00495	48 8b d7	 mov	 rdx, rdi
  00498	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T86[rsp]
  0049d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  004a2	41 b8 05 00 00
	00		 mov	 r8d, 5
  004a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  004af	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T86[rsp]
  004b4	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004b9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T86[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004be	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T86[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  004c4	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T86[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 408  : 				PlaySound((G³os + "n.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana licza jest nieparzysta

  004ca	45 33 c0	 xor	 r8d, r8d
  004cd	33 d2		 xor	 edx, edx
  004cf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  004d5	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004d6	48 8b 44 24 40	 mov	 rax, QWORD PTR $T86[rsp+24]
  004db	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  004df	0f 82 92 0a 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  004e5	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  004e8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T86[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  004ed	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  004f3	0f 82 40 ff ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  004f9	f6 c1 1f	 test	 cl, 31
  004fc	75 1a		 jne	 SHORT $_Invalid_parameter$2877

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  004fe	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00502	48 3b c1	 cmp	 rax, rcx
  00505	73 11		 jae	 SHORT $_Invalid_parameter$2877
  00507	48 2b c8	 sub	 rcx, rax
  0050a	48 83 e9 08	 sub	 rcx, 8
  0050e	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00512	0f 86 15 ff ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2877:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00518	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0051e	cc		 int	 3
$LN443@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0051f	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00522	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  00526	72 03		 jb	 SHORT $LN842@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00528	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN842@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0052b	48 83 fa 01	 cmp	 rdx, 1
  0052f	75 19		 jne	 SHORT $LN850@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00531	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00534	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01KDCPPGHE@r?$AA@
  0053a	75 05		 jne	 SHORT $LN2863@Odczytaj_l
  0053c	41 8b c6	 mov	 eax, r14d
  0053f	eb 05		 jmp	 SHORT $LN2864@Odczytaj_l
$LN2863@Odczytaj_l:
  00541	1b c0		 sbb	 eax, eax
  00543	83 c8 01	 or	 eax, 1
$LN2864@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00546	85 c0		 test	 eax, eax
  00548	74 33		 je	 SHORT $LN12@Odczytaj_l
$LN850@Odczytaj_l:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0054a	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0054d	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  00551	72 03		 jb	 SHORT $LN871@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00553	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN871@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00556	48 83 fa 01	 cmp	 rdx, 1
  0055a	0f 85 e4 01 00
	00		 jne	 $LN879@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00560	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00563	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01OJONOECF@b?$AA@
  00569	75 05		 jne	 SHORT $LN2861@Odczytaj_l
  0056b	41 8b c6	 mov	 eax, r14d
  0056e	eb 05		 jmp	 SHORT $LN2862@Odczytaj_l
$LN2861@Odczytaj_l:
  00570	1b c0		 sbb	 eax, eax
  00572	83 c8 01	 or	 eax, 1
$LN2862@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00575	85 c0		 test	 eax, eax
  00577	0f 85 c7 01 00
	00		 jne	 $LN879@Odczytaj_l
$LN12@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 410  : 			if (Ruletka_plansza_kolor[wylosowana_liczba] == 'r') //Je¿eli kolor wylosowanej liczby to czerwony

  0057d	43 80 bc 38 00
	00 00 00 72	 cmp	 BYTE PTR ?Ruletka_plansza_kolor@@3QBDB[r8+r15], 114 ; 00000072H
  00586	0f 85 dc 00 00
	00		 jne	 $LN13@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0058c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00594	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T119[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0059a	c6 44 24 28 00	 mov	 BYTE PTR $T119[rsp], 0
  0059f	c7 44 24 20 27
	00 00 00	 mov	 DWORD PTR $T1[rsp], 39	; 00000027H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  005a7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  005ae	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  005b2	48 83 fa 10	 cmp	 rdx, 16
  005b6	72 16		 jb	 SHORT $LN929@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  005b8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T119[rsp]
  005bd	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  005c2	4c 89 74 24 38	 mov	 QWORD PTR $T119[rsp+16], r14
  005c7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN929@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005ce	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  005d6	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  005de	48 8b d7	 mov	 rdx, rdi
  005e1	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T119[rsp]
  005e6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  005eb	41 b8 05 00 00
	00		 mov	 r8d, 5
  005f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  005f8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T119[rsp]
  005fd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00602	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T119[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00607	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T119[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  0060d	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T119[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 411  : 				PlaySound((G³os + "r.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest koloru czerwonego

  00613	45 33 c0	 xor	 r8d, r8d
  00616	33 d2		 xor	 edx, edx
  00618	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  0061e	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0061f	48 8b 44 24 40	 mov	 rax, QWORD PTR $T119[rsp+24]
  00624	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00628	0f 82 49 09 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0062e	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00631	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T119[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00636	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0063c	0f 82 f7 fd ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00642	f6 c1 1f	 test	 cl, 31
  00645	75 1a		 jne	 SHORT $_Invalid_parameter$2878

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00647	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0064b	48 3b c1	 cmp	 rax, rcx
  0064e	73 11		 jae	 SHORT $_Invalid_parameter$2878
  00650	48 2b c8	 sub	 rcx, rax
  00653	48 83 e9 08	 sub	 rcx, 8
  00657	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0065b	0f 86 cc fd ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2878:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00661	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00667	90		 npad	 1
$LN13@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00668	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00670	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T142[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00676	c6 44 24 28 00	 mov	 BYTE PTR $T142[rsp], 0
  0067b	c7 44 24 20 47
	00 00 00	 mov	 DWORD PTR $T1[rsp], 71	; 00000047H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00683	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0068a	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  0068e	48 83 fa 10	 cmp	 rdx, 16
  00692	72 16		 jb	 SHORT $LN1118@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00694	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T142[rsp]
  00699	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  0069e	4c 89 74 24 38	 mov	 QWORD PTR $T142[rsp+16], r14
  006a3	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1118@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006aa	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  006b2	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  006ba	48 8b d7	 mov	 rdx, rdi
  006bd	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T142[rsp]
  006c2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  006c7	41 b8 05 00 00
	00		 mov	 r8d, 5
  006cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  006d4	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T142[rsp]
  006d9	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  006de	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T142[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006e3	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T142[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  006e9	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T142[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 413  : 				PlaySound((G³os + "b.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e liczba jest koloru czarnego

  006ef	45 33 c0	 xor	 r8d, r8d
  006f2	33 d2		 xor	 edx, edx
  006f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  006fa	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006fb	48 8b 44 24 40	 mov	 rax, QWORD PTR $T142[rsp+24]
  00700	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00704	0f 82 6d 08 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0070a	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0070d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T142[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00712	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00718	0f 82 1b fd ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0071e	f6 c1 1f	 test	 cl, 31
  00721	75 1a		 jne	 SHORT $_Invalid_parameter$2879

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00723	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00727	48 3b c1	 cmp	 rax, rcx
  0072a	73 11		 jae	 SHORT $_Invalid_parameter$2879
  0072c	48 2b c8	 sub	 rcx, rax
  0072f	48 83 e9 08	 sub	 rcx, 8
  00733	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00737	0f 86 f0 fc ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2879:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0073d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00743	cc		 int	 3
$LN879@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00744	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00747	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  0074b	72 03		 jb	 SHORT $LN1278@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0074d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1278@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00750	48 83 fa 01	 cmp	 rdx, 1
  00754	75 19		 jne	 SHORT $LN1286@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00756	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00759	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01JEJKBAGA@g?$AA@
  0075f	75 05		 jne	 SHORT $LN2859@Odczytaj_l
  00761	41 8b c6	 mov	 eax, r14d
  00764	eb 05		 jmp	 SHORT $LN2860@Odczytaj_l
$LN2859@Odczytaj_l:
  00766	1b c0		 sbb	 eax, eax
  00768	83 c8 01	 or	 eax, 1
$LN2860@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0076b	85 c0		 test	 eax, eax
  0076d	74 33		 je	 SHORT $LN17@Odczytaj_l
$LN1286@Odczytaj_l:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0076f	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00772	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  00776	72 03		 jb	 SHORT $LN1307@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00778	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1307@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0077b	48 83 fa 01	 cmp	 rdx, 1
  0077f	0f 85 df 01 00
	00		 jne	 $LN1315@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00785	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00788	3a 05 00 00 00
	00		 cmp	 al, BYTE PTR ??_C@_01LPLHEDKD@d?$AA@
  0078e	75 05		 jne	 SHORT $LN2857@Odczytaj_l
  00790	41 8b c6	 mov	 eax, r14d
  00793	eb 05		 jmp	 SHORT $LN2858@Odczytaj_l
$LN2857@Odczytaj_l:
  00795	1b c0		 sbb	 eax, eax
  00797	83 c8 01	 or	 eax, 1
$LN2858@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0079a	85 c0		 test	 eax, eax
  0079c	0f 85 c2 01 00
	00		 jne	 $LN1315@Odczytaj_l
$LN17@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 415  : 			if (wylosowana_liczba < 19) //Je¿eli wylosowa liczba jest mniejsza ni¿ 19

  007a2	41 83 f8 13	 cmp	 r8d, 19
  007a6	0f 8d dc 00 00
	00		 jge	 $LN18@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  007ac	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  007b4	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T175[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  007ba	c6 44 24 28 00	 mov	 BYTE PTR $T175[rsp], 0
  007bf	c7 44 24 20 87
	00 00 00	 mov	 DWORD PTR $T1[rsp], 135	; 00000087H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  007c7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  007ce	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  007d2	48 83 fa 10	 cmp	 rdx, 16
  007d6	72 16		 jb	 SHORT $LN1365@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  007d8	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T175[rsp]
  007dd	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  007e2	4c 89 74 24 38	 mov	 QWORD PTR $T175[rsp+16], r14
  007e7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1365@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007ee	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  007f6	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  007fe	48 8b d7	 mov	 rdx, rdi
  00801	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T175[rsp]
  00806	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0080b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00811	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  00818	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T175[rsp]
  0081d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00822	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T175[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00827	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T175[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  0082d	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T175[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 416  : 				PlaySound((G³os + "g.wav").c_str(), nullptr, SND_SYNC); //Powiedz, ¿e wylosowana liczba jest z górnej po³ówki

  00833	45 33 c0	 xor	 r8d, r8d
  00836	33 d2		 xor	 edx, edx
  00838	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  0083e	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0083f	48 8b 44 24 40	 mov	 rax, QWORD PTR $T175[rsp+24]
  00844	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00848	0f 82 29 07 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0084e	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00851	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T175[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00856	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0085c	0f 82 d7 fb ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00862	f6 c1 1f	 test	 cl, 31
  00865	75 1a		 jne	 SHORT $_Invalid_parameter$2880

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00867	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0086b	48 3b c1	 cmp	 rax, rcx
  0086e	73 11		 jae	 SHORT $_Invalid_parameter$2880
  00870	48 2b c8	 sub	 rcx, rax
  00873	48 83 e9 08	 sub	 rcx, 8
  00877	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0087b	0f 86 ac fb ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2880:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00881	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00887	90		 npad	 1
$LN18@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00888	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00890	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T198[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00896	c6 44 24 28 00	 mov	 BYTE PTR $T198[rsp], 0
  0089b	c7 44 24 20 07
	01 00 00	 mov	 DWORD PTR $T1[rsp], 263	; 00000107H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  008a3	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  008aa	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  008ae	48 83 fa 10	 cmp	 rdx, 16
  008b2	72 16		 jb	 SHORT $LN1554@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  008b4	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T198[rsp]
  008b9	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  008be	4c 89 74 24 38	 mov	 QWORD PTR $T198[rsp+16], r14
  008c3	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1554@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008ca	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  008d2	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  008da	48 8b d7	 mov	 rdx, rdi
  008dd	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T198[rsp]
  008e2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  008e7	41 b8 05 00 00
	00		 mov	 r8d, 5
  008ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  008f4	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T198[rsp]
  008f9	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008fe	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T198[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00903	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T198[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00909	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T198[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 418  : 				PlaySound((G³os + "d.wav").c_str(), nullptr, SND_SYNC); //W przeciwym wypadku powiedz, ¿e wylosowana liczba jest z dolnej po³ówki

  0090f	45 33 c0	 xor	 r8d, r8d
  00912	33 d2		 xor	 edx, edx
  00914	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  0091a	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0091b	48 8b 44 24 40	 mov	 rax, QWORD PTR $T198[rsp+24]
  00920	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00924	0f 82 4d 06 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0092a	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0092d	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T198[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00932	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00938	0f 82 fb fa ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0093e	f6 c1 1f	 test	 cl, 31
  00941	75 1a		 jne	 SHORT $_Invalid_parameter$2881

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00943	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00947	48 3b c1	 cmp	 rax, rcx
  0094a	73 11		 jae	 SHORT $_Invalid_parameter$2881
  0094c	48 2b c8	 sub	 rcx, rax
  0094f	48 83 e9 08	 sub	 rcx, 8
  00953	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00957	0f 86 d0 fa ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2881:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0095d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00963	cc		 int	 3
$LN1315@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00964	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00967	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  0096b	72 03		 jb	 SHORT $LN1708@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0096d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN1708@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 419  : 		else if (typ_zak³adu[0] == 'k') //Je¿eli typ zak³adu to k

  00970	80 38 6b	 cmp	 BYTE PTR [rax], 107	; 0000006bH
  00973	0f 85 5a 02 00
	00		 jne	 $LN20@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00979	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00981	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T222[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00987	c6 44 24 28 00	 mov	 BYTE PTR $T222[rsp], 0
  0098c	c7 44 24 20 07
	02 00 00	 mov	 DWORD PTR $T1[rsp], 519	; 00000207H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00994	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0099b	49 8d 50 01	 lea	 rdx, QWORD PTR [r8+1]
  0099f	48 83 fa 10	 cmp	 rdx, 16
  009a3	72 16		 jb	 SHORT $LN1758@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  009a5	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T222[rsp]
  009aa	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  009af	4c 89 74 24 38	 mov	 QWORD PTR $T222[rsp+16], r14
  009b4	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1758@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009bb	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  009c3	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  009cb	48 8b d7	 mov	 rdx, rdi
  009ce	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T222[rsp]
  009d3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009d8	41 b8 01 00 00
	00		 mov	 r8d, 1
  009de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  009e5	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T222[rsp]
  009ea	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  009ef	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  009f1	ff c9		 dec	 ecx
  009f3	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  009f8	f7 e9		 imul	 ecx
  009fa	8b c2		 mov	 eax, edx
  009fc	c1 e8 1f	 shr	 eax, 31
  009ff	03 d0		 add	 edx, eax
  00a01	8d 04 52	 lea	 eax, DWORD PTR [rdx+rdx*2]
  00a04	2b c8		 sub	 ecx, eax
  00a06	80 c1 31	 add	 cl, 49			; 00000031H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00a09	48 8b 44 24 38	 mov	 rax, QWORD PTR $T222[rsp+16]
  00a0e	4c 8b c0	 mov	 r8, rax

; 2992 : 		if (_Old_size < _My_data._Myres)

  00a11	48 8b 54 24 40	 mov	 rdx, QWORD PTR $T222[rsp+24]
  00a16	48 3b c2	 cmp	 rax, rdx
  00a19	73 23		 jae	 SHORT $LN1846@Odczytaj_l

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00a1b	48 ff c0	 inc	 rax
  00a1e	48 89 44 24 38	 mov	 QWORD PTR $T222[rsp+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a23	48 8d 44 24 28	 lea	 rax, QWORD PTR $T222[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a28	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  00a2c	48 0f 43 44 24
	28		 cmovae	 rax, QWORD PTR $T222[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00a32	42 88 0c 00	 mov	 BYTE PTR [rax+r8], cl
  00a36	42 c6 44 00 01
	00		 mov	 BYTE PTR [rax+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00a3c	eb 0e		 jmp	 SHORT $LN1845@Odczytaj_l
$LN1846@Odczytaj_l:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00a3e	44 0f b6 c9	 movzx	 r9d, cl
  00a42	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T222[rsp]
  00a47	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN1845@Odczytaj_l:

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00a4c	0f 10 44 24 28	 movups	 xmm0, XMMWORD PTR $T222[rsp]
  00a51	0f 11 44 24 68	 movups	 XMMWORD PTR $T246[rsp], xmm0
  00a56	0f 10 4c 24 38	 movups	 xmm1, XMMWORD PTR $T222[rsp+16]
  00a5b	0f 11 4c 24 78	 movups	 XMMWORD PTR $T246[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00a60	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00a68	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T222[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00a6e	c6 44 24 28 00	 mov	 BYTE PTR $T222[rsp], 0
  00a73	c7 44 24 20 07
	06 00 00	 mov	 DWORD PTR $T1[rsp], 1543 ; 00000607H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a7b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00a81	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  00a88	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T246[rsp]
  00a8d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00a92	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00a95	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T262[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00a9b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00a9e	0f 11 44 24 48	 movups	 XMMWORD PTR $T262[rsp], xmm0
  00aa3	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00aa7	0f 11 4c 24 58	 movups	 XMMWORD PTR $T262[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00aac	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ab0	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00ab8	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00abb	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T262[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ac0	48 83 7c 24 60
	10		 cmp	 QWORD PTR $T262[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00ac6	48 0f 43 4c 24
	48		 cmovae	 rcx, QWORD PTR $T262[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 420  : 			PlaySound((G³os + "k" + (char)(((wylosowana_liczba - 1) % 3) + 49) + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiej kolumny jest wylosowana liczba

  00acc	45 33 c0	 xor	 r8d, r8d
  00acf	33 d2		 xor	 edx, edx
  00ad1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ad7	48 8b 44 24 60	 mov	 rax, QWORD PTR $T262[rsp+24]
  00adc	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00ae0	72 3c		 jb	 SHORT $LN2043@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ae2	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00ae5	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T262[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00aea	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00af0	72 27		 jb	 SHORT $LN2046@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00af2	f6 c1 1f	 test	 cl, 31
  00af5	75 1b		 jne	 SHORT $_Invalid_parameter$2882

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00af7	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00afb	48 3b c1	 cmp	 rax, rcx
  00afe	73 12		 jae	 SHORT $_Invalid_parameter$2882
  00b00	48 2b c8	 sub	 rcx, rax
  00b03	48 83 e9 08	 sub	 rcx, 8
  00b07	48 83 f9 1f	 cmp	 rcx, 31
  00b0b	77 05		 ja	 SHORT $_Invalid_parameter$2882

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00b0d	48 8b c8	 mov	 rcx, rax
  00b10	eb 07		 jmp	 SHORT $LN2046@Odczytaj_l
$_Invalid_parameter$2882:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b12	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00b18	cc		 int	 3
$LN2046@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00b19	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2043@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00b1e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00b26	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T262[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00b2c	c6 44 24 48 00	 mov	 BYTE PTR $T262[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b31	48 8b 45 80	 mov	 rax, QWORD PTR $T246[rbp-232]
  00b35	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00b39	72 3c		 jb	 SHORT $LN2089@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b3b	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00b3e	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T246[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00b43	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00b49	72 27		 jb	 SHORT $LN2092@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00b4b	f6 c1 1f	 test	 cl, 31
  00b4e	75 1b		 jne	 SHORT $_Invalid_parameter$2883

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b50	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00b54	48 3b c1	 cmp	 rax, rcx
  00b57	73 12		 jae	 SHORT $_Invalid_parameter$2883
  00b59	48 2b c8	 sub	 rcx, rax
  00b5c	48 83 e9 08	 sub	 rcx, 8
  00b60	48 83 f9 1f	 cmp	 rcx, 31
  00b64	77 05		 ja	 SHORT $_Invalid_parameter$2883

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00b66	48 8b c8	 mov	 rcx, rax
  00b69	eb 07		 jmp	 SHORT $LN2092@Odczytaj_l
$_Invalid_parameter$2883:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00b71	cc		 int	 3
$LN2092@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00b72	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2089@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00b77	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00b7f	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T246[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00b85	c6 44 24 68 00	 mov	 BYTE PTR $T246[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b8a	48 8b 44 24 40	 mov	 rax, QWORD PTR $T222[rsp+24]
  00b8f	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00b93	0f 82 de 03 00
	00		 jb	 $LN808@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b99	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00b9c	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T222[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00ba1	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00ba7	0f 82 8c f8 ff
	ff		 jb	 $LN622@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00bad	f6 c1 1f	 test	 cl, 31
  00bb0	75 1a		 jne	 SHORT $_Invalid_parameter$2884

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00bb2	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00bb6	48 3b c1	 cmp	 rax, rcx
  00bb9	73 11		 jae	 SHORT $_Invalid_parameter$2884
  00bbb	48 2b c8	 sub	 rcx, rax
  00bbe	48 83 e9 08	 sub	 rcx, 8
  00bc2	48 83 f9 1f	 cmp	 rcx, 31

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00bc6	0f 86 61 f8 ff
	ff		 jbe	 $LN2871@Odczytaj_l
$_Invalid_parameter$2884:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00bcc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00bd2	cc		 int	 3
$LN20@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bd3	48 83 f9 10	 cmp	 rcx, 16

; 1607 : 		if (_Large_string_engaged())

  00bd7	72 03		 jb	 SHORT $LN2163@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00bd9	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN2163@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 421  : 		else if (typ_zak³adu[0] == 'w') //Je¿eli typ zak³adu to w

  00bdc	80 3b 77	 cmp	 BYTE PTR [rbx], 119	; 00000077H
  00bdf	0f 85 92 03 00
	00		 jne	 $LN808@Odczytaj_l
  00be5	33 d2		 xor	 edx, edx
  00be7	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  00bed	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$390[rbp-256]
  00bf1	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 593  : 		{	// construct empty character buffer

  00bf6	49 8d 87 00 00
	00 00		 lea	 rax, QWORD PTR ??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@[r15]
  00bfd	48 89 45 c0	 mov	 QWORD PTR numers$390[rbp-256], rax
  00c01	4c 89 6d d0	 mov	 QWORD PTR numers$390[rbp-240], r13
  00c05	48 8d 4d 58	 lea	 rcx, QWORD PTR numers$390[rbp-104]
  00c09	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00c0f	90		 npad	 1
  00c10	c7 44 24 20 07
	10 00 00	 mov	 DWORD PTR $T1[rsp], 4103 ; 00001007H

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  00c18	45 33 c0	 xor	 r8d, r8d
  00c1b	48 8d 55 d8	 lea	 rdx, QWORD PTR numers$390[rbp-232]
  00c1f	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$390[rbp-256]
  00c23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00c29	90		 npad	 1

; 593  : 		{	// construct empty character buffer

  00c2a	48 8b 45 c0	 mov	 rax, QWORD PTR numers$390[rbp-256]
  00c2e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00c32	4c 89 64 0d c0	 mov	 QWORD PTR numers$390[rbp+rcx-256], r12
  00c37	48 8b 45 c0	 mov	 rax, QWORD PTR numers$390[rbp-256]
  00c3b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00c3f	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00c45	89 54 0d bc	 mov	 DWORD PTR numers$390[rbp+rcx-260], edx

; 592  : 			_Stringbuffer(_Mode)

  00c49	48 8d 45 d8	 lea	 rax, QWORD PTR numers$390[rbp-232]
  00c4d	48 89 45 88	 mov	 QWORD PTR this$[rbp-256], rax

; 30   : 		{	// construct empty character buffer from mode

  00c51	48 8d 4d d8	 lea	 rcx, QWORD PTR numers$390[rbp-232]
  00c55	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00c5b	90		 npad	 1
  00c5c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00c63	48 89 45 d8	 mov	 QWORD PTR numers$390[rbp-232], rax

; 311  : 		_Seekhigh = 0;

  00c67	4c 89 75 40	 mov	 QWORD PTR numers$390[rbp-128], r14

; 312  : 		_Mystate = _State;

  00c6b	44 89 75 48	 mov	 DWORD PTR numers$390[rbp-120], r14d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 424  : 			numers << ((wylosowana_liczba - 1) / 3 + 1); //Wpisanie do typu obliczonego wiersza wylosowanej liczby

  00c6f	8b 0e		 mov	 ecx, DWORD PTR [rsi]
  00c71	ff c9		 dec	 ecx
  00c73	b8 56 55 55 55	 mov	 eax, 1431655766		; 55555556H
  00c78	f7 e9		 imul	 ecx
  00c7a	8b c2		 mov	 eax, edx
  00c7c	c1 e8 1f	 shr	 eax, 31
  00c7f	ff c2		 inc	 edx
  00c81	03 d0		 add	 edx, eax
  00c83	48 8d 4d d0	 lea	 rcx, QWORD PTR numers$390[rbp-240]
  00c87	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 425  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00c8d	48 8d 55 98	 lea	 rdx, QWORD PTR $T289[rbp-256]
  00c91	48 8d 4d c0	 lea	 rcx, QWORD PTR numers$390[rbp-256]
  00c95	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  00c9a	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00c9d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00ca5	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T291[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00cab	c6 44 24 28 00	 mov	 BYTE PTR $T291[rsp], 0
  00cb0	c7 44 24 20 07
	30 00 00	 mov	 DWORD PTR $T1[rsp], 12295 ; 00003007H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00cb8	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00cbf	49 8d 50 01	 lea	 rdx, QWORD PTR [r8+1]
  00cc3	48 83 fa 10	 cmp	 rdx, 16
  00cc7	72 16		 jb	 SHORT $LN2262@Odczytaj_l

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00cc9	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T291[rsp]
  00cce	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00cd3	4c 89 74 24 38	 mov	 QWORD PTR $T291[rsp+16], r14
  00cd8	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN2262@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cdf	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  00ce7	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00cef	48 8b d7	 mov	 rdx, rdi
  00cf2	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T291[rsp]
  00cf7	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00cfc	41 b8 01 00 00
	00		 mov	 r8d, 1
  00d02	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  00d09	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T291[rsp]
  00d0e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3062 : 		return (this->_Get_data()._Mysize);

  00d13	4c 8b 43 10	 mov	 r8, QWORD PTR [rbx+16]

; 3851 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00d17	48 8b 44 24 40	 mov	 rax, QWORD PTR $T291[rsp+24]
  00d1c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR $T291[rsp+16]
  00d21	48 2b c1	 sub	 rax, rcx
  00d24	4c 3b c0	 cmp	 r8, rax
  00d27	76 1b		 jbe	 SHORT $LN2348@Odczytaj_l

; 3092 : 		return (this->_Get_data()._Myres);

  00d29	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 3851 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00d2d	49 2b c0	 sub	 rax, r8
  00d30	48 3b c1	 cmp	 rax, rcx
  00d33	72 0f		 jb	 SHORT $LN2348@Odczytaj_l

; 3852 : 		return (_STD move(_Left.append(_Right)));
; 3853 : 	else
; 3854 : 		return (_STD move(_Right.insert(0, _Left)));

  00d35	4c 8d 44 24 28	 lea	 r8, QWORD PTR $T291[rsp]
  00d3a	48 8b cb	 mov	 rcx, rbx
  00d3d	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  00d42	eb 17		 jmp	 SHORT $LN2870@Odczytaj_l
$LN2348@Odczytaj_l:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d44	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00d49	72 03		 jb	 SHORT $LN2415@Odczytaj_l
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00d4b	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN2415@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00d4e	48 8b d3	 mov	 rdx, rbx
  00d51	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T291[rsp]
  00d56	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN2870@Odczytaj_l:
  00d5b	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00d5e	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T332[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00d64	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00d67	0f 11 44 24 48	 movups	 XMMWORD PTR $T332[rsp], xmm0
  00d6c	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00d70	0f 11 4c 24 58	 movups	 XMMWORD PTR $T332[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00d75	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00d79	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
  00d81	c7 44 24 20 07
	70 00 00	 mov	 DWORD PTR $T1[rsp], 28679 ; 00007007H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00d89	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d8c	41 b8 04 00 00
	00		 mov	 r8d, 4
  00d92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  00d99	48 8d 4c 24 48	 lea	 rcx, QWORD PTR $T332[rsp]
  00d9e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00da3	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00da6	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T361[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00dac	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00daf	0f 11 44 24 68	 movups	 XMMWORD PTR $T361[rsp], xmm0
  00db4	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00db8	0f 11 4c 24 78	 movups	 XMMWORD PTR $T361[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00dbd	4c 89 70 10	 mov	 QWORD PTR [rax+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00dc1	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00dc9	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00dcc	48 8d 4c 24 68	 lea	 rcx, QWORD PTR $T361[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00dd1	48 83 7d 80 10	 cmp	 QWORD PTR $T361[rbp-232], 16

; 1607 : 		if (_Large_string_engaged())

  00dd6	48 0f 43 4c 24
	68		 cmovae	 rcx, QWORD PTR $T361[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 425  : 			PlaySound((G³os + "w" + numers.str() + ".wav").c_str(), nullptr, SND_SYNC); //Powiedz z jakiego wiersza jest wylosowana liczba

  00ddc	45 33 c0	 xor	 r8d, r8d
  00ddf	33 d2		 xor	 edx, edx
  00de1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00de7	48 8b 45 80	 mov	 rax, QWORD PTR $T361[rbp-232]
  00deb	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00def	72 3c		 jb	 SHORT $LN2658@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00df1	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00df4	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T361[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00df9	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00dff	72 27		 jb	 SHORT $LN2661@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00e01	f6 c1 1f	 test	 cl, 31
  00e04	75 1b		 jne	 SHORT $_Invalid_parameter$2885

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e06	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00e0a	48 3b c1	 cmp	 rax, rcx
  00e0d	73 12		 jae	 SHORT $_Invalid_parameter$2885
  00e0f	48 2b c8	 sub	 rcx, rax
  00e12	48 83 e9 08	 sub	 rcx, 8
  00e16	48 83 f9 1f	 cmp	 rcx, 31
  00e1a	77 05		 ja	 SHORT $_Invalid_parameter$2885

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00e1c	48 8b c8	 mov	 rcx, rax
  00e1f	eb 07		 jmp	 SHORT $LN2661@Odczytaj_l
$_Invalid_parameter$2885:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00e21	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00e27	cc		 int	 3
$LN2661@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00e28	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2658@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00e2d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00e35	f3 0f 7f 44 24
	78		 movdqu	 XMMWORD PTR $T361[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00e3b	c6 44 24 68 00	 mov	 BYTE PTR $T361[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e40	48 8b 44 24 60	 mov	 rax, QWORD PTR $T332[rsp+24]
  00e45	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00e49	72 3c		 jb	 SHORT $LN2704@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00e4b	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00e4e	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T332[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00e53	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00e59	72 27		 jb	 SHORT $LN2707@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00e5b	f6 c1 1f	 test	 cl, 31
  00e5e	75 1b		 jne	 SHORT $_Invalid_parameter$2886

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00e60	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00e64	48 3b c1	 cmp	 rax, rcx
  00e67	73 12		 jae	 SHORT $_Invalid_parameter$2886
  00e69	48 2b c8	 sub	 rcx, rax
  00e6c	48 83 e9 08	 sub	 rcx, 8
  00e70	48 83 f9 1f	 cmp	 rcx, 31
  00e74	77 05		 ja	 SHORT $_Invalid_parameter$2886

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00e76	48 8b c8	 mov	 rcx, rax
  00e79	eb 07		 jmp	 SHORT $LN2707@Odczytaj_l
$_Invalid_parameter$2886:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00e7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00e81	cc		 int	 3
$LN2707@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00e82	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2704@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00e87	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00e8f	f3 0f 7f 44 24
	58		 movdqu	 XMMWORD PTR $T332[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00e95	c6 44 24 48 00	 mov	 BYTE PTR $T332[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e9a	48 8b 44 24 40	 mov	 rax, QWORD PTR $T291[rsp+24]
  00e9f	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00ea3	72 3c		 jb	 SHORT $LN2750@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00ea5	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00ea8	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T291[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00ead	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00eb3	72 27		 jb	 SHORT $LN2753@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00eb5	f6 c1 1f	 test	 cl, 31
  00eb8	75 1b		 jne	 SHORT $_Invalid_parameter$2887

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00eba	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00ebe	48 3b c1	 cmp	 rax, rcx
  00ec1	73 12		 jae	 SHORT $_Invalid_parameter$2887
  00ec3	48 2b c8	 sub	 rcx, rax
  00ec6	48 83 e9 08	 sub	 rcx, 8
  00eca	48 83 f9 1f	 cmp	 rcx, 31
  00ece	77 05		 ja	 SHORT $_Invalid_parameter$2887

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00ed0	48 8b c8	 mov	 rcx, rax
  00ed3	eb 07		 jmp	 SHORT $LN2753@Odczytaj_l
$_Invalid_parameter$2887:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ed5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00edb	cc		 int	 3
$LN2753@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00edc	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2750@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00ee1	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00ee9	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T291[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00eef	c6 44 24 28 00	 mov	 BYTE PTR $T291[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ef4	48 8b 45 b0	 mov	 rax, QWORD PTR $T289[rbp-232]
  00ef8	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00efc	72 3c		 jb	 SHORT $LN2796@Odczytaj_l

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00efe	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00f01	48 8b 4d 98	 mov	 rcx, QWORD PTR $T289[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00f05	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00f0b	72 27		 jb	 SHORT $LN2799@Odczytaj_l

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00f0d	f6 c1 1f	 test	 cl, 31
  00f10	75 1b		 jne	 SHORT $_Invalid_parameter$2888

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f12	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00f16	48 3b c1	 cmp	 rax, rcx
  00f19	73 12		 jae	 SHORT $_Invalid_parameter$2888
  00f1b	48 2b c8	 sub	 rcx, rax
  00f1e	48 83 e9 08	 sub	 rcx, 8
  00f22	48 83 f9 1f	 cmp	 rcx, 31
  00f26	77 05		 ja	 SHORT $_Invalid_parameter$2888

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00f28	48 8b c8	 mov	 rcx, rax
  00f2b	eb 07		 jmp	 SHORT $LN2799@Odczytaj_l
$_Invalid_parameter$2888:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f2d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00f33	cc		 int	 3
$LN2799@Odczytaj_l:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00f34	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00f39	90		 npad	 1
$LN2796@Odczytaj_l:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 637  : 		{	// destroy the object

  00f3a	48 8b 45 c0	 mov	 rax, QWORD PTR numers$390[rbp-256]
  00f3e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00f42	4c 89 64 0d c0	 mov	 QWORD PTR numers$390[rbp+rcx-256], r12
  00f47	48 8b 45 c0	 mov	 rax, QWORD PTR numers$390[rbp-256]
  00f4b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00f4f	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00f55	89 54 0d bc	 mov	 DWORD PTR numers$390[rbp+rcx-260], edx

; 638  : 		}

  00f59	48 8d 4d d8	 lea	 rcx, QWORD PTR numers$390[rbp-232]
  00f5d	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00f62	48 8d 4d e0	 lea	 rcx, QWORD PTR numers$390[rbp-224]
  00f66	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00f6c	48 8d 4d 58	 lea	 rcx, QWORD PTR numers$390[rbp-104]
  00f70	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00f76	90		 npad	 1
$LN808@Odczytaj_l:

; 637  : 		{	// destroy the object

  00f77	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  00f7e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00f82	4c 89 a4 0d c0
	00 00 00	 mov	 QWORD PTR numers$[rbp+rcx-256], r12
  00f8a	48 8b 85 c0 00
	00 00		 mov	 rax, QWORD PTR numers$[rbp-256]
  00f91	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00f95	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00f9b	89 94 0d bc 00
	00 00		 mov	 DWORD PTR numers$[rbp+rcx-260], edx

; 638  : 		}

  00fa2	48 8d 8d d8 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-232]
  00fa9	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00fae	48 8d 8d e0 00
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-224]
  00fb5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00fbb	48 8d 8d 58 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp-104]
  00fc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN3@Odczytaj_l:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 427  : }

  00fc8	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00fcf	48 33 cc	 xor	 rcx, rsp
  00fd2	e8 00 00 00 00	 call	 __security_check_cookie
  00fd7	4c 8d 9c 24 d0
	02 00 00	 lea	 r11, QWORD PTR [rsp+720]
  00fdf	49 8b 5b 38	 mov	 rbx, QWORD PTR [r11+56]
  00fe3	49 8b 73 40	 mov	 rsi, QWORD PTR [r11+64]
  00fe7	49 8b 7b 48	 mov	 rdi, QWORD PTR [r11+72]
  00feb	49 8b e3	 mov	 rsp, r11
  00fee	41 5f		 pop	 r15
  00ff0	41 5e		 pop	 r14
  00ff2	41 5d		 pop	 r13
  00ff4	41 5c		 pop	 r12
  00ff6	5d		 pop	 rbp
  00ff7	c3		 ret	 0
$LN2869@Odczytaj_l:
?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Odczytaj_liczbê
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$19
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 18		 je	 SHORT $LN49@dtor$19
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp]
  0001e	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN49@dtor$19:
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$19
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$20
  00031	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00038	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0003c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$20
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$22
  00043	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$22
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$0
  00051	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00058	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$0
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$1
  0005d	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$1
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$2
  00069	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T13[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$2
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$98
  00075	40 55		 push	 rbp
  00077	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0007b	48 8b ea	 mov	 rbp, rdx
  0007e	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00081	83 e0 08	 and	 eax, 8
  00084	85 c0		 test	 eax, eax
  00086	74 0d		 je	 SHORT $LN452@dtor$98
  00088	83 65 20 f7	 and	 DWORD PTR $T1[rbp], -9
  0008c	48 8d 4d 28	 lea	 rcx, QWORD PTR $T63[rbp]
  00090	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN452@dtor$98:
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$98
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$130
  0009b	40 55		 push	 rbp
  0009d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a1	48 8b ea	 mov	 rbp, rdx
  000a4	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000a7	83 e0 10	 and	 eax, 16
  000aa	85 c0		 test	 eax, eax
  000ac	74 0d		 je	 SHORT $LN641@dtor$130
  000ae	83 65 20 ef	 and	 DWORD PTR $T1[rbp], -17
  000b2	48 8d 4d 28	 lea	 rcx, QWORD PTR $T86[rbp]
  000b6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN641@dtor$130:
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$130
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$174
  000c1	40 55		 push	 rbp
  000c3	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c7	48 8b ea	 mov	 rbp, rdx
  000ca	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000cd	83 e0 20	 and	 eax, 32			; 00000020H
  000d0	85 c0		 test	 eax, eax
  000d2	74 0d		 je	 SHORT $LN888@dtor$174
  000d4	83 65 20 df	 and	 DWORD PTR $T1[rbp], -33	; ffffffffffffffdfH
  000d8	48 8d 4d 28	 lea	 rcx, QWORD PTR $T119[rbp]
  000dc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN888@dtor$174:
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5d		 pop	 rbp
  000e6	c3		 ret	 0
?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$174
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$206
  000e7	40 55		 push	 rbp
  000e9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000ed	48 8b ea	 mov	 rbp, rdx
  000f0	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000f3	83 e0 40	 and	 eax, 64			; 00000040H
  000f6	85 c0		 test	 eax, eax
  000f8	74 0d		 je	 SHORT $LN1077@dtor$206
  000fa	83 65 20 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000fe	48 8d 4d 28	 lea	 rcx, QWORD PTR $T142[rbp]
  00102	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1077@dtor$206:
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$206
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$250
  0010d	40 55		 push	 rbp
  0010f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00113	48 8b ea	 mov	 rbp, rdx
  00116	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00119	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN1324@dtor$250
  00122	81 65 20 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  00129	48 8d 4d 28	 lea	 rcx, QWORD PTR $T175[rbp]
  0012d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1324@dtor$250:
  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$250
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$282
  00138	40 55		 push	 rbp
  0013a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0013e	48 8b ea	 mov	 rbp, rdx
  00141	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00144	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00149	85 c0		 test	 eax, eax
  0014b	74 10		 je	 SHORT $LN1513@dtor$282
  0014d	81 65 20 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00154	48 8d 4d 28	 lea	 rcx, QWORD PTR $T198[rbp]
  00158	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1513@dtor$282:
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	5d		 pop	 rbp
  00162	c3		 ret	 0
?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$282
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$316
  00163	40 55		 push	 rbp
  00165	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00169	48 8b ea	 mov	 rbp, rdx
  0016c	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0016f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00174	85 c0		 test	 eax, eax
  00176	74 10		 je	 SHORT $LN1717@dtor$316
  00178	81 65 20 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0017f	48 8d 4d 28	 lea	 rcx, QWORD PTR $T222[rbp]
  00183	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1717@dtor$316:
  00188	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018c	5d		 pop	 rbp
  0018d	c3		 ret	 0
?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$316
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$11
  0018e	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T246[rdx]
  00195	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$11
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$406
  0019a	40 55		 push	 rbp
  0019c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a0	48 8b ea	 mov	 rbp, rdx
  001a3	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  001a6	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  001ab	85 c0		 test	 eax, eax
  001ad	74 1b		 je	 SHORT $LN2176@dtor$406
  001af	81 65 20 ff ef
	ff ff		 and	 DWORD PTR $T1[rbp], -4097 ; ffffffffffffefffH
  001b6	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rbp]
  001bd	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN2176@dtor$406:
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5d		 pop	 rbp
  001cf	c3		 ret	 0
?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$406
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$407@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$407
  001d0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rdx]
  001d7	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001db	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$407@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$407
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$409@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$409
  001e2	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  001e9	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$409@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$409
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$13
  001f0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rdx]
  001f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$13
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$14
  001fc	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T289[rdx]
  00203	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$14
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$412
  00208	40 55		 push	 rbp
  0020a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020e	48 8b ea	 mov	 rbp, rdx
  00211	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00214	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00219	85 c0		 test	 eax, eax
  0021b	74 10		 je	 SHORT $LN2221@dtor$412
  0021d	81 65 20 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00224	48 8d 4d 28	 lea	 rcx, QWORD PTR $T291[rbp]
  00228	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2221@dtor$412:
  0022d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00231	5d		 pop	 rbp
  00232	c3		 ret	 0
?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$412
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$16
  00233	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T332[rdx]
  0023a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$19
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 18		 je	 SHORT $LN49@dtor$19
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 8d c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rbp]
  0001e	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00025	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN49@dtor$19:
  0002b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002f	5d		 pop	 rbp
  00030	c3		 ret	 0
?dtor$19@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$19
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$20
  00031	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00038	48 83 c1 20	 add	 rcx, 32			; 00000020H
  0003c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$20@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$22
  00043	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  0004a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$22@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$0
  00051	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$[rdx]
  00058	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$0@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$1
  0005d	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T6[rdx]
  00064	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$2
  00069	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T13[rdx]
  00070	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$98
  00075	40 55		 push	 rbp
  00077	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0007b	48 8b ea	 mov	 rbp, rdx
  0007e	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00081	83 e0 08	 and	 eax, 8
  00084	85 c0		 test	 eax, eax
  00086	74 0d		 je	 SHORT $LN452@dtor$98
  00088	83 65 20 f7	 and	 DWORD PTR $T1[rbp], -9
  0008c	48 8d 4d 28	 lea	 rcx, QWORD PTR $T63[rbp]
  00090	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN452@dtor$98:
  00095	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00099	5d		 pop	 rbp
  0009a	c3		 ret	 0
?dtor$98@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$98
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$130
  0009b	40 55		 push	 rbp
  0009d	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000a1	48 8b ea	 mov	 rbp, rdx
  000a4	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000a7	83 e0 10	 and	 eax, 16
  000aa	85 c0		 test	 eax, eax
  000ac	74 0d		 je	 SHORT $LN641@dtor$130
  000ae	83 65 20 ef	 and	 DWORD PTR $T1[rbp], -17
  000b2	48 8d 4d 28	 lea	 rcx, QWORD PTR $T86[rbp]
  000b6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN641@dtor$130:
  000bb	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bf	5d		 pop	 rbp
  000c0	c3		 ret	 0
?dtor$130@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$130
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$174
  000c1	40 55		 push	 rbp
  000c3	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000c7	48 8b ea	 mov	 rbp, rdx
  000ca	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000cd	83 e0 20	 and	 eax, 32			; 00000020H
  000d0	85 c0		 test	 eax, eax
  000d2	74 0d		 je	 SHORT $LN888@dtor$174
  000d4	83 65 20 df	 and	 DWORD PTR $T1[rbp], -33	; ffffffffffffffdfH
  000d8	48 8d 4d 28	 lea	 rcx, QWORD PTR $T119[rbp]
  000dc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN888@dtor$174:
  000e1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e5	5d		 pop	 rbp
  000e6	c3		 ret	 0
?dtor$174@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$174
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$206
  000e7	40 55		 push	 rbp
  000e9	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000ed	48 8b ea	 mov	 rbp, rdx
  000f0	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  000f3	83 e0 40	 and	 eax, 64			; 00000040H
  000f6	85 c0		 test	 eax, eax
  000f8	74 0d		 je	 SHORT $LN1077@dtor$206
  000fa	83 65 20 bf	 and	 DWORD PTR $T1[rbp], -65	; ffffffffffffffbfH
  000fe	48 8d 4d 28	 lea	 rcx, QWORD PTR $T142[rbp]
  00102	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1077@dtor$206:
  00107	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010b	5d		 pop	 rbp
  0010c	c3		 ret	 0
?dtor$206@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$206
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$250
  0010d	40 55		 push	 rbp
  0010f	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00113	48 8b ea	 mov	 rbp, rdx
  00116	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00119	25 80 00 00 00	 and	 eax, 128		; 00000080H
  0011e	85 c0		 test	 eax, eax
  00120	74 10		 je	 SHORT $LN1324@dtor$250
  00122	81 65 20 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  00129	48 8d 4d 28	 lea	 rcx, QWORD PTR $T175[rbp]
  0012d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1324@dtor$250:
  00132	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00136	5d		 pop	 rbp
  00137	c3		 ret	 0
?dtor$250@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$250
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$282
  00138	40 55		 push	 rbp
  0013a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0013e	48 8b ea	 mov	 rbp, rdx
  00141	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00144	25 00 01 00 00	 and	 eax, 256		; 00000100H
  00149	85 c0		 test	 eax, eax
  0014b	74 10		 je	 SHORT $LN1513@dtor$282
  0014d	81 65 20 ff fe
	ff ff		 and	 DWORD PTR $T1[rbp], -257 ; fffffffffffffeffH
  00154	48 8d 4d 28	 lea	 rcx, QWORD PTR $T198[rbp]
  00158	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1513@dtor$282:
  0015d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00161	5d		 pop	 rbp
  00162	c3		 ret	 0
?dtor$282@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$282
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$316
  00163	40 55		 push	 rbp
  00165	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00169	48 8b ea	 mov	 rbp, rdx
  0016c	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0016f	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00174	85 c0		 test	 eax, eax
  00176	74 10		 je	 SHORT $LN1717@dtor$316
  00178	81 65 20 ff fd
	ff ff		 and	 DWORD PTR $T1[rbp], -513 ; fffffffffffffdffH
  0017f	48 8d 4d 28	 lea	 rcx, QWORD PTR $T222[rbp]
  00183	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1717@dtor$316:
  00188	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0018c	5d		 pop	 rbp
  0018d	c3		 ret	 0
?dtor$316@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$316
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$11
  0018e	48 8d 8a 68 00
	00 00		 lea	 rcx, QWORD PTR $T246[rdx]
  00195	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$406
  0019a	40 55		 push	 rbp
  0019c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  001a0	48 8b ea	 mov	 rbp, rdx
  001a3	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  001a6	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  001ab	85 c0		 test	 eax, eax
  001ad	74 1b		 je	 SHORT $LN2176@dtor$406
  001af	81 65 20 ff ef
	ff ff		 and	 DWORD PTR $T1[rbp], -4097 ; ffffffffffffefffH
  001b6	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rbp]
  001bd	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  001c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN2176@dtor$406:
  001ca	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001ce	5d		 pop	 rbp
  001cf	c3		 ret	 0
?dtor$406@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$406
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$407@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$407
  001d0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rdx]
  001d7	48 83 c1 20	 add	 rcx, 32			; 00000020H
  001db	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$407@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$407
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$409@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$409
  001e2	48 8b 8a 88 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  001e9	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$409@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$409
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$13
  001f0	48 8d 8a c0 00
	00 00		 lea	 rcx, QWORD PTR numers$390[rdx]
  001f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$13@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$13
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$14
  001fc	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T289[rdx]
  00203	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$14@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$14
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$412
  00208	40 55		 push	 rbp
  0020a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0020e	48 8b ea	 mov	 rbp, rdx
  00211	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  00214	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  00219	85 c0		 test	 eax, eax
  0021b	74 10		 je	 SHORT $LN2221@dtor$412
  0021d	81 65 20 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00224	48 8d 4d 28	 lea	 rcx, QWORD PTR $T291[rbp]
  00228	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2221@dtor$412:
  0022d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00231	5d		 pop	 rbp
  00232	c3		 ret	 0
?dtor$412@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$412
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T291 = 40
$T222 = 40
$T198 = 40
$T175 = 40
$T142 = 40
$T119 = 40
$T86 = 40
$T63 = 40
$T6 = 40
$T332 = 72
$T262 = 72
$T29 = 72
$T361 = 104
$T246 = 104
$T13 = 104
this$ = 136
this$ = 136
$T389 = 144
$T289 = 152
numers$390 = 192
numers$ = 448
__$ArrayPad$ = 704
wylosowana_liczba$ = 768
typ_zak³adu$ = 776
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA PROC ; `Odczytaj_liczbê'::`1'::dtor$16
  00233	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR $T332[rdx]
  0023a	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z@4HA ENDP ; `Odczytaj_liczbê'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor', COMDAT
$LN7:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 637  : 		{	// destroy the object

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8d 99 98 00
	00 00		 lea	 rbx, QWORD PTR [rcx+152]

; 638  : 		}

  00010	48 8d 4b 80	 lea	 rcx, QWORD PTR [rbx-128]
  00014	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00018	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001f	48 89 84 1a 68
	ff ff ff	 mov	 QWORD PTR [rdx+rbx-152], rax
  00027	48 8b 83 68 ff
	ff ff		 mov	 rax, QWORD PTR [rbx-152]
  0002e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00032	44 8d 82 68 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-152]
  00039	44 89 84 1a 64
	ff ff ff	 mov	 DWORD PTR [rdx+rbx-156], r8d
  00041	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00046	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00050	48 8b cb	 mov	 rcx, rbx
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 f8 00 00
	00		 mov	 r8d, 248		; 000000f8H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z
_TEXT	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z PROC ; Wczytaj_z_pliku, COMDAT

; 430  : {

$LN2936:
  00000	40 55		 push	 rbp
  00002	53		 push	 rbx
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 8d 6c 24 f9	 lea	 rbp, QWORD PTR [rsp-7]
  00012	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H
  00019	48 c7 45 87 fe
	ff ff ff	 mov	 QWORD PTR $T410[rbp-177], -2
  00021	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00028	48 33 c4	 xor	 rax, rsp
  0002b	48 89 45 ef	 mov	 QWORD PTR __$ArrayPad$[rbp-177], rax
  0002f	4c 89 4c 24 20	 mov	 QWORD PTR iloœæ_pieniêdzy$GSCopy$1$[rsp], r9
  00034	4d 8b f8	 mov	 r15, r8
  00037	4c 8b f2	 mov	 r14, rdx
  0003a	48 8b d9	 mov	 rbx, rcx
  0003d	48 8b 45 6f	 mov	 rax, QWORD PTR kwota_zak³adu$[rbp-177]
  00041	48 89 44 24 30	 mov	 QWORD PTR kwota_zak³adu$GSCopy$1$[rsp], rax
  00046	4c 8b 65 77	 mov	 r12, QWORD PTR wylosowana_liczba$[rbp-177]
  0004a	4c 8b 6d 7f	 mov	 r13, QWORD PTR typ_zak³adu$[rbp-177]

; 431  : 	if (!czy_kontynuowaæ_grê) //Je¿eli czy_kontynuowaæ_grê == 0

  0004e	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, 0 ; czy_kontynuowaæ_grê
  00056	75 5c		 jne	 SHORT $LN31@Wczytaj_z_

; 432  : 		if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  00058	33 d2		 xor	 edx, edx
  0005a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00067	85 c0		 test	 eax, eax
  00069	75 49		 jne	 SHORT $LN31@Wczytaj_z_

; 433  : 		{
; 434  : 			co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  0006b	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH

; 435  : 			remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ rozpoczyna siê now¹ grê

  0006f	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_remove

; 436  : 			log_ogólny << endl << "Uruchomiono ponownie grê z wy³¹czon¹ opcj¹ kontynuowania" << endl; //Wpisanie do buforu logu ogólnego informacje o rozpoczêciu nowej gry spowodowane ustawieniem gry

  0007c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00083	48 8b cb	 mov	 rcx, rbx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  0008c	48 8b c8	 mov	 rcx, rax
  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@EFIKGJBI@Uruchomiono?5ponownie?5gr?j?5z?5wy?$LD?$LJc@
  00096	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0009b	48 8b c8	 mov	 rcx, rax
  0009e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 437  : 			log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000ab	48 8b cb	 mov	 rcx, rbx
  000ae	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN31@Wczytaj_z_:

; 440  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000b4	33 d2		 xor	 edx, edx
  000b6	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  000bd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000c3	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  000c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 440  : 	if (!_access("log_aktualny.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  000ce	85 c0		 test	 eax, eax
  000d0	0f 85 7f 16 00
	00		 jne	 $LN32@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000d6	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  000da	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1360 : 			_Myios::setstate(ios_base::failbit);

  000df	45 33 c0	 xor	 r8d, r8d

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000e2	48 85 c0	 test	 rax, rax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  000e5	49 8b 06	 mov	 rax, QWORD PTR [r14]
  000e8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  000ec	75 0f		 jne	 SHORT $LN74@Wczytaj_z_

; 1360 : 			_Myios::setstate(ios_base::failbit);

  000ee	49 03 ce	 add	 rcx, r14
  000f1	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  000f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1361 : 		else

  000fb	eb 0b		 jmp	 SHORT $LN75@Wczytaj_z_
$LN74@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  000fd	49 03 ce	 add	 rcx, r14
  00100	33 d2		 xor	 edx, edx
  00102	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN75@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00108	33 c0		 xor	 eax, eax
  0010a	48 89 45 bf	 mov	 QWORD PTR buf$415[rbp-161], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0010e	48 c7 45 c7 0f
	00 00 00	 mov	 QWORD PTR buf$415[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00116	88 45 af	 mov	 BYTE PTR buf$415[rbp-177], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00119	48 89 45 df	 mov	 QWORD PTR bufor2$416[rbp-161], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0011d	48 c7 45 e7 0f
	00 00 00	 mov	 QWORD PTR bufor2$416[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00125	88 45 cf	 mov	 BYTE PTR bufor2$416[rbp-177], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00128	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0012b	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012f	49 03 ce	 add	 rcx, r14
  00132	b2 0a		 mov	 dl, 10
  00134	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0013a	44 0f b6 c0	 movzx	 r8d, al
  0013e	48 8d 55 af	 lea	 rdx, QWORD PTR buf$415[rbp-177]
  00142	49 8b ce	 mov	 rcx, r14
  00145	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  0014a	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0014d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00151	42 f6 44 31 10
	01		 test	 BYTE PTR [rcx+r14+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  00157	0f 85 94 00 00
	00		 jne	 $LN3@Wczytaj_z_
  0015d	0f 1f 00	 npad	 3
$LL2@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1607 : 		if (_Large_string_engaged())

  00160	48 8b 4d af	 mov	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00164	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$415[rbp-153]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00168	48 8b 7d bf	 mov	 rdi, QWORD PTR buf$415[rbp-161]
  0016c	48 85 ff	 test	 rdi, rdi
  0016f	75 04		 jne	 SHORT $LN157@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00171	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00173	74 47		 je	 SHORT $LN189@Wczytaj_z_
$LN157@Wczytaj_z_:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00175	4c 8d 4d af	 lea	 r9, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00179	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  0017d	4c 0f 43 c9	 cmovae	 r9, rcx

; 2435 : 		if (_Count <= _My_data._Myres)

  00181	48 8b 45 e7	 mov	 rax, QWORD PTR bufor2$416[rbp-153]
  00185	48 3b f8	 cmp	 rdi, rax
  00188	77 26		 ja	 SHORT $LN190@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  0018a	48 8d 5d cf	 lea	 rbx, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0018e	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00192	48 0f 43 5d cf	 cmovae	 rbx, QWORD PTR bufor2$416[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  00197	48 89 7d df	 mov	 QWORD PTR bufor2$416[rbp-161], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0019b	4c 8b c7	 mov	 r8, rdi
  0019e	49 8b d1	 mov	 rdx, r9
  001a1	48 8b cb	 mov	 rcx, rbx
  001a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  001aa	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  001ae	eb 0c		 jmp	 SHORT $LN189@Wczytaj_z_
$LN190@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  001b0	48 8b d7	 mov	 rdx, rdi
  001b3	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$416[rbp-177]
  001b7	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN189@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  001bc	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001bf	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  001c3	49 03 ce	 add	 rcx, r14
  001c6	b2 0a		 mov	 dl, 10
  001c8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  001ce	44 0f b6 c0	 movzx	 r8d, al
  001d2	48 8d 55 af	 lea	 rdx, QWORD PTR buf$415[rbp-177]
  001d6	49 8b ce	 mov	 rcx, r14
  001d9	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001de	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001e1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001e5	42 f6 44 31 10
	01		 test	 BYTE PTR [rcx+r14+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 445  : 		while (!log.eof()) //Pêtla dzia³j¹ca do czasu kiedy kursor odczytu z pliku nie bêdzie na koñcu pliku

  001eb	0f 84 6f ff ff
	ff		 je	 $LL2@Wczytaj_z_
$LN3@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1607 : 		if (_Large_string_engaged())

  001f1	48 8b 55 af	 mov	 rdx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001f5	48 8b 4d c7	 mov	 rcx, QWORD PTR buf$415[rbp-153]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  001f9	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
  001fd	48 85 c0	 test	 rax, rax
  00200	75 51		 jne	 SHORT $LN271@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00202	45 33 c0	 xor	 r8d, r8d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00205	75 4c		 jne	 SHORT $LN271@Wczytaj_z_

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00207	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0020b	48 83 7d e7 10	 cmp	 QWORD PTR bufor2$416[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00210	4c 0f 43 4d cf	 cmovae	 r9, QWORD PTR bufor2$416[rbp-177]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00215	48 8b 7d df	 mov	 rdi, QWORD PTR bufor2$416[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  00219	48 3b f9	 cmp	 rdi, rcx
  0021c	77 25		 ja	 SHORT $LN272@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  0021e	48 8d 5d af	 lea	 rbx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00222	48 83 f9 10	 cmp	 rcx, 16

; 1596 : 		if (_Large_string_engaged())

  00226	48 0f 43 da	 cmovae	 rbx, rdx

; 2438 : 			_My_data._Mysize = _Count;

  0022a	48 89 7d bf	 mov	 QWORD PTR buf$415[rbp-161], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0022e	4c 8b c7	 mov	 r8, rdi
  00231	49 8b d1	 mov	 rdx, r9
  00234	48 8b cb	 mov	 rcx, rbx
  00237	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0023d	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  00241	eb 0c		 jmp	 SHORT $LN2933@Wczytaj_z_
$LN272@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00243	48 8b d7	 mov	 rdx, rdi
  00246	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]
  0024a	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN2933@Wczytaj_z_:
  0024f	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
$LN271@Wczytaj_z_:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00253	48 8d 7d af	 lea	 rdi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00257	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  0025c	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00261	48 83 f8 09	 cmp	 rax, 9
  00265	0f 82 42 02 00
	00		 jb	 $LN36@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0026b	48 8d 34 07	 lea	 rsi, QWORD PTR [rdi+rax]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0026f	4c 8d 46 f8	 lea	 r8, QWORD PTR [rsi-8]
  00273	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00276	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  0027b	48 8b cf	 mov	 rcx, rdi
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00284	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00287	48 85 c0	 test	 rax, rax
  0028a	0f 84 19 02 00
	00		 je	 $LN2913@Wczytaj_z_
$LL315@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00290	41 b8 09 00 00
	00		 mov	 r8d, 9
  00296	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_09LFKNBKJA@Posiadasz?$AA@
  0029d	48 8b cb	 mov	 rcx, rbx
  002a0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  002a5	85 c0		 test	 eax, eax
  002a7	74 25		 je	 SHORT $LN2732@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  002a9	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002ac	4c 8d 46 f8	 lea	 r8, QWORD PTR [rsi-8]
  002b0	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  002b3	ba 50 00 00 00	 mov	 edx, 80			; 00000050H
  002b8	48 8b cb	 mov	 rcx, rbx
  002bb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  002c1	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  002c4	48 85 c0	 test	 rax, rax
  002c7	75 c7		 jne	 SHORT $LL315@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  002c9	e9 db 01 00 00	 jmp	 $LN2913@Wczytaj_z_
$LN2732@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  002ce	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o skoñczeniu rundy

  002d1	48 83 fb ff	 cmp	 rbx, -1
  002d5	0f 84 ce 01 00
	00		 je	 $LN2913@Wczytaj_z_

; 452  : 		{
; 453  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku

  002db	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH

; 454  : 			auto pocz¹tek = (unsigned short)buf.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst pozycji ostatniego znaku tekstu o kwocie pieniêdzy któr¹ posiada jeszcze gracz, typ zmiennej auto wsazuje, ¿e kompilator sam wybierze typ zmiennej

  002df	0f b7 5d bf	 movzx	 ebx, WORD PTR buf$415[rbp-161]
  002e3	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  002e8	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$415[rbp-153]
  002ec	4c 8b 4d af	 mov	 r9, QWORD PTR buf$415[rbp-177]
$LL4@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  002f0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002f4	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  002f8	49 0f 43 c9	 cmovae	 rcx, r9
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 455  : 			while (buf[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  002fc	0f b7 c3	 movzx	 eax, bx
  002ff	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  00303	74 0a		 je	 SHORT $LN5@Wczytaj_z_
  00305	66 85 db	 test	 bx, bx
  00308	74 05		 je	 SHORT $LN5@Wczytaj_z_
  0030a	66 03 da	 add	 bx, dx
  0030d	eb e1		 jmp	 SHORT $LL4@Wczytaj_z_
$LN5@Wczytaj_z_:

; 456  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  0030f	66 ff c3	 inc	 bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00312	45 33 e4	 xor	 r12d, r12d
  00315	4c 89 65 9f	 mov	 QWORD PTR buf2$414[rbp-161], r12

; 1577 : 		_Myres(0)

  00319	4c 89 65 a7	 mov	 QWORD PTR buf2$414[rbp-153], r12

; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  0031d	48 8b 7d bf	 mov	 rdi, QWORD PTR buf$415[rbp-161]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00321	4c 8d 7d af	 lea	 r15, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00325	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00329	4d 0f 43 f9	 cmovae	 r15, r9

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  0032d	48 83 ff 10	 cmp	 rdi, 16
  00331	73 12		 jae	 SHORT $LN376@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00333	41 0f 10 07	 movups	 xmm0, XMMWORD PTR [r15]
  00337	0f 11 45 8f	 movups	 XMMWORD PTR buf2$414[rbp-177], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2192 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  0033b	41 8d 74 24 0f	 lea	 esi, QWORD PTR [r12+15]

; 2193 : 			return;

  00340	e9 79 00 00 00	 jmp	 $LN2934@Wczytaj_z_
$LN376@Wczytaj_z_:

; 2194 : 			}
; 2195 : 
; 2196 : 		auto& _Al = this->_Getal();
; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00345	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0034f	48 8b f7	 mov	 rsi, rdi
  00352	48 83 ce 0f	 or	 rsi, 15
  00356	48 3b f0	 cmp	 rsi, rax
  00359	48 0f 47 f0	 cmova	 rsi, rax

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  0035d	48 8d 4e 01	 lea	 rcx, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  00361	48 85 c9	 test	 rcx, rcx
  00364	75 05		 jne	 SHORT $LN433@Wczytaj_z_

; 53   : 		{
; 54   : 		return (_Ptr);

  00366	49 8b cc	 mov	 rcx, r12
  00369	eb 43		 jmp	 SHORT $LN432@Wczytaj_z_
$LN433@Wczytaj_z_:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0036b	45 84 e4	 test	 r12b, r12b
  0036e	74 07		 je	 SHORT $LN434@Wczytaj_z_

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00370	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00376	cc		 int	 3
$LN434@Wczytaj_z_:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00377	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0037e	72 26		 jb	 SHORT $LN435@Wczytaj_z_

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00380	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  00384	48 3b c1	 cmp	 rax, rcx
  00387	77 07		 ja	 SHORT $LN436@Wczytaj_z_

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00389	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0038f	cc		 int	 3
$LN436@Wczytaj_z_:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00390	48 8b c8	 mov	 rcx, rax
  00393	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00398	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0039c	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  003a0	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  003a4	eb 08		 jmp	 SHORT $LN432@Wczytaj_z_
$LN435@Wczytaj_z_:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  003a6	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  003ab	48 8b c8	 mov	 rcx, rax
$LN432@Wczytaj_z_:

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  003ae	48 89 4d 8f	 mov	 QWORD PTR buf2$414[rbp-177], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  003b2	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  003b6	49 8b d7	 mov	 rdx, r15
  003b9	e8 00 00 00 00	 call	 memcpy
$LN2934@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  003be	48 89 75 a7	 mov	 QWORD PTR buf2$414[rbp-153], rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 458  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  003c2	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  003c5	48 3b f8	 cmp	 rdi, rax
  003c8	48 0f 42 c7	 cmovb	 rax, rdi

; 1595 : 		value_type * _Result = _Bx._Buf;

  003cc	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  003d0	48 83 fe 10	 cmp	 rsi, 16

; 1596 : 		if (_Large_string_engaged())

  003d4	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  003d9	48 2b f8	 sub	 rdi, rax

; 2622 : 		_My_data._Mysize = _New_size;

  003dc	48 89 7d 9f	 mov	 QWORD PTR buf2$414[rbp-161], rdi

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  003e0	4c 8d 47 01	 lea	 r8, QWORD PTR [rdi+1]
  003e4	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  003e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 459  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  003ee	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$414[rbp-161]
  003f2	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  003f6	4c 3b c2	 cmp	 r8, rdx
  003f9	73 06		 jae	 SHORT $LN505@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  003fb	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00400	cc		 int	 3
$LN505@Wczytaj_z_:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00401	49 8b c0	 mov	 rax, r8
  00404	48 2b c2	 sub	 rax, rdx
  00407	48 83 f8 01	 cmp	 rax, 1
  0040b	41 b9 01 00 00
	00		 mov	 r9d, 1
  00411	4c 0f 42 c8	 cmovb	 r9, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00415	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00419	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  0041e	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00423	48 03 ca	 add	 rcx, rdx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00426	4d 2b c1	 sub	 r8, r9

; 2622 : 		_My_data._Mysize = _New_size;

  00429	4c 89 45 9f	 mov	 QWORD PTR buf2$414[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0042d	4c 2b c2	 sub	 r8, rdx
  00430	49 ff c0	 inc	 r8
  00433	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00437	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0043d	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$414[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00441	48 83 7d a7 10	 cmp	 QWORD PTR buf2$414[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00446	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$414[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 460  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0044b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00451	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloœæ_pieniêdzy$GSCopy$1$[rsp]
  00456	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00458	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$414[rbp-153]
  0045c	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00460	0f 82 df 11 00
	00		 jb	 $LN51@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00466	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00469	48 8b 4d 8f	 mov	 rcx, QWORD PTR buf2$414[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  0046d	45 84 e4	 test	 r12b, r12b
  00470	75 30		 jne	 SHORT $_Invalid_parameter$2937

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00472	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00478	72 1e		 jb	 SHORT $LN570@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0047a	f6 c1 1f	 test	 cl, 31
  0047d	75 23		 jne	 SHORT $_Invalid_parameter$2937

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0047f	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00483	48 3b c1	 cmp	 rax, rcx
  00486	73 1a		 jae	 SHORT $_Invalid_parameter$2937
  00488	48 2b c8	 sub	 rcx, rax
  0048b	48 83 e9 08	 sub	 rcx, 8
  0048f	48 83 f9 1f	 cmp	 rcx, 31
  00493	77 0d		 ja	 SHORT $_Invalid_parameter$2937

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00495	48 8b c8	 mov	 rcx, rax
$LN570@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00498	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 462  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o wylosowaniu liczby

  0049d	e9 a3 11 00 00	 jmp	 $LN51@Wczytaj_z_
$_Invalid_parameter$2937:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  004a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  004a8	cc		 int	 3
$LN2913@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 451  : 		if (buf.find("Posiadasz") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o skoñczeniu rundy

  004a9	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
$LN36@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  004ad	48 8d 7d af	 lea	 rdi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004b1	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  004b6	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  004bb	48 83 f8 0a	 cmp	 rax, 10
  004bf	0f 82 47 08 00
	00		 jb	 $LN38@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  004c5	48 8d 34 07	 lea	 rsi, QWORD PTR [rdi+rax]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004c9	4c 8d 46 f7	 lea	 r8, QWORD PTR [rsi-9]
  004cd	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  004d0	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  004d5	48 8b cf	 mov	 rcx, rdi
  004d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  004de	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  004e1	48 85 c0	 test	 rax, rax
  004e4	0f 84 1e 08 00
	00		 je	 $LN2914@Wczytaj_z_
  004ea	66 0f 1f 44 00
	00		 npad	 6
$LL608@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004f0	41 b8 0a 00 00
	00		 mov	 r8d, 10
  004f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0L@DAFLKCID@Wylosowano?$AA@
  004fd	48 8b cb	 mov	 rcx, rbx
  00500	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00505	85 c0		 test	 eax, eax
  00507	74 25		 je	 SHORT $LN2734@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00509	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0050c	4c 8d 46 f7	 lea	 r8, QWORD PTR [rsi-9]
  00510	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00513	ba 57 00 00 00	 mov	 edx, 87			; 00000057H
  00518	48 8b cb	 mov	 rcx, rbx
  0051b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00521	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00524	48 85 c0	 test	 rax, rax
  00527	75 c7		 jne	 SHORT $LL608@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00529	e9 da 07 00 00	 jmp	 $LN2914@Wczytaj_z_
$LN2734@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  0052e	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 462  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o wylosowaniu liczby

  00531	48 83 fb ff	 cmp	 rbx, -1
  00535	0f 84 cd 07 00
	00		 je	 $LN2914@Wczytaj_z_

; 463  : 		{
; 464  : 			co_kontynuowaæ = 'w'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od sprawdzenia wygranej

  0053b	41 c6 07 77	 mov	 BYTE PTR [r15], 119	; 00000077H

; 465  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o wylosowanej liczbie

  0053f	45 33 d2	 xor	 r10d, r10d
  00542	41 0f b7 da	 movzx	 ebx, r10w
  00546	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$415[rbp-153]
  0054a	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$415[rbp-161]
  0054e	4c 8b 45 af	 mov	 r8, QWORD PTR buf$415[rbp-177]
  00552	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL6@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00560	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00564	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  00568	49 0f 43 c8	 cmovae	 rcx, r8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 466  : 			while (buf[pocz¹tek] != 'y' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukiwanie od pocz¹tku litery y która wystêpuje w wyrazie po którym jest wylosowana liczba

  0056c	0f b7 c3	 movzx	 eax, bx
  0056f	80 3c 08 79	 cmp	 BYTE PTR [rax+rcx], 121	; 00000079H
  00573	74 0d		 je	 SHORT $LN7@Wczytaj_z_
  00575	0f b7 c3	 movzx	 eax, bx
  00578	41 3b c1	 cmp	 eax, r9d
  0057b	7d 05		 jge	 SHORT $LN7@Wczytaj_z_
  0057d	66 ff c3	 inc	 bx
  00580	eb de		 jmp	 SHORT $LL6@Wczytaj_z_
$LN7@Wczytaj_z_:

; 467  : 			pocz¹tek += 10; //Przesuniêcie o +10 pozycji pocz¹tku tekstu o po której jest wylosowana liczba

  00582	66 83 c3 0a	 add	 bx, 10
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00586	4c 89 55 9f	 mov	 QWORD PTR buf2$413[rbp-161], r10

; 1577 : 		_Myres(0)

  0058a	4c 89 55 a7	 mov	 QWORD PTR buf2$413[rbp-153], r10

; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  0058e	48 8b 75 bf	 mov	 rsi, QWORD PTR buf$415[rbp-161]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00592	4c 8d 7d af	 lea	 r15, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00596	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  0059a	4d 0f 43 f8	 cmovae	 r15, r8

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  0059e	48 83 fe 10	 cmp	 rsi, 16
  005a2	73 0f		 jae	 SHORT $LN669@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  005a4	41 0f 10 07	 movups	 xmm0, XMMWORD PTR [r15]
  005a8	0f 11 45 8f	 movups	 XMMWORD PTR buf2$413[rbp-177], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2192 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  005ac	bf 0f 00 00 00	 mov	 edi, 15

; 2193 : 			return;

  005b1	eb 79		 jmp	 SHORT $LN2935@Wczytaj_z_
$LN669@Wczytaj_z_:

; 2194 : 			}
; 2195 : 
; 2196 : 		auto& _Al = this->_Getal();
; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  005b3	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  005bd	48 8b fe	 mov	 rdi, rsi
  005c0	48 83 cf 0f	 or	 rdi, 15
  005c4	48 3b f8	 cmp	 rdi, rax
  005c7	48 0f 47 f8	 cmova	 rdi, rax

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  005cb	48 8d 4f 01	 lea	 rcx, QWORD PTR [rdi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  005cf	48 85 c9	 test	 rcx, rcx
  005d2	75 05		 jne	 SHORT $LN726@Wczytaj_z_

; 53   : 		{
; 54   : 		return (_Ptr);

  005d4	49 8b ca	 mov	 rcx, r10
  005d7	eb 43		 jmp	 SHORT $LN725@Wczytaj_z_
$LN726@Wczytaj_z_:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  005d9	45 84 d2	 test	 r10b, r10b
  005dc	74 07		 je	 SHORT $LN727@Wczytaj_z_

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  005de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  005e4	cc		 int	 3
$LN727@Wczytaj_z_:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  005e5	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  005ec	72 26		 jb	 SHORT $LN728@Wczytaj_z_

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  005ee	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  005f2	48 3b c1	 cmp	 rax, rcx
  005f5	77 07		 ja	 SHORT $LN729@Wczytaj_z_

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  005f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  005fd	cc		 int	 3
$LN729@Wczytaj_z_:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  005fe	48 8b c8	 mov	 rcx, rax
  00601	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00606	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0060a	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0060e	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00612	eb 08		 jmp	 SHORT $LN725@Wczytaj_z_
$LN728@Wczytaj_z_:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00614	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00619	48 8b c8	 mov	 rcx, rax
$LN725@Wczytaj_z_:

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0061c	48 89 4d 8f	 mov	 QWORD PTR buf2$413[rbp-177], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  00620	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00624	49 8b d7	 mov	 rdx, r15
  00627	e8 00 00 00 00	 call	 memcpy
$LN2935@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  0062c	48 89 7d a7	 mov	 QWORD PTR buf2$413[rbp-153], rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 469  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00630	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00633	48 3b f0	 cmp	 rsi, rax
  00636	48 0f 42 c6	 cmovb	 rax, rsi

; 1595 : 		value_type * _Result = _Bx._Buf;

  0063a	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0063e	48 83 ff 10	 cmp	 rdi, 16

; 1596 : 		if (_Large_string_engaged())

  00642	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00647	48 2b f0	 sub	 rsi, rax

; 2622 : 		_My_data._Mysize = _New_size;

  0064a	48 89 75 9f	 mov	 QWORD PTR buf2$413[rbp-161], rsi

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0064e	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  00652	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00656	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0065c	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00660	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00665	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 470  : 			wylosowana_liczba = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0066a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00670	41 89 04 24	 mov	 DWORD PTR [r12], eax

; 471  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  00674	33 c0		 xor	 eax, eax
  00676	0f b7 f8	 movzx	 edi, ax
  00679	48 8b 55 c7	 mov	 rdx, QWORD PTR buf$415[rbp-153]
  0067d	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$415[rbp-161]
  00681	4c 8b 45 af	 mov	 r8, QWORD PTR buf$415[rbp-177]
  00685	66 66 66 0f 1f
	84 00 00 00 00
	00		 npad	 11
$LL8@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00690	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00694	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  00698	49 0f 43 c8	 cmovae	 rcx, r8
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 472  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (int)buf.size()) ++pocz¹tek;

  0069c	0f b7 c7	 movzx	 eax, di
  0069f	80 3c 08 64	 cmp	 BYTE PTR [rax+rcx], 100	; 00000064H
  006a3	74 0d		 je	 SHORT $LN9@Wczytaj_z_
  006a5	0f b7 c7	 movzx	 eax, di
  006a8	41 3b c1	 cmp	 eax, r9d
  006ab	7d 05		 jge	 SHORT $LN9@Wczytaj_z_
  006ad	66 ff c7	 inc	 di
  006b0	eb de		 jmp	 SHORT $LL8@Wczytaj_z_
$LN9@Wczytaj_z_:

; 473  : 			pocz¹tek += 2;  //Przesuniêcie o +2 pozycji pocz¹tku tekstu o po której jest typ zak³adu

  006b2	66 83 c7 02	 add	 di, 2
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  006b6	4c 8d 4d af	 lea	 r9, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006ba	48 83 fa 10	 cmp	 rdx, 16

; 1607 : 		if (_Large_string_engaged())

  006be	4d 0f 43 c8	 cmovae	 r9, r8

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  006c2	48 8b 75 bf	 mov	 rsi, QWORD PTR buf$415[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  006c6	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  006ca	48 3b f0	 cmp	 rsi, rax
  006cd	77 26		 ja	 SHORT $LN846@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  006cf	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006d3	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  006d7	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$413[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  006dc	48 89 75 9f	 mov	 QWORD PTR buf2$413[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  006e0	4c 8b c6	 mov	 r8, rsi
  006e3	49 8b d1	 mov	 rdx, r9
  006e6	48 8b cb	 mov	 rcx, rbx
  006e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  006ef	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  006f3	eb 0c		 jmp	 SHORT $LN845@Wczytaj_z_
$LN846@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  006f5	48 8b d6	 mov	 rdx, rsi
  006f8	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  006fc	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN845@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 475  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00701	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00704	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00708	4c 3b c0	 cmp	 r8, rax
  0070b	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  0070f	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00713	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00718	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  0071d	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  00720	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00724	49 ff c0	 inc	 r8
  00727	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0072b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  00731	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00735	4d 8b e0	 mov	 r12, r8

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00738	48 8d 75 8f	 lea	 rsi, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0073c	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00741	48 0f 43 75 8f	 cmovae	 rsi, QWORD PTR buf2$413[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00746	49 83 f8 0b	 cmp	 r8, 11
  0074a	72 6c		 jb	 SHORT $LN928@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0074c	49 8d 1c 30	 lea	 rbx, QWORD PTR [r8+rsi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00750	4c 8d 43 f6	 lea	 r8, QWORD PTR [rbx-10]
  00754	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00757	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  0075c	48 8b ce	 mov	 rcx, rsi
  0075f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00765	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00768	48 85 c0	 test	 rax, rax
  0076b	74 47		 je	 SHORT $LN2735@Wczytaj_z_
  0076d	0f 1f 00	 npad	 3
$LL926@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00770	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00776	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  0077d	48 8b cf	 mov	 rcx, rdi
  00780	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00785	85 c0		 test	 eax, eax
  00787	74 22		 je	 SHORT $LN2736@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00789	48 ff c7	 inc	 rdi

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0078c	4c 8d 43 f6	 lea	 r8, QWORD PTR [rbx-10]
  00790	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00793	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00798	48 8b cf	 mov	 rcx, rdi
  0079b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  007a1	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  007a4	48 85 c0	 test	 rax, rax
  007a7	75 c7		 jne	 SHORT $LL926@Wczytaj_z_
  007a9	eb 09		 jmp	 SHORT $LN2735@Wczytaj_z_
$LN2736@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  007ab	48 2b fe	 sub	 rdi, rsi
  007ae	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  007b2	eb 08		 jmp	 SHORT $LN925@Wczytaj_z_
$LN2735@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  007b4	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
$LN928@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  007b8	48 83 cf ff	 or	 rdi, -1
$LN925@Wczytaj_z_:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007bc	48 8d 75 8f	 lea	 rsi, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007c0	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  007c5	48 0f 43 75 8f	 cmovae	 rsi, QWORD PTR buf2$413[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  007ca	49 83 f8 0b	 cmp	 r8, 11
  007ce	72 78		 jb	 SHORT $LN964@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  007d0	4d 8d 3c 30	 lea	 r15, QWORD PTR [r8+rsi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  007d4	4d 8d 47 f6	 lea	 r8, QWORD PTR [r15-10]
  007d8	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  007db	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  007e0	48 8b ce	 mov	 rcx, rsi
  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  007e9	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  007ec	48 85 c0	 test	 rax, rax
  007ef	74 53		 je	 SHORT $LN2737@Wczytaj_z_
  007f1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL962@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00800	41 b8 0b 00 00
	00		 mov	 r8d, 11
  00806	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@DIDIAOPI@?5Wylosowano?$AA@
  0080d	48 8b cb	 mov	 rcx, rbx
  00810	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00815	85 c0		 test	 eax, eax
  00817	74 22		 je	 SHORT $LN2738@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00819	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0081c	4d 8d 47 f6	 lea	 r8, QWORD PTR [r15-10]
  00820	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00823	ba 20 00 00 00	 mov	 edx, 32			; 00000020H
  00828	48 8b cb	 mov	 rcx, rbx
  0082b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00831	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00834	48 85 c0	 test	 rax, rax
  00837	75 c7		 jne	 SHORT $LL962@Wczytaj_z_
  00839	eb 09		 jmp	 SHORT $LN2737@Wczytaj_z_
$LN2738@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  0083b	48 2b de	 sub	 rbx, rsi
  0083e	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00842	eb 08		 jmp	 SHORT $LN961@Wczytaj_z_
$LN2737@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00844	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
$LN964@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00848	48 83 cb ff	 or	 rbx, -1
$LN961@Wczytaj_z_:

; 1622 : 		if (_Mysize < _Off)

  0084c	4c 3b c3	 cmp	 r8, rbx
  0084f	73 06		 jae	 SHORT $LN985@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  00851	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00856	cc		 int	 3
$LN985@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 476  : 			buf2.erase(buf2.find(" Wylosowano"), buf2.size() - buf2.find(" Wylosowano"));

  00857	4c 2b e7	 sub	 r12, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0085a	49 8b c0	 mov	 rax, r8
  0085d	48 2b c3	 sub	 rax, rbx
  00860	49 3b c4	 cmp	 rax, r12
  00863	4c 0f 42 e0	 cmovb	 r12, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00867	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0086b	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00870	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00875	48 03 cb	 add	 rcx, rbx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00878	4d 2b c4	 sub	 r8, r12

; 2622 : 		_My_data._Mysize = _New_size;

  0087b	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0087f	4c 2b c3	 sub	 r8, rbx
  00882	49 ff c0	 inc	 r8
  00885	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00889	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2253 : 		if (this != _STD addressof(_Right))

  0088f	48 8d 45 8f	 lea	 rax, QWORD PTR buf2$413[rbp-177]
  00893	4c 3b e8	 cmp	 r13, rax
  00896	74 4c		 je	 SHORT $LN1030@Wczytaj_z_

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00898	4c 8d 4d 8f	 lea	 r9, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0089c	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  008a1	4c 0f 43 4d 8f	 cmovae	 r9, QWORD PTR buf2$413[rbp-177]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  008a6	48 8b 5d 9f	 mov	 rbx, QWORD PTR buf2$413[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  008aa	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  008ae	48 3b d8	 cmp	 rbx, rax
  008b1	77 26		 ja	 SHORT $LN1031@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  008b3	49 8b fd	 mov	 rdi, r13

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008b6	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  008ba	72 04		 jb	 SHORT $LN1040@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008bc	49 8b 7d 00	 mov	 rdi, QWORD PTR [r13]
$LN1040@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  008c0	49 89 5d 10	 mov	 QWORD PTR [r13+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  008c4	4c 8b c3	 mov	 r8, rbx
  008c7	49 8b d1	 mov	 rdx, r9
  008ca	48 8b cf	 mov	 rcx, rdi
  008cd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  008d3	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  008d7	eb 0b		 jmp	 SHORT $LN1030@Wczytaj_z_
$LN1031@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  008d9	48 8b d3	 mov	 rdx, rbx
  008dc	49 8b cd	 mov	 rcx, r13
  008df	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1030@Wczytaj_z_:

; 3062 : 		return (this->_Get_data()._Mysize);

  008e4	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  008e8	4d 8b e0	 mov	 r12, r8

; 1606 : 		const value_type * _Result = _Bx._Buf;

  008eb	48 8d 5d af	 lea	 rbx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008ef	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  008f4	48 0f 43 5d af	 cmovae	 rbx, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  008f9	49 83 f8 11	 cmp	 r8, 17
  008fd	72 69		 jb	 SHORT $LN1085@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  008ff	49 8d 34 18	 lea	 rsi, QWORD PTR [r8+rbx]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00903	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00907	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0090a	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  0090f	48 8b cb	 mov	 rcx, rbx
  00912	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00918	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0091b	48 85 c0	 test	 rax, rax
  0091e	74 44		 je	 SHORT $LN2739@Wczytaj_z_
$LL1083@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00920	41 b8 11 00 00
	00		 mov	 r8d, 17
  00926	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  0092d	48 8b cf	 mov	 rcx, rdi
  00930	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00935	85 c0		 test	 eax, eax
  00937	74 22		 je	 SHORT $LN2740@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00939	48 ff c7	 inc	 rdi

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0093c	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00940	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00943	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00948	48 8b cf	 mov	 rcx, rdi
  0094b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00951	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00954	48 85 c0	 test	 rax, rax
  00957	75 c7		 jne	 SHORT $LL1083@Wczytaj_z_
  00959	eb 09		 jmp	 SHORT $LN2739@Wczytaj_z_
$LN2740@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  0095b	48 2b fb	 sub	 rdi, rbx
  0095e	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  00962	eb 08		 jmp	 SHORT $LN1082@Wczytaj_z_
$LN2739@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00964	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
$LN1085@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00968	48 83 cf ff	 or	 rdi, -1
$LN1082@Wczytaj_z_:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0096c	48 8d 75 af	 lea	 rsi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00970	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00975	48 0f 43 75 af	 cmovae	 rsi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0097a	49 83 f8 11	 cmp	 r8, 17
  0097e	72 78		 jb	 SHORT $LN1121@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00980	4d 8d 3c 30	 lea	 r15, QWORD PTR [r8+rsi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00984	4d 8d 47 f0	 lea	 r8, QWORD PTR [r15-16]
  00988	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0098b	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00990	48 8b ce	 mov	 rcx, rsi
  00993	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00999	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0099c	48 85 c0	 test	 rax, rax
  0099f	74 53		 je	 SHORT $LN2741@Wczytaj_z_
  009a1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL1119@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  009b0	41 b8 11 00 00
	00		 mov	 r8d, 17
  009b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  009bd	48 8b cb	 mov	 rcx, rbx
  009c0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  009c5	85 c0		 test	 eax, eax
  009c7	74 22		 je	 SHORT $LN2742@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  009c9	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  009cc	4d 8d 47 f0	 lea	 r8, QWORD PTR [r15-16]
  009d0	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  009d3	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  009d8	48 8b cb	 mov	 rcx, rbx
  009db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  009e1	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  009e4	48 85 c0	 test	 rax, rax
  009e7	75 c7		 jne	 SHORT $LL1119@Wczytaj_z_
  009e9	eb 09		 jmp	 SHORT $LN2741@Wczytaj_z_
$LN2742@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  009eb	48 2b de	 sub	 rbx, rsi
  009ee	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  009f2	eb 08		 jmp	 SHORT $LN1118@Wczytaj_z_
$LN2741@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  009f4	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
$LN1121@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  009f8	48 83 cb ff	 or	 rbx, -1
$LN1118@Wczytaj_z_:

; 1622 : 		if (_Mysize < _Off)

  009fc	4c 3b c3	 cmp	 r8, rbx
  009ff	73 06		 jae	 SHORT $LN1142@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  00a01	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00a06	cc		 int	 3
$LN1142@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 478  : 			buf.erase(buf.find("Obstawiono zaklad"), buf.size() - buf.find("Obstawiono zaklad"));

  00a07	4c 2b e7	 sub	 r12, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00a0a	49 8b c0	 mov	 rax, r8
  00a0d	48 2b c3	 sub	 rax, rbx
  00a10	49 3b c4	 cmp	 rax, r12
  00a13	4c 0f 42 e0	 cmovb	 r12, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a17	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a1b	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00a20	48 0f 43 4d af	 cmovae	 rcx, QWORD PTR buf$415[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00a25	48 03 cb	 add	 rcx, rbx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00a28	4d 2b c4	 sub	 r8, r12

; 2622 : 		_My_data._Mysize = _New_size;

  00a2b	4c 89 45 bf	 mov	 QWORD PTR buf$415[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00a2f	4c 2b c3	 sub	 r8, rbx
  00a32	49 ff c0	 inc	 r8
  00a35	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00a39	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 479  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00a3f	45 33 e4	 xor	 r12d, r12d
  00a42	41 0f b7 fc	 movzx	 edi, r12w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a46	48 8d 45 af	 lea	 rax, QWORD PTR buf$415[rbp-177]

; 1596 : 		if (_Large_string_engaged())

  00a4a	48 8b 55 af	 mov	 rdx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a4e	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$415[rbp-153]
  00a52	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00a56	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 480  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00a5a	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$415[rbp-161]
  00a5f	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  00a63	75 0b		 jne	 SHORT $LL10@Wczytaj_z_
  00a65	41 8d 7c 24 0e	 lea	 edi, QWORD PTR [r12+14]

; 481  : 			else //Je¿eli nie to

  00a6a	eb 28		 jmp	 SHORT $LN41@Wczytaj_z_
  00a6c	0f 1f 40 00	 npad	 4
$LL10@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a70	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a74	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00a78	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 483  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  00a7c	0f b7 c7	 movzx	 eax, di
  00a7f	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  00a83	74 0b		 je	 SHORT $LN11@Wczytaj_z_
  00a85	66 41 3b f9	 cmp	 di, r9w
  00a89	73 05		 jae	 SHORT $LN11@Wczytaj_z_
  00a8b	66 ff c7	 inc	 di
  00a8e	eb e0		 jmp	 SHORT $LL10@Wczytaj_z_
$LN11@Wczytaj_z_:

; 484  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  00a90	66 83 c7 03	 add	 di, 3
$LN41@Wczytaj_z_:

; 485  : 			}
; 486  : 			int koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  00a94	0f b7 f7	 movzx	 esi, di
  00a97	ff c6		 inc	 esi
  00a99	8b ce		 mov	 ecx, esi
  00a9b	0f 1f 44 00 00	 npad	 5
$LL12@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00aa0	48 8d 45 af	 lea	 rax, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00aa4	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00aa8	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 487  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Poszukujemy znaku dolara przed którym jest kwota zak³adu

  00aac	80 3c 01 24	 cmp	 BYTE PTR [rcx+rax], 36	; 00000024H
  00ab0	74 0f		 je	 SHORT $LN13@Wczytaj_z_
  00ab2	41 0f b7 c1	 movzx	 eax, r9w
  00ab6	3b f0		 cmp	 esi, eax
  00ab8	7d 07		 jge	 SHORT $LN13@Wczytaj_z_
  00aba	ff c6		 inc	 esi
  00abc	48 ff c1	 inc	 rcx
  00abf	eb df		 jmp	 SHORT $LL12@Wczytaj_z_
$LN13@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00ac1	4c 8d 4d af	 lea	 r9, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ac5	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00ac9	4c 0f 43 ca	 cmovae	 r9, rdx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00acd	4c 8b 7d bf	 mov	 r15, QWORD PTR buf$415[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  00ad1	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  00ad5	4c 3b f8	 cmp	 r15, rax
  00ad8	77 26		 ja	 SHORT $LN1251@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  00ada	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ade	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00ae2	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$413[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  00ae7	4c 89 7d 9f	 mov	 QWORD PTR buf2$413[rbp-161], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00aeb	4d 8b c7	 mov	 r8, r15
  00aee	49 8b d1	 mov	 rdx, r9
  00af1	48 8b cb	 mov	 rcx, rbx
  00af4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00afa	46 88 24 3b	 mov	 BYTE PTR [rbx+r15], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  00afe	eb 0c		 jmp	 SHORT $LN1250@Wczytaj_z_
$LN1251@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00b00	49 8b d7	 mov	 rdx, r15
  00b03	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  00b07	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1250@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 489  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  00b0c	4c 63 ce	 movsxd	 r9, esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00b0f	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00b13	4d 3b c1	 cmp	 r8, r9
  00b16	73 06		 jae	 SHORT $LN1290@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  00b18	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00b1d	cc		 int	 3
$LN1290@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 489  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  00b1e	49 8b d0	 mov	 rdx, r8
  00b21	49 2b d1	 sub	 rdx, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00b24	48 3b d2	 cmp	 rdx, rdx

; 1595 : 		value_type * _Result = _Bx._Buf;

  00b27	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b2b	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00b30	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00b35	49 03 c9	 add	 rcx, r9

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00b38	4c 2b c2	 sub	 r8, rdx

; 2622 : 		_My_data._Mysize = _New_size;

  00b3b	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00b3f	4d 2b c1	 sub	 r8, r9
  00b42	49 ff c0	 inc	 r8
  00b45	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00b48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 490  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00b4e	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00b51	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00b55	4c 3b c0	 cmp	 r8, rax
  00b58	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  00b5c	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b60	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00b65	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00b6a	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  00b6d	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00b71	49 ff c0	 inc	 r8
  00b74	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00b78	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00b7e	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b82	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00b87	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 491  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  00b8c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b92	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  00b97	89 01		 mov	 DWORD PTR [rcx], eax

; 492  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  00b99	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$416[rbp-161]
  00b9d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  00ba2	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$416[rbp-153]
  00ba6	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$416[rbp-177]
  00baa	66 0f 1f 44 00
	00		 npad	 6
$LL14@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00bb0	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bb4	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00bb8	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 493  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  00bbc	0f b7 c7	 movzx	 eax, di
  00bbf	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  00bc3	74 0a		 je	 SHORT $LN15@Wczytaj_z_
  00bc5	66 85 ff	 test	 di, di
  00bc8	74 05		 je	 SHORT $LN15@Wczytaj_z_
  00bca	66 03 fa	 add	 di, dx
  00bcd	eb e1		 jmp	 SHORT $LL14@Wczytaj_z_
$LN15@Wczytaj_z_:

; 494  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  00bcf	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00bd2	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bd6	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  00bda	4d 0f 43 ca	 cmovae	 r9, r10

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00bde	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$416[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  00be2	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  00be6	48 3b f0	 cmp	 rsi, rax
  00be9	77 26		 ja	 SHORT $LN1404@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  00beb	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bef	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00bf3	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$413[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  00bf8	48 89 75 9f	 mov	 QWORD PTR buf2$413[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00bfc	4c 8b c6	 mov	 r8, rsi
  00bff	49 8b d1	 mov	 rdx, r9
  00c02	48 8b cb	 mov	 rcx, rbx
  00c05	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00c0b	44 88 24 33	 mov	 BYTE PTR [rbx+rsi], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  00c0f	eb 0c		 jmp	 SHORT $LN1403@Wczytaj_z_
$LN1404@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00c11	48 8b d6	 mov	 rdx, rsi
  00c14	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]
  00c18	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1403@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 496  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00c1d	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00c20	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00c24	4c 3b c0	 cmp	 r8, rax
  00c27	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  00c2b	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c2f	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00c34	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00c39	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  00c3c	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00c40	49 ff c0	 inc	 r8
  00c43	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00c47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 497  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  00c4d	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$413[rbp-161]
  00c51	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00c55	4c 3b c2	 cmp	 r8, rdx
  00c58	73 06		 jae	 SHORT $LN1471@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  00c5a	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00c5f	cc		 int	 3
$LN1471@Wczytaj_z_:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00c60	49 8b c0	 mov	 rax, r8
  00c63	48 2b c2	 sub	 rax, rdx
  00c66	48 83 f8 01	 cmp	 rax, 1
  00c6a	41 b9 01 00 00
	00		 mov	 r9d, 1
  00c70	4c 0f 42 c8	 cmovb	 r9, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00c74	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c78	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00c7d	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00c82	48 03 ca	 add	 rcx, rdx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00c85	4d 2b c1	 sub	 r8, r9

; 2622 : 		_My_data._Mysize = _New_size;

  00c88	4c 89 45 9f	 mov	 QWORD PTR buf2$413[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00c8c	4c 2b c2	 sub	 r8, rdx
  00c8f	49 ff c0	 inc	 r8
  00c92	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00c96	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00c9c	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$413[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ca0	48 83 7d a7 10	 cmp	 QWORD PTR buf2$413[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00ca5	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$413[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 498  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  00caa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00cb0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloœæ_pieniêdzy$GSCopy$1$[rsp]
  00cb5	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cb7	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$413[rbp-153]
  00cbb	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00cbf	0f 82 80 09 00
	00		 jb	 $LN51@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00cc5	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00cc8	48 8b 4d 8f	 mov	 rcx, QWORD PTR buf2$413[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00ccc	45 84 e4	 test	 r12b, r12b
  00ccf	75 30		 jne	 SHORT $_Invalid_parameter$2938

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00cd1	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00cd7	72 1e		 jb	 SHORT $LN1536@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00cd9	f6 c1 1f	 test	 cl, 31
  00cdc	75 23		 jne	 SHORT $_Invalid_parameter$2938

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00cde	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00ce2	48 3b c1	 cmp	 rax, rcx
  00ce5	73 1a		 jae	 SHORT $_Invalid_parameter$2938
  00ce7	48 2b c8	 sub	 rcx, rax
  00cea	48 83 e9 08	 sub	 rcx, 8
  00cee	48 83 f9 1f	 cmp	 rcx, 31
  00cf2	77 0d		 ja	 SHORT $_Invalid_parameter$2938

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00cf4	48 8b c8	 mov	 rcx, rax
$LN1536@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00cf7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 500  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o typie obstawionego zak³adu

  00cfc	e9 44 09 00 00	 jmp	 $LN51@Wczytaj_z_
$_Invalid_parameter$2938:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d01	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00d07	cc		 int	 3
$LN2914@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 462  : 		else if (buf.find("Wylosowano") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o wylosowaniu liczby

  00d08	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
$LN38@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00d0c	48 8d 7d af	 lea	 rdi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d10	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00d15	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00d1a	48 83 f8 11	 cmp	 rax, 17
  00d1e	0f 82 78 05 00
	00		 jb	 $LN42@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00d24	48 8d 34 07	 lea	 rsi, QWORD PTR [rdi+rax]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00d28	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00d2c	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00d2f	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00d34	48 8b cf	 mov	 rcx, rdi
  00d37	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00d3d	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00d40	48 85 c0	 test	 rax, rax
  00d43	0f 84 4f 05 00
	00		 je	 $LN2915@Wczytaj_z_
  00d49	0f 1f 80 00 00
	00 00		 npad	 7
$LL1574@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00d50	41 b8 11 00 00
	00		 mov	 r8d, 17
  00d56	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00d5d	48 8b cb	 mov	 rcx, rbx
  00d60	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00d65	85 c0		 test	 eax, eax
  00d67	74 25		 je	 SHORT $LN2744@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00d69	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00d6c	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00d70	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00d73	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00d78	48 8b cb	 mov	 rcx, rbx
  00d7b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00d81	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00d84	48 85 c0	 test	 rax, rax
  00d87	75 c7		 jne	 SHORT $LL1574@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00d89	e9 0a 05 00 00	 jmp	 $LN2915@Wczytaj_z_
$LN2744@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  00d8e	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 500  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o typie obstawionego zak³adu

  00d91	48 83 fb ff	 cmp	 rbx, -1
  00d95	0f 84 fd 04 00
	00		 je	 $LN2915@Wczytaj_z_

; 501  : 		{
; 502  : 			co_kontynuowaæ = 't'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od wylosowania liczby

  00d9b	41 c6 07 74	 mov	 BYTE PTR [r15], 116	; 00000074H

; 503  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o typie zak³adu

  00d9f	33 c0		 xor	 eax, eax
  00da1	0f b7 d8	 movzx	 ebx, ax
  00da4	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$415[rbp-153]
  00da8	0f b7 55 bf	 movzx	 edx, WORD PTR buf$415[rbp-161]
  00dac	4c 8b 4d af	 mov	 r9, QWORD PTR buf$415[rbp-177]
$LL16@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00db0	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00db4	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00db8	49 0f 43 c9	 cmovae	 rcx, r9
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 504  : 			while (buf[pocz¹tek] != 'd' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek;

  00dbc	0f b7 c3	 movzx	 eax, bx
  00dbf	80 3c 08 64	 cmp	 BYTE PTR [rax+rcx], 100	; 00000064H
  00dc3	74 0a		 je	 SHORT $LN17@Wczytaj_z_
  00dc5	66 3b da	 cmp	 bx, dx
  00dc8	73 05		 jae	 SHORT $LN17@Wczytaj_z_
  00dca	66 ff c3	 inc	 bx
  00dcd	eb e1		 jmp	 SHORT $LL16@Wczytaj_z_
$LN17@Wczytaj_z_:

; 505  : 			pocz¹tek += 2; //Przesuniêcie pozycji pocz¹tku tekstu o 2 po której jest typ zak³adu

  00dcf	66 83 c3 02	 add	 bx, 2

; 506  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  00dd3	48 8d 55 af	 lea	 rdx, QWORD PTR buf$415[rbp-177]
  00dd7	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]
  00ddb	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  00de0	90		 npad	 1

; 507  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  00de1	0f b7 c3	 movzx	 eax, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00de4	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  00de8	4c 3b c0	 cmp	 r8, rax
  00deb	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  00def	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00df3	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00df8	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00dfd	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  00e00	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00e04	49 ff c0	 inc	 r8
  00e07	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00e0b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2253 : 		if (this != _STD addressof(_Right))

  00e11	48 8d 45 8f	 lea	 rax, QWORD PTR buf2$412[rbp-177]
  00e15	4c 3b e8	 cmp	 r13, rax
  00e18	74 4c		 je	 SHORT $LN1666@Wczytaj_z_

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00e1a	4c 8d 4d 8f	 lea	 r9, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e1e	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00e23	4c 0f 43 4d 8f	 cmovae	 r9, QWORD PTR buf2$412[rbp-177]

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00e28	48 8b 5d 9f	 mov	 rbx, QWORD PTR buf2$412[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  00e2c	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  00e30	48 3b d8	 cmp	 rbx, rax
  00e33	77 26		 ja	 SHORT $LN1667@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  00e35	49 8b fd	 mov	 rdi, r13

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e38	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00e3c	72 04		 jb	 SHORT $LN1676@Wczytaj_z_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00e3e	49 8b 7d 00	 mov	 rdi, QWORD PTR [r13]
$LN1676@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00e42	49 89 5d 10	 mov	 QWORD PTR [r13+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00e46	4c 8b c3	 mov	 r8, rbx
  00e49	49 8b d1	 mov	 rdx, r9
  00e4c	48 8b cf	 mov	 rcx, rdi
  00e4f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00e55	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  00e59	eb 0b		 jmp	 SHORT $LN1666@Wczytaj_z_
$LN1667@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00e5b	48 8b d3	 mov	 rdx, rbx
  00e5e	49 8b cd	 mov	 rcx, r13
  00e61	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1666@Wczytaj_z_:

; 3062 : 		return (this->_Get_data()._Mysize);

  00e66	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  00e6a	4d 8b e0	 mov	 r12, r8

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00e6d	48 8d 5d af	 lea	 rbx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e71	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00e76	48 0f 43 5d af	 cmovae	 rbx, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00e7b	49 83 f8 11	 cmp	 r8, 17
  00e7f	72 77		 jb	 SHORT $LN1721@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00e81	4a 8d 34 03	 lea	 rsi, QWORD PTR [rbx+r8]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00e85	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00e89	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00e8c	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00e91	48 8b cb	 mov	 rcx, rbx
  00e94	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00e9a	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00e9d	48 85 c0	 test	 rax, rax
  00ea0	74 52		 je	 SHORT $LN2745@Wczytaj_z_
  00ea2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL1719@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00eb0	41 b8 11 00 00
	00		 mov	 r8d, 17
  00eb6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00ebd	48 8b cf	 mov	 rcx, rdi
  00ec0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00ec5	85 c0		 test	 eax, eax
  00ec7	74 22		 je	 SHORT $LN2746@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00ec9	48 ff c7	 inc	 rdi

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00ecc	4c 8d 46 f0	 lea	 r8, QWORD PTR [rsi-16]
  00ed0	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00ed3	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00ed8	48 8b cf	 mov	 rcx, rdi
  00edb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00ee1	48 8b f8	 mov	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00ee4	48 85 c0	 test	 rax, rax
  00ee7	75 c7		 jne	 SHORT $LL1719@Wczytaj_z_
  00ee9	eb 09		 jmp	 SHORT $LN2745@Wczytaj_z_
$LN2746@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  00eeb	48 2b fb	 sub	 rdi, rbx
  00eee	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  00ef2	eb 08		 jmp	 SHORT $LN1718@Wczytaj_z_
$LN2745@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00ef4	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
$LN1721@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00ef8	48 83 cf ff	 or	 rdi, -1
$LN1718@Wczytaj_z_:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00efc	48 8d 75 af	 lea	 rsi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00f00	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  00f05	48 0f 43 75 af	 cmovae	 rsi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00f0a	49 83 f8 11	 cmp	 r8, 17
  00f0e	72 78		 jb	 SHORT $LN1757@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00f10	4e 8d 3c 06	 lea	 r15, QWORD PTR [rsi+r8]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00f14	4d 8d 47 f0	 lea	 r8, QWORD PTR [r15-16]
  00f18	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00f1b	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00f20	48 8b ce	 mov	 rcx, rsi
  00f23	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00f29	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00f2c	48 85 c0	 test	 rax, rax
  00f2f	74 53		 je	 SHORT $LN2747@Wczytaj_z_
  00f31	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL1755@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00f40	41 b8 11 00 00
	00		 mov	 r8d, 17
  00f46	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@EAGHPBJK@Obstawiono?5zaklad?$AA@
  00f4d	48 8b cb	 mov	 rcx, rbx
  00f50	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00f55	85 c0		 test	 eax, eax
  00f57	74 22		 je	 SHORT $LN2748@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  00f59	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00f5c	4d 8d 47 f0	 lea	 r8, QWORD PTR [r15-16]
  00f60	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00f63	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  00f68	48 8b cb	 mov	 rcx, rbx
  00f6b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00f71	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00f74	48 85 c0	 test	 rax, rax
  00f77	75 c7		 jne	 SHORT $LL1755@Wczytaj_z_
  00f79	eb 09		 jmp	 SHORT $LN2747@Wczytaj_z_
$LN2748@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  00f7b	48 2b de	 sub	 rbx, rsi
  00f7e	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
  00f82	eb 08		 jmp	 SHORT $LN1754@Wczytaj_z_
$LN2747@Wczytaj_z_:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  00f84	4c 8b 45 bf	 mov	 r8, QWORD PTR buf$415[rbp-161]
$LN1757@Wczytaj_z_:

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));

  00f88	48 83 cb ff	 or	 rbx, -1
$LN1754@Wczytaj_z_:

; 1622 : 		if (_Mysize < _Off)

  00f8c	4c 3b c3	 cmp	 r8, rbx
  00f8f	73 06		 jae	 SHORT $LN1778@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  00f91	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00f96	cc		 int	 3
$LN1778@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 509  : 			buf.erase(buf.find("Obstawiono zaklad"), buf.size() - buf.find("Obstawiono zaklad"));

  00f97	4c 2b e7	 sub	 r12, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00f9a	49 8b c0	 mov	 rax, r8
  00f9d	48 2b c3	 sub	 rax, rbx
  00fa0	49 3b c4	 cmp	 rax, r12
  00fa3	4c 0f 42 e0	 cmovb	 r12, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00fa7	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00fab	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  00fb0	48 0f 43 4d af	 cmovae	 rcx, QWORD PTR buf$415[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  00fb5	48 03 cb	 add	 rcx, rbx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00fb8	4d 2b c4	 sub	 r8, r12

; 2622 : 		_My_data._Mysize = _New_size;

  00fbb	4c 89 45 bf	 mov	 QWORD PTR buf$415[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00fbf	4c 2b c3	 sub	 r8, rbx
  00fc2	49 ff c0	 inc	 r8
  00fc5	4a 8d 14 21	 lea	 rdx, QWORD PTR [rcx+r12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00fc9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 510  : 			pocz¹tek = 0; //Przypisanie zera do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie zak³adu

  00fcf	45 33 e4	 xor	 r12d, r12d
  00fd2	41 0f b7 fc	 movzx	 edi, r12w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00fd6	48 8d 45 af	 lea	 rax, QWORD PTR buf$415[rbp-177]

; 1596 : 		if (_Large_string_engaged())

  00fda	48 8b 55 af	 mov	 rdx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00fde	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$415[rbp-153]
  00fe2	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00fe6	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 511  : 			if (buf[12] == 'a') pocz¹tek = 14; //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  00fea	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  00fee	75 07		 jne	 SHORT $LN2905@Wczytaj_z_
  00ff0	41 8d 7c 24 0e	 lea	 edi, QWORD PTR [r12+14]

; 512  : 			else //Je¿eli nie to

  00ff5	eb 2f		 jmp	 SHORT $LN45@Wczytaj_z_
$LN2905@Wczytaj_z_:
  00ff7	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$415[rbp-161]
  00ffb	0f 1f 44 00 00	 npad	 5
$LL18@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01000	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01004	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01008	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 514  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (int)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0100c	0f b7 c7	 movzx	 eax, di
  0100f	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  01013	74 0d		 je	 SHORT $LN19@Wczytaj_z_
  01015	0f b7 c7	 movzx	 eax, di
  01018	41 3b c1	 cmp	 eax, r9d
  0101b	7d 05		 jge	 SHORT $LN19@Wczytaj_z_
  0101d	66 ff c7	 inc	 di
  01020	eb de		 jmp	 SHORT $LL18@Wczytaj_z_
$LN19@Wczytaj_z_:

; 515  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  01022	66 83 c7 03	 add	 di, 3
$LN45@Wczytaj_z_:

; 516  : 			}
; 517  : 			unsigned short koniec = pocz¹tek + 1; //Przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  01026	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
  01029	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$415[rbp-161]
  0102e	66 90		 npad	 2
$LL20@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01030	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01034	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01038	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 518  : 			while (buf[koniec] != '$' && koniec < (unsigned short)buf.size()) ++koniec; //Pêtla poszukuj¹ca znaku dolara, pêtla koñczy siê znalezieniem znaku dolara

  0103c	0f b7 c6	 movzx	 eax, si
  0103f	80 3c 08 24	 cmp	 BYTE PTR [rax+rcx], 36	; 00000024H
  01043	74 0b		 je	 SHORT $LN21@Wczytaj_z_
  01045	66 41 3b f1	 cmp	 si, r9w
  01049	73 05		 jae	 SHORT $LN21@Wczytaj_z_
  0104b	66 ff c6	 inc	 si
  0104e	eb e0		 jmp	 SHORT $LL20@Wczytaj_z_
$LN21@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01050	4c 8d 4d af	 lea	 r9, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01054	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  01058	4c 0f 43 ca	 cmovae	 r9, rdx

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0105c	4c 8b 7d bf	 mov	 r15, QWORD PTR buf$415[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  01060	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$412[rbp-153]
  01064	4c 3b f8	 cmp	 r15, rax
  01067	77 26		 ja	 SHORT $LN1887@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  01069	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0106d	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  01071	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$412[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  01076	4c 89 7d 9f	 mov	 QWORD PTR buf2$412[rbp-161], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0107a	4d 8b c7	 mov	 r8, r15
  0107d	49 8b d1	 mov	 rdx, r9
  01080	48 8b cb	 mov	 rcx, rbx
  01083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  01089	46 88 24 3b	 mov	 BYTE PTR [rbx+r15], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  0108d	eb 0c		 jmp	 SHORT $LN1886@Wczytaj_z_
$LN1887@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0108f	49 8b d7	 mov	 rdx, r15
  01092	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]
  01096	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN1886@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 520  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  0109b	44 0f b7 ce	 movzx	 r9d, si
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0109f	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  010a3	4d 3b c1	 cmp	 r8, r9
  010a6	73 06		 jae	 SHORT $LN1926@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  010a8	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  010ad	cc		 int	 3
$LN1926@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 520  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  010ae	49 8b d0	 mov	 rdx, r8
  010b1	49 2b d1	 sub	 rdx, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  010b4	48 3b d2	 cmp	 rdx, rdx

; 1595 : 		value_type * _Result = _Bx._Buf;

  010b7	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010bb	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  010c0	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  010c5	49 03 c9	 add	 rcx, r9

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  010c8	4c 2b c2	 sub	 r8, rdx

; 2622 : 		_My_data._Mysize = _New_size;

  010cb	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  010cf	4d 2b c1	 sub	 r8, r9
  010d2	49 ff c0	 inc	 r8
  010d5	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  010d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 521  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  010de	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  010e1	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  010e5	4c 3b c0	 cmp	 r8, rax
  010e8	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  010ec	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010f0	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  010f5	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  010fa	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  010fd	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  01101	49 ff c0	 inc	 r8
  01104	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0110e	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01112	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  01117	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 522  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0111c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01122	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  01127	89 01		 mov	 DWORD PTR [rcx], eax

; 523  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  01129	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$416[rbp-161]
  0112d	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  01132	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$416[rbp-153]
  01136	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$416[rbp-177]
  0113a	66 0f 1f 44 00
	00		 npad	 6
$LL22@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01140	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01144	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01148	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 524  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0114c	0f b7 c7	 movzx	 eax, di
  0114f	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  01153	74 0a		 je	 SHORT $LN23@Wczytaj_z_
  01155	66 85 ff	 test	 di, di
  01158	74 05		 je	 SHORT $LN23@Wczytaj_z_
  0115a	66 03 fa	 add	 di, dx
  0115d	eb e1		 jmp	 SHORT $LL22@Wczytaj_z_
$LN23@Wczytaj_z_:

; 525  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  0115f	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01162	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01166	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0116a	4d 0f 43 ca	 cmovae	 r9, r10

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0116e	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$416[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  01172	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$412[rbp-153]
  01176	48 3b f0	 cmp	 rsi, rax
  01179	77 26		 ja	 SHORT $LN2040@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  0117b	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0117f	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  01183	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$412[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  01188	48 89 75 9f	 mov	 QWORD PTR buf2$412[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0118c	4c 8b c6	 mov	 r8, rsi
  0118f	49 8b d1	 mov	 rdx, r9
  01192	48 8b cb	 mov	 rcx, rbx
  01195	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0119b	44 88 24 33	 mov	 BYTE PTR [rbx+rsi], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  0119f	eb 0c		 jmp	 SHORT $LN2039@Wczytaj_z_
$LN2040@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  011a1	48 8b d6	 mov	 rdx, rsi
  011a4	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]
  011a8	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN2039@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 527  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  011ad	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  011b0	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  011b4	4c 3b c0	 cmp	 r8, rax
  011b7	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  011bb	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  011bf	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  011c4	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  011c9	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  011cc	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  011d0	49 ff c0	 inc	 r8
  011d3	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  011d7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 528  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  011dd	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$412[rbp-161]
  011e1	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  011e5	4c 3b c2	 cmp	 r8, rdx
  011e8	73 06		 jae	 SHORT $LN2107@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  011ea	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  011ef	cc		 int	 3
$LN2107@Wczytaj_z_:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  011f0	49 8b c0	 mov	 rax, r8
  011f3	48 2b c2	 sub	 rax, rdx
  011f6	48 83 f8 01	 cmp	 rax, 1
  011fa	41 b9 01 00 00
	00		 mov	 r9d, 1
  01200	4c 0f 42 c8	 cmovb	 r9, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  01204	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01208	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  0120d	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  01212	48 03 ca	 add	 rcx, rdx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  01215	4d 2b c1	 sub	 r8, r9

; 2622 : 		_My_data._Mysize = _New_size;

  01218	4c 89 45 9f	 mov	 QWORD PTR buf2$412[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0121c	4c 2b c2	 sub	 r8, rdx
  0121f	49 ff c0	 inc	 r8
  01222	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0122c	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$412[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01230	48 83 7d a7 10	 cmp	 QWORD PTR buf2$412[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  01235	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$412[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 529  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0123a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01240	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloœæ_pieniêdzy$GSCopy$1$[rsp]
  01245	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01247	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$412[rbp-153]
  0124b	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0124f	0f 82 f0 03 00
	00		 jb	 $LN51@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01255	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01258	48 8b 4d 8f	 mov	 rcx, QWORD PTR buf2$412[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  0125c	45 84 e4	 test	 r12b, r12b
  0125f	75 30		 jne	 SHORT $_Invalid_parameter$2939

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01261	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01267	72 1e		 jb	 SHORT $LN2172@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01269	f6 c1 1f	 test	 cl, 31
  0126c	75 23		 jne	 SHORT $_Invalid_parameter$2939

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0126e	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01272	48 3b c1	 cmp	 rax, rcx
  01275	73 1a		 jae	 SHORT $_Invalid_parameter$2939
  01277	48 2b c8	 sub	 rcx, rax
  0127a	48 83 e9 08	 sub	 rcx, 8
  0127e	48 83 f9 1f	 cmp	 rcx, 31
  01282	77 0d		 ja	 SHORT $_Invalid_parameter$2939

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01284	48 8b c8	 mov	 rcx, rax
$LN2172@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01287	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o kwocie obstawionego zak³adu

  0128c	e9 b4 03 00 00	 jmp	 $LN51@Wczytaj_z_
$_Invalid_parameter$2939:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01297	cc		 int	 3
$LN2915@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 500  : 		else if (buf.find("Obstawiono zaklad") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o typie obstawionego zak³adu

  01298	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
$LN42@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0129c	48 8d 7d af	 lea	 rdi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  012a0	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  012a5	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  012aa	48 83 f8 0d	 cmp	 rax, 13
  012ae	0f 82 08 03 00
	00		 jb	 $LN46@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  012b4	48 8d 34 38	 lea	 rsi, QWORD PTR [rax+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  012b8	4c 8d 46 f4	 lea	 r8, QWORD PTR [rsi-12]
  012bc	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  012bf	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  012c4	48 8b cf	 mov	 rcx, rdi
  012c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  012cd	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  012d0	48 85 c0	 test	 rax, rax
  012d3	0f 84 df 02 00
	00		 je	 $LN2916@Wczytaj_z_
  012d9	0f 1f 80 00 00
	00 00		 npad	 7
$LL2210@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  012e0	41 b8 0d 00 00
	00		 mov	 r8d, 13
  012e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0O@POHKAIHJ@Obstawiono?5za?$AA@
  012ed	48 8b cb	 mov	 rcx, rbx
  012f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  012f5	85 c0		 test	 eax, eax
  012f7	74 25		 je	 SHORT $LN2750@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  012f9	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  012fc	4c 8d 46 f4	 lea	 r8, QWORD PTR [rsi-12]
  01300	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  01303	ba 4f 00 00 00	 mov	 edx, 79			; 0000004fH
  01308	48 8b cb	 mov	 rcx, rbx
  0130b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  01311	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  01314	48 85 c0	 test	 rax, rax
  01317	75 c7		 jne	 SHORT $LL2210@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  01319	e9 9a 02 00 00	 jmp	 $LN2916@Wczytaj_z_
$LN2750@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  0131e	48 2b df	 sub	 rbx, rdi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o kwocie obstawionego zak³adu

  01321	48 83 fb ff	 cmp	 rbx, -1
  01325	0f 84 8d 02 00
	00		 je	 $LN2916@Wczytaj_z_

; 532  : 		{
; 533  : 			co_kontynuowaæ = 'k';  //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od zapytania o typ zak³adu

  0132b	41 c6 07 6b	 mov	 BYTE PTR [r15], 107	; 0000006bH

; 534  : 			unsigned short pocz¹tek = 0; //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  0132f	45 33 e4	 xor	 r12d, r12d
  01332	41 0f b7 fc	 movzx	 edi, r12w
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01336	48 8d 45 af	 lea	 rax, QWORD PTR buf$415[rbp-177]

; 1596 : 		if (_Large_string_engaged())

  0133a	48 8b 55 af	 mov	 rdx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0133e	4c 8b 45 c7	 mov	 r8, QWORD PTR buf$415[rbp-153]
  01342	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01346	48 0f 43 c2	 cmovae	 rax, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 535  : 			if (buf[12] == 'a') { pocz¹tek = 14; } //Sprawdzenie czy na pozycji 12 teksty znajduje siê litera a œwiadcz¹ca o wyrazie po którym jest kwota zak³adu, je¿eli tak to pozycja pocz¹tkowa tekstu wynosi 14

  0134a	80 78 0c 61	 cmp	 BYTE PTR [rax+12], 97	; 00000061H
  0134e	75 07		 jne	 SHORT $LN2909@Wczytaj_z_
  01350	41 8d 7c 24 0e	 lea	 edi, QWORD PTR [r12+14]

; 536  : 			else //Je¿eli nie to

  01355	eb 2d		 jmp	 SHORT $LN49@Wczytaj_z_
$LN2909@Wczytaj_z_:
  01357	44 0f b7 4d bf	 movzx	 r9d, WORD PTR buf$415[rbp-161]
  0135c	0f 1f 40 00	 npad	 4
$LL24@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01360	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01364	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01368	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 538  : 				while (buf[pocz¹tek] != 'z' && pocz¹tek < (unsigned short)buf.size()) ++pocz¹tek; //Poszukanie litery z œwiadcz¹cej o wyrazie po którym jest kwota zak³adu

  0136c	0f b7 c7	 movzx	 eax, di
  0136f	80 3c 08 7a	 cmp	 BYTE PTR [rax+rcx], 122	; 0000007aH
  01373	74 0b		 je	 SHORT $LN25@Wczytaj_z_
  01375	66 41 3b f9	 cmp	 di, r9w
  01379	73 05		 jae	 SHORT $LN25@Wczytaj_z_
  0137b	66 ff c7	 inc	 di
  0137e	eb e0		 jmp	 SHORT $LL24@Wczytaj_z_
$LN25@Wczytaj_z_:

; 539  : 				pocz¹tek += 3; //Po znalezienu z przesuwamy pozycje +3

  01380	66 83 c7 03	 add	 di, 3
$LN49@Wczytaj_z_:

; 540  : 			}
; 541  : 			unsigned short koniec = pocz¹tek + 1; //Utworzenie i przypisanie do zmiennej pozycji pocz¹tku +1 wskazuj¹cej koniec tekst o kwocie zak³adu

  01384	8d 5f 01	 lea	 ebx, DWORD PTR [rdi+1]
  01387	44 8b 4d bf	 mov	 r9d, DWORD PTR buf$415[rbp-161]
  0138b	0f 1f 44 00 00	 npad	 5
$LL26@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01390	48 8d 4d af	 lea	 rcx, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01394	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01398	48 0f 43 ca	 cmovae	 rcx, rdx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 542  : 			while (buf[koniec] != '$' && koniec < (int)buf.size()) ++koniec;

  0139c	0f b7 c3	 movzx	 eax, bx
  0139f	80 3c 08 24	 cmp	 BYTE PTR [rax+rcx], 36	; 00000024H
  013a3	74 0d		 je	 SHORT $LN27@Wczytaj_z_
  013a5	0f b7 c3	 movzx	 eax, bx
  013a8	41 3b c1	 cmp	 eax, r9d
  013ab	7d 05		 jge	 SHORT $LN27@Wczytaj_z_
  013ad	66 ff c3	 inc	 bx
  013b0	eb de		 jmp	 SHORT $LL26@Wczytaj_z_
$LN27@Wczytaj_z_:

; 543  : 			string buf2 = buf; //Utworzenie bufora pomocniczego do ciêcia tekstu i w³o¿enie do niego wczeœniej odczytanego tekstu

  013b2	48 8d 55 af	 lea	 rdx, QWORD PTR buf$415[rbp-177]
  013b6	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]
  013ba	e8 00 00 00 00	 call	 ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
  013bf	90		 npad	 1

; 544  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  013c0	44 0f b7 cb	 movzx	 r9d, bx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  013c4	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$411[rbp-161]
  013c8	4d 3b c1	 cmp	 r8, r9
  013cb	73 06		 jae	 SHORT $LN2305@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  013cd	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  013d2	cc		 int	 3
$LN2305@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 544  : 			buf2.erase(koniec, buf2.size() - koniec); //Usuniêcie z bufora pomocniczego tekstu z prawej strony, aby tekst koñczy³ siê liczb¹

  013d3	49 8b d0	 mov	 rdx, r8
  013d6	49 2b d1	 sub	 rdx, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  013d9	48 3b d2	 cmp	 rdx, rdx

; 1595 : 		value_type * _Result = _Bx._Buf;

  013dc	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013e0	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  013e5	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  013ea	49 03 c9	 add	 rcx, r9

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  013ed	4c 2b c2	 sub	 r8, rdx

; 2622 : 		_My_data._Mysize = _New_size;

  013f0	4c 89 45 9f	 mov	 QWORD PTR buf2$411[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  013f4	4d 2b c1	 sub	 r8, r9
  013f7	49 ff c0	 inc	 r8
  013fa	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  013fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 545  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  01403	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  01406	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$411[rbp-161]
  0140a	4c 3b c0	 cmp	 r8, rax
  0140d	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  01411	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01415	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  0141a	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  0141f	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  01422	4c 89 45 9f	 mov	 QWORD PTR buf2$411[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  01426	49 ff c0	 inc	 r8
  01429	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0142d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01433	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01437	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  0143c	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 546  : 			kwota_zak³adu = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  01441	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01447	48 8b 4c 24 30	 mov	 rcx, QWORD PTR kwota_zak³adu$GSCopy$1$[rsp]
  0144c	89 01		 mov	 DWORD PTR [rcx], eax

; 547  : 			pocz¹tek = (unsigned short)bufor2.size(); //Utworzenie i przypisanie do zmiennej wskazuj¹cej pocz¹tek tekst o kwocie pieniêdzy któr¹ posiada jeszcze gracz

  0144e	0f b7 7d df	 movzx	 edi, WORD PTR bufor2$416[rbp-161]
  01452	ba ff ff 00 00	 mov	 edx, 65535		; 0000ffffH
  01457	4c 8b 45 e7	 mov	 r8, QWORD PTR bufor2$416[rbp-153]
  0145b	4c 8b 55 cf	 mov	 r10, QWORD PTR bufor2$416[rbp-177]
  0145f	90		 npad	 1
$LL28@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  01460	48 8d 4d cf	 lea	 rcx, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01464	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  01468	49 0f 43 ca	 cmovae	 rcx, r10
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 548  : 			while (bufor2[pocz¹tek] != ' ' && pocz¹tek > 0) --pocz¹tek; //Poszukiwanie od koñca spacji po której jest kwota pieniêdzy któr¹ posiada jeszcze gracz

  0146c	0f b7 c7	 movzx	 eax, di
  0146f	80 3c 08 20	 cmp	 BYTE PTR [rax+rcx], 32	; 00000020H
  01473	74 0a		 je	 SHORT $LN29@Wczytaj_z_
  01475	66 85 ff	 test	 di, di
  01478	74 05		 je	 SHORT $LN29@Wczytaj_z_
  0147a	66 03 fa	 add	 di, dx
  0147d	eb e1		 jmp	 SHORT $LL28@Wczytaj_z_
$LN29@Wczytaj_z_:

; 549  : 			++pocz¹tek; //Kwota jest na nastêpnym znaku wiêc przesuniêcie o jeden znak do przodu

  0147f	66 ff c7	 inc	 di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01482	4c 8d 4d cf	 lea	 r9, QWORD PTR bufor2$416[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01486	49 83 f8 10	 cmp	 r8, 16

; 1607 : 		if (_Large_string_engaged())

  0148a	4d 0f 43 ca	 cmovae	 r9, r10

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  0148e	48 8b 75 df	 mov	 rsi, QWORD PTR bufor2$416[rbp-161]

; 2435 : 		if (_Count <= _My_data._Myres)

  01492	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$411[rbp-153]
  01496	48 3b f0	 cmp	 rsi, rax
  01499	77 26		 ja	 SHORT $LN2419@Wczytaj_z_

; 1595 : 		value_type * _Result = _Bx._Buf;

  0149b	48 8d 5d 8f	 lea	 rbx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0149f	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  014a3	48 0f 43 5d 8f	 cmovae	 rbx, QWORD PTR buf2$411[rbp-177]

; 2438 : 			_My_data._Mysize = _Count;

  014a8	48 89 75 9f	 mov	 QWORD PTR buf2$411[rbp-161], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  014ac	4c 8b c6	 mov	 r8, rsi
  014af	49 8b d1	 mov	 rdx, r9
  014b2	48 8b cb	 mov	 rcx, rbx
  014b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  014bb	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  014bf	eb 0c		 jmp	 SHORT $LN2418@Wczytaj_z_
$LN2419@Wczytaj_z_:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  014c1	48 8b d6	 mov	 rdx, rsi
  014c4	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]
  014c8	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN2418@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 551  : 			buf2.erase(0, pocz¹tek); //Usuniêcie z bufora pomocniczego tekstu z lewej strony, aby tekst rozpoczyna³ siê liczb¹

  014cd	0f b7 c7	 movzx	 eax, di
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  014d0	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$411[rbp-161]
  014d4	4c 3b c0	 cmp	 r8, rax
  014d7	49 0f 42 c0	 cmovb	 rax, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  014db	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  014df	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  014e4	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  014e9	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;

  014ec	4c 89 45 9f	 mov	 QWORD PTR buf2$411[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  014f0	49 ff c0	 inc	 r8
  014f3	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  014f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 552  : 			buf2.erase(buf2.size() - 1, 1); //Usuniêcie z bufora pomocniczego znaku dolara z prawej strony

  014fd	4c 8b 45 9f	 mov	 r8, QWORD PTR buf2$411[rbp-161]
  01501	49 8d 50 ff	 lea	 rdx, QWORD PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  01505	4c 3b c2	 cmp	 r8, rdx
  01508	73 06		 jae	 SHORT $LN2486@Wczytaj_z_

; 1623 : 			{
; 1624 : 			_Xran();

  0150a	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  0150f	cc		 int	 3
$LN2486@Wczytaj_z_:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  01510	49 8b c0	 mov	 rax, r8
  01513	48 2b c2	 sub	 rax, rdx
  01516	48 83 f8 01	 cmp	 rax, 1
  0151a	41 b9 01 00 00
	00		 mov	 r9d, 1
  01520	4c 0f 42 c8	 cmovb	 r9, rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  01524	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01528	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1596 : 		if (_Large_string_engaged())

  0152d	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]

; 2620 : 		_Elem * const _Erase_at = _My_ptr + _Off;

  01532	48 03 ca	 add	 rcx, rdx

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  01535	4d 2b c1	 sub	 r8, r9

; 2622 : 		_My_data._Mysize = _New_size;

  01538	4c 89 45 9f	 mov	 QWORD PTR buf2$411[rbp-161], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0153c	4c 2b c2	 sub	 r8, rdx
  0153f	49 ff c0	 inc	 r8
  01542	4a 8d 14 09	 lea	 rdx, QWORD PTR [rcx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  01546	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0154c	48 8d 4d 8f	 lea	 rcx, QWORD PTR buf2$411[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01550	48 83 7d a7 10	 cmp	 QWORD PTR buf2$411[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  01555	48 0f 43 4d 8f	 cmovae	 rcx, QWORD PTR buf2$411[rbp-177]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 553  : 			iloœæ_pieniêdzy = atoi(buf2.c_str()); //Zamiana liczby w tekœcie na wartoœæ w zmiennnej liczbowej

  0155a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  01560	48 8b 4c 24 20	 mov	 rcx, QWORD PTR iloœæ_pieniêdzy$GSCopy$1$[rsp]
  01565	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01567	48 8b 45 a7	 mov	 rax, QWORD PTR buf2$411[rbp-153]
  0156b	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0156f	0f 82 d0 00 00
	00		 jb	 $LN51@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01575	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01578	48 8b 4d 8f	 mov	 rcx, QWORD PTR buf2$411[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  0157c	45 84 e4	 test	 r12b, r12b
  0157f	75 30		 jne	 SHORT $_Invalid_parameter$2940

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01581	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01587	72 1e		 jb	 SHORT $LN2551@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01589	f6 c1 1f	 test	 cl, 31
  0158c	75 23		 jne	 SHORT $_Invalid_parameter$2940

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0158e	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01592	48 3b c1	 cmp	 rax, rcx
  01595	73 1a		 jae	 SHORT $_Invalid_parameter$2940
  01597	48 2b c8	 sub	 rcx, rax
  0159a	48 83 e9 08	 sub	 rcx, 8
  0159e	48 83 f9 1f	 cmp	 rcx, 31
  015a2	77 0d		 ja	 SHORT $_Invalid_parameter$2940

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  015a4	48 8b c8	 mov	 rcx, rax
$LN2551@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  015a7	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 555  : 		else if (buf.find("Gra rozpoczeta dnia") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o rozpoczêciu nowej gry

  015ac	e9 94 00 00 00	 jmp	 $LN51@Wczytaj_z_
$_Invalid_parameter$2940:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  015b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  015b7	cc		 int	 3
$LN2916@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 531  : 		else if (buf.find("Obstawiono za") != string::npos) //Sprawdzenie czy w ostatniej niepustej lini znajduj¹ siê s³owa œwiadcz¹ce o kwocie obstawionego zak³adu

  015b8	48 8b 45 bf	 mov	 rax, QWORD PTR buf$415[rbp-161]
$LN46@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  015bc	48 8d 7d af	 lea	 rdi, QWORD PTR buf$415[rbp-177]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  015c0	48 83 7d c7 10	 cmp	 QWORD PTR buf$415[rbp-153], 16

; 1607 : 		if (_Large_string_engaged())

  015c5	48 0f 43 7d af	 cmovae	 rdi, QWORD PTR buf$415[rbp-177]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  015ca	48 83 f8 13	 cmp	 rax, 19
  015ce	72 6e		 jb	 SHORT $LN50@Wczytaj_z_

; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  015d0	48 8d 34 38	 lea	 rsi, QWORD PTR [rax+rdi]

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  015d4	4c 8d 46 ee	 lea	 r8, QWORD PTR [rsi-18]
  015d8	4c 2b c7	 sub	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  015db	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  015e0	48 8b cf	 mov	 rcx, rdi
  015e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  015e9	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  015ec	48 85 c0	 test	 rax, rax
  015ef	74 4d		 je	 SHORT $LN50@Wczytaj_z_
  015f1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL2589@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  01600	41 b8 13 00 00
	00		 mov	 r8d, 19
  01606	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@CILJHICG@Gra?5rozpoczeta?5dnia?$AA@
  0160d	48 8b cb	 mov	 rcx, rbx
  01610	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  01615	85 c0		 test	 eax, eax
  01617	74 22		 je	 SHORT $LN2752@Wczytaj_z_

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  01619	48 ff c3	 inc	 rbx

; 76   : 		{
; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0161c	4c 8d 46 ee	 lea	 r8, QWORD PTR [rsi-18]
  01620	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  01623	ba 47 00 00 00	 mov	 edx, 71			; 00000047H
  01628	48 8b cb	 mov	 rcx, rbx
  0162b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  01631	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  01634	48 85 c0	 test	 rax, rax
  01637	75 c7		 jne	 SHORT $LL2589@Wczytaj_z_

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  01639	eb 03		 jmp	 SHORT $LN50@Wczytaj_z_
$LN2752@Wczytaj_z_:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  0163b	48 2b df	 sub	 rbx, rdi
$LN50@Wczytaj_z_:
  0163e	45 33 e4	 xor	 r12d, r12d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 561  : 			co_kontynuowaæ = 'n'; //Je¿eli siê znajduj¹ to przypisanie znaku rozpoczêcia rundy od pocz¹tku

  01641	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH
$LN51@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1381 : 		if (_Filebuffer.close() == 0)

  01645	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  01649	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0164e	48 85 c0	 test	 rax, rax
  01651	75 17		 jne	 SHORT $LN2604@Wczytaj_z_

; 1382 : 			_Myios::setstate(ios_base::failbit);

  01653	49 8b 06	 mov	 rax, QWORD PTR [r14]
  01656	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0165a	49 03 ce	 add	 rcx, r14
  0165d	45 33 c0	 xor	 r8d, r8d
  01660	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  01664	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2604@Wczytaj_z_:

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  0166a	41 b8 0a 00 00
	00		 mov	 r8d, 10
  01670	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  01677	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  0167b	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1360 : 			_Myios::setstate(ios_base::failbit);

  01680	45 33 c0	 xor	 r8d, r8d

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  01683	48 85 c0	 test	 rax, rax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  01686	49 8b 06	 mov	 rax, QWORD PTR [r14]
  01689	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  0168d	75 0f		 jne	 SHORT $LN2607@Wczytaj_z_

; 1360 : 			_Myios::setstate(ios_base::failbit);

  0168f	49 03 ce	 add	 rcx, r14
  01692	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  01696	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1361 : 		else

  0169c	eb 0c		 jmp	 SHORT $LN2608@Wczytaj_z_
$LN2607@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  0169e	49 03 ce	 add	 rcx, r14
  016a1	33 d2		 xor	 edx, edx
  016a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  016a9	90		 npad	 1
$LN2608@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  016aa	48 8b 45 e7	 mov	 rax, QWORD PTR bufor2$416[rbp-153]
  016ae	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  016b2	72 40		 jb	 SHORT $LN2637@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  016b4	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  016b7	48 8b 4d cf	 mov	 rcx, QWORD PTR bufor2$416[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  016bb	45 84 e4	 test	 r12b, r12b
  016be	75 2d		 jne	 SHORT $_Invalid_parameter$2941

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  016c0	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  016c6	72 1e		 jb	 SHORT $LN2640@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  016c8	f6 c1 1f	 test	 cl, 31
  016cb	75 20		 jne	 SHORT $_Invalid_parameter$2941

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  016cd	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  016d1	48 3b c1	 cmp	 rax, rcx
  016d4	73 17		 jae	 SHORT $_Invalid_parameter$2941
  016d6	48 2b c8	 sub	 rcx, rax
  016d9	48 83 e9 08	 sub	 rcx, 8
  016dd	48 83 f9 1f	 cmp	 rcx, 31
  016e1	77 0a		 ja	 SHORT $_Invalid_parameter$2941

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  016e3	48 8b c8	 mov	 rcx, rax
$LN2640@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  016e6	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  016eb	eb 07		 jmp	 SHORT $LN2637@Wczytaj_z_
$_Invalid_parameter$2941:

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  016ed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  016f3	cc		 int	 3
$LN2637@Wczytaj_z_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  016f4	4c 89 65 df	 mov	 QWORD PTR bufor2$416[rbp-161], r12

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  016f8	48 c7 45 e7 0f
	00 00 00	 mov	 QWORD PTR bufor2$416[rbp-153], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01700	c6 45 cf 00	 mov	 BYTE PTR bufor2$416[rbp-177], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01704	48 8b 45 c7	 mov	 rax, QWORD PTR buf$415[rbp-153]
  01708	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0170c	0f 82 da 02 00
	00		 jb	 $LN33@Wczytaj_z_

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01712	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01715	48 8b 4d af	 mov	 rcx, QWORD PTR buf$415[rbp-177]

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  01719	45 84 e4	 test	 r12b, r12b
  0171c	75 30		 jne	 SHORT $_Invalid_parameter$2942

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0171e	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01724	72 1e		 jb	 SHORT $LN2686@Wczytaj_z_

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01726	f6 c1 1f	 test	 cl, 31
  01729	75 23		 jne	 SHORT $_Invalid_parameter$2942

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0172b	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0172f	48 3b c1	 cmp	 rax, rcx
  01732	73 1a		 jae	 SHORT $_Invalid_parameter$2942
  01734	48 2b c8	 sub	 rcx, rax
  01737	48 83 e9 08	 sub	 rcx, 8
  0173b	48 83 f9 1f	 cmp	 rcx, 31
  0173f	77 0d		 ja	 SHORT $_Invalid_parameter$2942

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01741	48 8b c8	 mov	 rcx, rax
$LN2686@Wczytaj_z_:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01744	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 566  : 	else

  01749	e9 9e 02 00 00	 jmp	 $LN33@Wczytaj_z_
$_Invalid_parameter$2942:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0174e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01754	cc		 int	 3
$LN32@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 568  : 		co_kontynuowaæ = 'n'; //Przypisanie znaku rozpoczêcia rundy od pocz¹tku

  01755	41 c6 07 6e	 mov	 BYTE PTR [r15], 110	; 0000006eH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  01759	41 b8 02 00 00
	00		 mov	 r8d, 2
  0175f	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1360 : 			_Myios::setstate(ios_base::failbit);

  01764	45 33 c0	 xor	 r8d, r8d

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  01767	48 85 c0	 test	 rax, rax

; 1360 : 			_Myios::setstate(ios_base::failbit);

  0176a	49 8b 06	 mov	 rax, QWORD PTR [r14]
  0176d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  01771	75 0f		 jne	 SHORT $LN2703@Wczytaj_z_

; 1360 : 			_Myios::setstate(ios_base::failbit);

  01773	49 03 ce	 add	 rcx, r14
  01776	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  0177a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1361 : 		else

  01780	eb 0b		 jmp	 SHORT $LN2704@Wczytaj_z_
$LN2703@Wczytaj_z_:

; 1362 : 			_Myios::clear();	// added with C++11

  01782	49 03 ce	 add	 rcx, r14
  01785	33 d2		 xor	 edx, edx
  01787	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2704@Wczytaj_z_:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 570  : 		GetSystemTime(&Czas); //Pobieranie aktualnej daty i czasu z zegara systemowego

  0178d	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Czas@@3U_SYSTEMTIME@@A ; Czas
  01794	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetSystemTime

; 571  : 		log << "Gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_aktualny.txt

  0179a	49 83 c6 10	 add	 r14, 16
  0179e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@EHKBBICH@Gra?5rozpoczeta?5dnia?5?$AA@
  017a5	49 8b ce	 mov	 rcx, r14
  017a8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017ad	48 8b c8	 mov	 rcx, rax
  017b0	0f b7 15 06 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  017b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  017bd	48 8b c8	 mov	 rcx, rax
  017c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  017c7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017cc	48 8b c8	 mov	 rcx, rax
  017cf	0f b7 15 02 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  017d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  017dc	48 8b c8	 mov	 rcx, rax
  017df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  017e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017eb	48 8b c8	 mov	 rcx, rax
  017ee	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  017f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  017fb	48 8b c8	 mov	 rcx, rax
  017fe	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  01805	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 572  : 		if (Czas.wHour < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_aktualny.txt

  0180a	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  01811	66 83 fa 0a	 cmp	 dx, 10
  01815	73 16		 jae	 SHORT $LN52@Wczytaj_z_
  01817	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  0181e	49 8b ce	 mov	 rcx, r14
  01821	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01826	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN52@Wczytaj_z_:

; 573  : 		log << Czas.wHour << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  0182d	49 8b ce	 mov	 rcx, r14
  01830	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01836	48 8b c8	 mov	 rcx, rax
  01839	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  01840	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 574  : 		if (Czas.wMinute < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsze ni¿ 10 do pliku log_aktualny.txt

  01845	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  0184c	66 83 fa 0a	 cmp	 dx, 10
  01850	73 16		 jae	 SHORT $LN53@Wczytaj_z_
  01852	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  01859	49 8b ce	 mov	 rcx, r14
  0185c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01861	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN53@Wczytaj_z_:

; 575  : 		log << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_aktualny.txt

  01868	49 8b ce	 mov	 rcx, r14
  0186b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01871	48 8b c8	 mov	 rcx, rax
  01874	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  0187b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 576  : 		if (Czas.wSecond < 10) log << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_aktualny.txt

  01880	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  01887	66 83 fa 0a	 cmp	 dx, 10
  0188b	73 16		 jae	 SHORT $LN54@Wczytaj_z_
  0188d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  01894	49 8b ce	 mov	 rcx, r14
  01897	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0189c	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN54@Wczytaj_z_:

; 577  : 		log << Czas.wSecond << endl; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_aktualny.txt

  018a3	49 8b ce	 mov	 rcx, r14
  018a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  018ac	48 8b c8	 mov	 rcx, rax
  018af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  018b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 578  : 		log_ogólny << "Nowa gra rozpoczeta dnia " << Czas.wDay << "." << Czas.wMonth << "." << Czas.wYear << " o godzinie "; //Wpisanie do bufora zapisu danych o dniu,miesi¹cu i roku do pliku log_ogólny.txt

  018bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BK@PLEOEKGI@Nowa?5gra?5rozpoczeta?5dnia?5?$AA@
  018c3	48 8b cb	 mov	 rcx, rbx
  018c6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  018cb	48 8b c8	 mov	 rcx, rax
  018ce	0f b7 15 06 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+6
  018d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  018db	48 8b c8	 mov	 rcx, rax
  018de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  018e5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  018ea	48 8b c8	 mov	 rcx, rax
  018ed	0f b7 15 02 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+2
  018f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  018fa	48 8b c8	 mov	 rcx, rax
  018fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01LFCBOECM@?4?$AA@
  01904	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01909	48 8b c8	 mov	 rcx, rax
  0190c	0f b7 15 00 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A
  01913	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01919	48 8b c8	 mov	 rcx, rax
  0191c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@KHLIPMCA@?5o?5godzinie?5?$AA@
  01923	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 579  : 		if (Czas.wHour < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania godzinny je¿eli godzina jest minejsza ni¿ 10 do pliku log_ogólny.txt

  01928	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
  0192f	66 83 fa 0a	 cmp	 dx, 10
  01933	73 16		 jae	 SHORT $LN55@Wczytaj_z_
  01935	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  0193c	48 8b cb	 mov	 rcx, rbx
  0193f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01944	0f b7 15 08 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+8
$LN55@Wczytaj_z_:

; 580  : 		log_ogólny << Czas.wHour << ":";//Wpisanie do bufora zapisu znaku : dla rozdzielenia godzin od minut do pliku log_aktualny.txt

  0194b	48 8b cb	 mov	 rcx, rbx
  0194e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  01954	48 8b c8	 mov	 rcx, rax
  01957	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  0195e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 581  : 		if (Czas.wMinute < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania minut je¿eli minuty jest minejsza ni¿ 10 do pliku log_ogólny.txt

  01963	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
  0196a	66 83 fa 0a	 cmp	 dx, 10
  0196e	73 16		 jae	 SHORT $LN56@Wczytaj_z_
  01970	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  01977	48 8b cb	 mov	 rcx, rbx
  0197a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0197f	0f b7 15 0a 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+10
$LN56@Wczytaj_z_:

; 582  : 		log_ogólny << Czas.wMinute << ":"; //Wpisanie do bufora zapisu znaku : dla rozdzielenia minut od sekund do pliku log_ogólny.txt

  01986	48 8b cb	 mov	 rcx, rbx
  01989	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  0198f	48 8b c8	 mov	 rcx, rax
  01992	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01JLIPDDHJ@?3?$AA@
  01999	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 583  : 		if (Czas.wSecond < 10) log_ogólny << "0"; //Wpisanie do bufora zapisu znaku zera dla równego formatowania sekund je¿eli sekundy jest minejsza ni¿ 10 do pliku log_ogólny.txt

  0199e	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
  019a5	66 83 fa 0a	 cmp	 dx, 10
  019a9	73 16		 jae	 SHORT $LN57@Wczytaj_z_
  019ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01GBGANLPD@0?$AA@
  019b2	48 8b cb	 mov	 rcx, rbx
  019b5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  019ba	0f b7 15 0c 00
	00 00		 movzx	 edx, WORD PTR ?Czas@@3U_SYSTEMTIME@@A+12
$LN57@Wczytaj_z_:

; 584  : 		log_ogólny << Czas.wSecond << endl; // Wpisanie do bufora zapisu danych o sekundzie do pliku log_ogólny.txt

  019c1	48 8b cb	 mov	 rcx, rbx
  019c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z
  019ca	48 8b c8	 mov	 rcx, rax
  019cd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  019d4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 585  : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  019da	49 8b ce	 mov	 rcx, r14
  019dd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 586  : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  019e3	48 8b cb	 mov	 rcx, rbx
  019e6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN33@Wczytaj_z_:

; 587  : 	}
; 588  : }

  019ec	48 8b 4d ef	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-177]
  019f0	48 33 cc	 xor	 rcx, rsp
  019f3	e8 00 00 00 00	 call	 __security_check_cookie
  019f8	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  019ff	41 5f		 pop	 r15
  01a01	41 5e		 pop	 r14
  01a03	41 5d		 pop	 r13
  01a05	41 5c		 pop	 r12
  01a07	5f		 pop	 rdi
  01a08	5e		 pop	 rsi
  01a09	5b		 pop	 rbx
  01a0a	5d		 pop	 rbp
  01a0b	c3		 ret	 0
$LN2932@Wczytaj_z_:
?Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z ENDP ; Wczytaj_z_pliku
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR buf$415[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$0
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$1
  0000c	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR bufor2$416[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$1
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$2
  00018	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$414[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$2
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$3
  00024	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$413[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$3
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$4
  00030	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$412[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$4
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$5
  0003c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$411[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR buf$415[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$1
  0000c	48 8d 8a 80 00
	00 00		 lea	 rcx, QWORD PTR bufor2$416[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$2
  00018	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$414[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$2@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$3
  00024	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$413[rdx]
  0002b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$3@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$4
  00030	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$412[rdx]
  00037	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$4@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
iloœæ_pieniêdzy$GSCopy$1$ = 32
kwota_zak³adu$GSCopy$1$ = 48
$T410 = 56
buf2$411 = 64
buf2$412 = 64
buf2$413 = 64
buf2$414 = 64
buf$415 = 96
bufor2$416 = 128
__$ArrayPad$ = 160
log_ogólny$ = 256
log$ = 264
co_kontynuowaæ$ = 272
iloœæ_pieniêdzy$ = 280
kwota_zak³adu$ = 288
wylosowana_liczba$ = 296
typ_zak³adu$ = 304
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA PROC ; `Wczytaj_z_pliku'::`1'::dtor$5
  0003c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR buf2$411[rdx]
  00043	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??Wczytaj_z_pliku@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAH33AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@@Z@4HA ENDP ; `Wczytaj_z_pliku'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_Pliki@@YAXXZ
_TEXT	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?SprawdŸ_Pliki@@YAXXZ PROC				; SprawdŸ_Pliki, COMDAT

; 591  : {

$LN4429:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	41 56		 push	 r14
  00006	41 57		 push	 r15
  00008	48 8d a8 18 fe
	ff ff		 lea	 rbp, QWORD PTR [rax-488]
  0000f	48 81 ec d0 02
	00 00		 sub	 rsp, 720		; 000002d0H
  00016	48 c7 45 78 fe
	ff ff ff	 mov	 QWORD PTR $T636[rbp-256], -2
  0001e	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  00022	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00026	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0002a	4c 89 60 20	 mov	 QWORD PTR [rax+32], r12
  0002e	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00035	48 33 c4	 xor	 rax, rsp
  00038	48 89 85 c0 01
	00 00		 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  0003f	45 33 e4	 xor	 r12d, r12d
  00042	44 89 64 24 70	 mov	 DWORD PTR $T1[rsp], r12d

; 592  : 	if (efekty_dŸwiêkowe == 1) //Je¿eli w³¹czono efekty dŸwiêkowe

  00047	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?efekty_dŸwiêkowe@@3FA, 1 ; efekty_dŸwiêkowe
  0004f	0f 85 84 02 00
	00		 jne	 $LN31@SprawdŸ_P

; 593  : 	{
; 594  : 		if ((_access("Efekty_dŸwiêkowe", 0))) //SprawdŸ czy nie ma folderu Efekty dŸwiêkowe

  00055	33 d2		 xor	 edx, edx
  00057	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00064	85 c0		 test	 eax, eax
  00066	74 0f		 je	 SHORT $LN14@SprawdŸ_P

; 595  : 		{
; 596  : 			CreateDirectoryA("Efekty_dŸwiêkowe", nullptr); //Je¿eli nie ma to utwórz go

  00068	33 d2		 xor	 edx, edx
  0006a	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@GJELGIOA@Efekty_d?$JPwi?jkowe?$AA@
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
$LN14@SprawdŸ_P:

; 597  : 		}
; 598  : 
; 599  : 		bool czy_pobierano = false; //Utworzenie zmiennej informuj¹c¹ czy rozpoczêto pobieranie plików

  00077	32 db		 xor	 bl, bl

; 600  : 		bool czy_pobrano = true; //Utworzenie zmiennej informuj¹c¹ czy ostatnie pobieranie zakoñczy³o siê sukesem

  00079	40 b7 01	 mov	 dil, 1

; 601  : 
; 602  : 		if ((_access("Efekty_dŸwiêkowe/bankrut.wav", 0))) //Sprawdzenie czy plik nie istnieje

  0007c	33 d2		 xor	 edx, edx
  0007e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00085	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0008b	85 c0		 test	 eax, eax
  0008d	74 76		 je	 SHORT $LN18@SprawdŸ_P

; 603  : 		{
; 604  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o
; 605  : 			{
; 606  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0008f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00096	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0009d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a2	48 8b c8	 mov	 rcx, rax
  000a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 607  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  000b2	40 0f b6 df	 movzx	 ebx, dil

; 608  : 			}
; 609  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/bankrut.wav", "Efekty_dŸwiêkowe/bankrut.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  000b6	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  000bb	45 33 c9	 xor	 r9d, r9d
  000be	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  000c5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FP@HCIMMKGN@https?3?1?1github?4com?1talez2709?1Rul@
  000cc	33 c9		 xor	 ecx, ecx
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 610  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  000d4	85 c0		 test	 eax, eax
  000d6	74 2d		 je	 SHORT $LN18@SprawdŸ_P

; 611  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo
; 612  : 				{
; 613  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false

  000d8	40 32 ff	 xor	 dil, dil

; 614  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  000db	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  000e2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  000e9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ee	48 8b c8	 mov	 rcx, rax
  000f1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000f8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 615  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  000fe	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, dil ; EfektyKompletne
$LN18@SprawdŸ_P:

; 616  : 				}
; 617  : 		}
; 618  : 
; 619  : 		if ((_access("Efekty_dŸwiêkowe/wygrana1.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00105	33 d2		 xor	 edx, edx
  00107	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  0010e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00114	85 c0		 test	 eax, eax
  00116	74 7d		 je	 SHORT $LN22@SprawdŸ_P

; 620  : 		{
; 621  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00118	84 db		 test	 bl, bl
  0011a	75 25		 jne	 SHORT $LN20@SprawdŸ_P

; 622  : 			{
; 623  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0011c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00123	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0012a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0012f	48 8b c8	 mov	 rcx, rax
  00132	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 624  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0013f	b3 01		 mov	 bl, 1
$LN20@SprawdŸ_P:

; 625  : 			}
; 626  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana1.wav", "Efekty_dŸwiêkowe/wygrana1.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00141	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00146	45 33 c9	 xor	 r9d, r9d
  00149	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@OCGMENDH@Efekty_d?$JPwi?jkowe?1wygrana1?4wav?$AA@
  00150	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@GDDMBFNB@https?3?1?1github?4com?1talez2709?1Rul@
  00157	33 c9		 xor	 ecx, ecx
  00159	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 627  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0015f	85 c0		 test	 eax, eax
  00161	74 32		 je	 SHORT $LN22@SprawdŸ_P

; 628  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  00163	40 84 ff	 test	 dil, dil
  00166	74 2d		 je	 SHORT $LN22@SprawdŸ_P

; 629  : 				{
; 630  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false

  00168	40 32 ff	 xor	 dil, dil

; 631  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  0016b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  00172	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00179	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0017e	48 8b c8	 mov	 rcx, rax
  00181	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 632  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  0018e	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, dil ; EfektyKompletne
$LN22@SprawdŸ_P:

; 633  : 				}
; 634  : 		}
; 635  : 
; 636  : 		if ((_access("Efekty_dŸwiêkowe/wygrana2.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00195	33 d2		 xor	 edx, edx
  00197	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  0019e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  001a4	85 c0		 test	 eax, eax
  001a6	74 7d		 je	 SHORT $LN26@SprawdŸ_P

; 637  : 		{
; 638  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  001a8	84 db		 test	 bl, bl
  001aa	75 25		 jne	 SHORT $LN24@SprawdŸ_P

; 639  : 			{
; 640  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  001ac	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  001b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001ba	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001bf	48 8b c8	 mov	 rcx, rax
  001c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  001c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 641  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  001cf	b3 01		 mov	 bl, 1
$LN24@SprawdŸ_P:

; 642  : 			}
; 643  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/wygrana2.wav", "Efekty_dŸwiêkowe/wygrana2.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  001d1	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  001d6	45 33 c9	 xor	 r9d, r9d
  001d9	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@
  001e0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GA@OFKIGHHP@https?3?1?1github?4com?1talez2709?1Rul@
  001e7	33 c9		 xor	 ecx, ecx
  001e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 644  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  001ef	85 c0		 test	 eax, eax
  001f1	74 32		 je	 SHORT $LN26@SprawdŸ_P

; 645  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  001f3	40 84 ff	 test	 dil, dil
  001f6	74 2d		 je	 SHORT $LN26@SprawdŸ_P

; 646  : 				{
; 647  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false

  001f8	40 32 ff	 xor	 dil, dil

; 648  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  001fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  00202	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00209	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0020e	48 8b c8	 mov	 rcx, rax
  00211	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00218	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 649  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  0021e	40 88 3d 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, dil ; EfektyKompletne
$LN26@SprawdŸ_P:

; 650  : 				}
; 651  : 		}
; 652  : 
; 653  : 		if ((_access("Efekty_dŸwiêkowe/zwielokrotnenie.wav", 0))) //Sprawdzenie czy plik nie istnieje

  00225	33 d2		 xor	 edx, edx
  00227	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  0022e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00234	85 c0		 test	 eax, eax
  00236	74 7a		 je	 SHORT $LN30@SprawdŸ_P

; 654  : 		{
; 655  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00238	84 db		 test	 bl, bl
  0023a	75 25		 jne	 SHORT $LN28@SprawdŸ_P

; 656  : 			{
; 657  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików efektów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0023c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@DNDHBNPK@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00243	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0024a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0024f	48 8b c8	 mov	 rcx, rax
  00252	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00259	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 658  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0025f	b3 01		 mov	 bl, 1
$LN28@SprawdŸ_P:

; 659  : 			}
; 660  : 			auto res = URLDownloadToFileA(nullptr, "https://github.com/talez2709/Ruletka/raw/master/Ruletka/Efekty_d%C5%BAwi%C4%99kowe/zwielokrotnenie.wav", "Efekty_dŸwiêkowe/zwielokrotnenie.wav", 0, nullptr); //Rozpoczêcie pobierania pliku

  00261	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00266	45 33 c9	 xor	 r9d, r9d
  00269	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
  00270	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GH@BAJDCEKO@https?3?1?1github?4com?1talez2709?1Rul@
  00277	33 c9		 xor	 ecx, ecx
  00279	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA

; 661  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  0027f	85 c0		 test	 eax, eax
  00281	74 2f		 je	 SHORT $LN30@SprawdŸ_P

; 662  : 				if (czy_pobrano) //Je¿eli ostatnie pobieranie zakoñczono prawid³owo

  00283	40 84 ff	 test	 dil, dil
  00286	74 2a		 je	 SHORT $LN30@SprawdŸ_P

; 663  : 				{
; 664  : 					czy_pobrano = false; //Ustawienie zmiennej informuj¹cej o sukcesie pobierania na wartoœæ false
; 665  : 					cout << "Brak plików dla efektów dŸwiêkowych oraz nie mo¿na pobraæ danych, wy³¹czono efekty dŸwiêkowe muzyczne, w³¹czono efekty systemowe" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  00288	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0IB@GKCCNHLI@Brak?5plik?sw?5dla?5efekt?sw?5d?$JPwi?jkow@
  0028f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00296	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0029b	48 8b c8	 mov	 rcx, rax
  0029e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 666  : 					EfektyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  002ab	44 88 25 00 00
	00 00		 mov	 BYTE PTR ?EfektyKompletne@@3_NA, r12b ; EfektyKompletne
$LN30@SprawdŸ_P:

; 667  : 				}
; 668  : 		}
; 669  : 
; 670  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki efektów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  002b2	84 db		 test	 bl, bl
  002b4	74 23		 je	 SHORT $LN31@SprawdŸ_P
  002b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@KILAJOJF@Pobrano?5brakuj?$LJce?5pliki?5efekt?sw?$AA@
  002bd	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002c4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002c9	48 8b c8	 mov	 rcx, rax
  002cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN31@SprawdŸ_P:

; 671  : 	}
; 672  : 
; 673  : 	if (g³os_odczytu_numeru > 0) //Je¿eli w³¹czono odczyt g³osowy

  002d9	66 44 39 25 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, r12w ; g³os_odczytu_numeru
  002e1	0f 8e 17 1e 00
	00		 jle	 $LN32@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2435 : 		if (_Count <= _My_data._Myres)

  002e7	48 8b 05 18 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24

; 1595 : 		value_type * _Result = _Bx._Buf;

  002ee	48 8d 3d 00 00
	00 00		 lea	 rdi, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2435 : 		if (_Count <= _My_data._Myres)

  002f5	48 83 f8 05	 cmp	 rax, 5
  002f9	72 36		 jb	 SHORT $LN164@SprawdŸ_P

; 1596 : 		if (_Large_string_engaged())

  002fb	48 8b df	 mov	 rbx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002fe	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00302	48 0f 43 1d 00
	00 00 00	 cmovae	 rbx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2438 : 			_My_data._Mysize = _Count;

  0030a	48 c7 05 10 00
	00 00 05 00 00
	00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00315	41 b8 05 00 00
	00		 mov	 r8d, 5
  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00322	48 8b cb	 mov	 rcx, rbx
  00325	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0032b	44 88 63 05	 mov	 BYTE PTR [rbx+5], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  0032f	eb 14		 jmp	 SHORT $LN163@SprawdŸ_P
$LN164@SprawdŸ_P:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00331	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00338	ba 05 00 00 00	 mov	 edx, 5
  0033d	48 8b cf	 mov	 rcx, rdi
  00340	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
$LN163@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 677  : 		switch (g³os_odczytu_numeru) //U¿ycie warunku wielokrotnego wyboru do wpisania odpowiedniej nazwy g³osu do zmiennej g³os_nazwa

  00345	0f bf 05 00 00
	00 00		 movsx	 eax, WORD PTR ?g³os_odczytu_numeru@@3FA ; g³os_odczytu_numeru
  0034c	ff c8		 dec	 eax
  0034e	83 f8 08	 cmp	 eax, 8
  00351	0f 87 96 00 00
	00		 ja	 $LN42@SprawdŸ_P
  00357	48 98		 cdqe
  00359	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:__ImageBase
  00360	8b 8c 82 00 00
	00 00		 mov	 ecx, DWORD PTR $LN4424@SprawdŸ_P[rdx+rax*4]
  00367	48 03 ca	 add	 rcx, rdx
  0036a	ff e1		 jmp	 rcx
$LN33@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0036c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KFCKMKOB@Jacek?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 682  : 			break; //Wyjœcie z instrukcji case //Wyjœcie z instrukcji case

  00373	eb 6a		 jmp	 SHORT $LN4426@SprawdŸ_P
$LN34@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00375	41 b8 03 00 00
	00		 mov	 r8d, 3
  0037b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03FPCJKMNP@Ewa?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 687  : 			break; //Wyjœcie z instrukcji case

  00382	eb 61		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN35@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00384	41 b8 04 00 00
	00		 mov	 r8d, 4
  0038a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04CDICBAGM@Maja?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 692  : 			break; //Wyjœcie z instrukcji case

  00391	eb 52		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN36@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00393	41 b8 03 00 00
	00		 mov	 r8d, 3
  00399	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_03JIHJHPIE@Jan?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 697  : 			break; //Wyjœcie z instrukcji case

  003a0	eb 43		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN37@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003a2	41 b8 06 00 00
	00		 mov	 r8d, 6
  003a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_06DKNIKMFF@Jacek2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 702  : 			break; //Wyjœcie z instrukcji case

  003af	eb 34		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN38@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003b1	41 b8 04 00 00
	00		 mov	 r8d, 4
  003b7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04PLEDLCJI@Ewa2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 708  : 			break; //Wyjœcie z instrukcji case

  003be	eb 25		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN39@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05KJFHPLBC@Maja2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 713  : 			break; //Wyjœcie z instrukcji case

  003c7	eb 16		 jmp	 SHORT $LN4426@SprawdŸ_P
$LN40@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003c9	41 b8 04 00 00
	00		 mov	 r8d, 4
  003cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_04HDNGKDH@Jan2?$AA@
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 718  : 			break; //Wyjœcie z instrukcji case

  003d6	eb 0d		 jmp	 SHORT $LN4427@SprawdŸ_P
$LN41@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  003d8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05NKPCGME@Agata?$AA@
$LN4426@SprawdŸ_P:
  003df	41 b8 05 00 00
	00		 mov	 r8d, 5
$LN4427@SprawdŸ_P:
  003e5	48 8b cf	 mov	 rcx, rdi
  003e8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN42@SprawdŸ_P:
  003ed	41 bf 01 00 00
	00		 mov	 r15d, 1
  003f3	45 8b c7	 mov	 r8d, r15d
  003f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01IDAFKMJL@_?$AA@
  003fd	48 8b cf	 mov	 rcx, rdi
  00400	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 730  : 		G³os += '0' + g³os_szybkoœæ_odczytu_numeru; //Dodanie do zmiennej szybkoœci mowy

  00405	44 0f b6 0d 00
	00 00 00	 movzx	 r9d, BYTE PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA
  0040d	41 80 c1 30	 add	 r9b, 48			; 00000030H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00411	48 8b 0d 10 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2992 : 		if (_Old_size < _My_data._Myres)

  00418	48 8b 15 18 00
	00 00		 mov	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0041f	48 3b ca	 cmp	 rcx, rdx
  00422	73 25		 jae	 SHORT $LN278@SprawdŸ_P

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00424	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00428	48 89 05 10 00
	00 00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, rax

; 1596 : 		if (_Large_string_engaged())

  0042f	48 8b c7	 mov	 rax, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00432	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  00436	48 0f 43 05 00
	00 00 00	 cmovae	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0043e	44 88 0c 08	 mov	 BYTE PTR [rax+rcx], r9b
  00442	44 88 64 08 01	 mov	 BYTE PTR [rax+rcx+1], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00447	eb 08		 jmp	 SHORT $LN277@SprawdŸ_P
$LN278@SprawdŸ_P:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00449	48 8b cf	 mov	 rcx, rdi
  0044c	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN277@SprawdŸ_P:

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00451	4d 8b c7	 mov	 r8, r15
  00454	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01KMDKNFGN@?1?$AA@
  0045b	48 8b cf	 mov	 rcx, rdi
  0045e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3698 : 		_My_data._Mysize = 0;

  00463	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0046b	f3 0f 7f 85 b0
	00 00 00	 movdqu	 XMMWORD PTR link$638[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00473	44 88 a5 a0 00
	00 00		 mov	 BYTE PTR link$638[rbp-256], r12b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0047a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_0ED@KNLDKMLM@https?3?1?1github?4com?1talez2709?1Rul@
  00481	ba 42 00 00 00	 mov	 edx, 66			; 00000042H
  00486	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR link$638[rbp-256]
  0048d	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  00492	90		 npad	 1

; 3698 : 		_My_data._Mysize = 0;

  00493	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0049b	f3 0f 7f 85 90
	00 00 00	 movdqu	 XMMWORD PTR g³os2$637[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  004a3	c6 85 80 00 00
	00 00		 mov	 BYTE PTR g³os2$637[rbp-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  004aa	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  004b1	48 83 f8 05	 cmp	 rax, 5
  004b5	73 06		 jae	 SHORT $LN400@SprawdŸ_P

; 1623 : 			{
; 1624 : 			_Xran();

  004b7	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  004bc	cc		 int	 3
$LN400@SprawdŸ_P:

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  004bd	48 83 c0 fb	 add	 rax, -5
  004c1	48 83 cb ff	 or	 rbx, -1
  004c5	48 3b c3	 cmp	 rax, rbx
  004c8	48 0f 42 d8	 cmovb	 rbx, rax

; 1607 : 		if (_Large_string_engaged())

  004cc	4c 8b cf	 mov	 r9, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  004cf	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  004d7	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  004df	49 83 c1 05	 add	 r9, 5
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  004e3	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR g³os2$637[rbp-256]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2435 : 		if (_Count <= _My_data._Myres)

  004ea	48 83 fb 0f	 cmp	 rbx, 15
  004ee	77 1d		 ja	 SHORT $LN417@SprawdŸ_P

; 2436 : 			{
; 2437 : 			_Elem * const _Old_ptr = _My_data._Myptr();
; 2438 : 			_My_data._Mysize = _Count;

  004f0	48 89 9d 90 00
	00 00		 mov	 QWORD PTR g³os2$637[rbp-240], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  004f7	4c 8b c3	 mov	 r8, rbx
  004fa	49 8b d1	 mov	 rdx, r9
  004fd	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00503	c6 84 1d 80 00
	00 00 00	 mov	 BYTE PTR g³os2$637[rbp+rbx-256], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  0050b	eb 09		 jmp	 SHORT $LN416@SprawdŸ_P
$LN417@SprawdŸ_P:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0050d	48 8b d3	 mov	 rdx, rbx
  00510	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  00515	90		 npad	 1
$LN416@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 737  : 		if ((_access("G³os", 0))) //SprawdŸ czy nie ma folderu G³os

  00516	33 d2		 xor	 edx, edx
  00518	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04JLFAMLOH@G?$LDos?$AA@
  0051f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00525	85 c0		 test	 eax, eax
  00527	74 0f		 je	 SHORT $LN43@SprawdŸ_P

; 738  : 		{
; 739  : 			CreateDirectoryA("G³os", nullptr); //Je¿eli nie ma to utwórz go

  00529	33 d2		 xor	 edx, edx
  0052b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_04JLFAMLOH@G?$LDos?$AA@
  00532	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
$LN43@SprawdŸ_P:

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  00538	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  0053f	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T42[rsp]
  00544	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00549	48 83 78 18 10	 cmp	 QWORD PTR [rax+24], 16

; 1607 : 		if (_Large_string_engaged())

  0054e	72 03		 jb	 SHORT $LN451@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00550	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN451@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  00553	33 d2		 xor	 edx, edx
  00555	48 8b c8	 mov	 rcx, rax
  00558	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0055e	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00560	48 8b 4d 90	 mov	 rcx, QWORD PTR $T42[rbp-232]
  00564	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00568	72 40		 jb	 SHORT $LN484@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0056a	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0056d	48 8b 54 24 78	 mov	 rdx, QWORD PTR $T42[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00572	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00579	72 27		 jb	 SHORT $LN487@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0057b	f6 c2 1f	 test	 dl, 31
  0057e	75 1b		 jne	 SHORT $_Invalid_parameter$4430

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00580	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00584	48 3b c2	 cmp	 rax, rdx
  00587	73 12		 jae	 SHORT $_Invalid_parameter$4430
  00589	48 2b d0	 sub	 rdx, rax
  0058c	48 83 ea 08	 sub	 rdx, 8
  00590	48 83 fa 1f	 cmp	 rdx, 31
  00594	77 05		 ja	 SHORT $_Invalid_parameter$4430

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00596	48 8b d0	 mov	 rdx, rax
  00599	eb 07		 jmp	 SHORT $LN487@SprawdŸ_P
$_Invalid_parameter$4430:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0059b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  005a1	cc		 int	 3
$LN487@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  005a2	48 8b ca	 mov	 rcx, rdx
  005a5	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN484@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 741  : 		if ((_access(("G³os/" + g³os2).c_str(), 0))) //SprawdŸ czy nie ma w folderze G³os podfolderu z nazw¹ i szybkoœci¹ g³osu

  005aa	85 db		 test	 ebx, ebx
  005ac	74 6c		 je	 SHORT $LN546@SprawdŸ_P

; 743  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  005ae	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  005b5	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T52[rsp]
  005ba	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005bf	48 83 78 18 10	 cmp	 QWORD PTR [rax+24], 16

; 1607 : 		if (_Large_string_engaged())

  005c4	72 03		 jb	 SHORT $LN513@SprawdŸ_P
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
$LN513@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 743  : 			CreateDirectoryA(("G³os/" + g³os2).c_str(), nullptr); //Je¿eli nie ma to utwórz go

  005c9	33 d2		 xor	 edx, edx
  005cb	48 8b c8	 mov	 rcx, rax
  005ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_CreateDirectoryA
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005d4	48 8b 45 90	 mov	 rax, QWORD PTR $T52[rbp-232]
  005d8	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  005dc	72 3c		 jb	 SHORT $LN546@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  005de	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  005e1	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T52[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  005e6	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  005ec	72 27		 jb	 SHORT $LN549@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  005ee	f6 c1 1f	 test	 cl, 31
  005f1	75 1b		 jne	 SHORT $_Invalid_parameter$4431

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  005f3	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  005f7	48 3b c1	 cmp	 rax, rcx
  005fa	73 12		 jae	 SHORT $_Invalid_parameter$4431
  005fc	48 2b c8	 sub	 rcx, rax
  005ff	48 83 e9 08	 sub	 rcx, 8
  00603	48 83 f9 1f	 cmp	 rcx, 31
  00607	77 05		 ja	 SHORT $_Invalid_parameter$4431

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00609	48 8b c8	 mov	 rcx, rax
  0060c	eb 07		 jmp	 SHORT $LN549@SprawdŸ_P
$_Invalid_parameter$4431:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0060e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00614	cc		 int	 3
$LN549@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00615	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN546@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 746  : 		bool czy_pobierano = false; //Utworzenie zmiennej logicznej informuj¹cej czy jakieœ pobieranie siê rozpocze³o

  0061a	40 32 f6	 xor	 sil, sil
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0061d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00625	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T61[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0062b	40 88 74 24 30	 mov	 BYTE PTR $T61[rsp], sil
  00630	c7 44 24 70 03
	00 00 00	 mov	 DWORD PTR $T1[rsp], 3
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00638	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0063f	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  00643	48 83 fa 10	 cmp	 rdx, 16
  00647	72 16		 jb	 SHORT $LN609@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00649	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T61[rsp]
  0064e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00653	4c 89 64 24 40	 mov	 QWORD PTR $T61[rsp+16], r12
  00658	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN609@SprawdŸ_P:

; 1607 : 		if (_Large_string_engaged())

  0065f	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00662	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  0066a	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00672	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T61[rsp]
  00677	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0067c	41 b8 05 00 00
	00		 mov	 r8d, 5
  00682	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  00689	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T61[rsp]
  0068e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00693	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T61[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00698	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T61[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  0069e	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T61[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006a4	33 d2		 xor	 edx, edx
  006a6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  006ac	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006ae	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T61[rsp+24]
  006b3	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  006b7	72 40		 jb	 SHORT $LN735@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  006b9	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  006bc	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T61[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  006c1	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  006c8	72 27		 jb	 SHORT $LN738@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  006ca	f6 c2 1f	 test	 dl, 31
  006cd	75 1b		 jne	 SHORT $_Invalid_parameter$4432

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  006cf	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  006d3	48 3b c2	 cmp	 rax, rdx
  006d6	73 12		 jae	 SHORT $_Invalid_parameter$4432
  006d8	48 2b d0	 sub	 rdx, rax
  006db	48 83 ea 08	 sub	 rdx, 8
  006df	48 83 fa 1f	 cmp	 rdx, 31
  006e3	77 05		 ja	 SHORT $_Invalid_parameter$4432

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  006e5	48 8b d0	 mov	 rdx, rax
  006e8	eb 07		 jmp	 SHORT $LN738@SprawdŸ_P
$_Invalid_parameter$4432:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  006ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  006f0	cc		 int	 3
$LN738@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  006f1	48 8b ca	 mov	 rcx, rdx
  006f4	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN735@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  006f9	45 8b f7	 mov	 r14d, r15d
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 748  : 		if ((_access((G³os + "p.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  006fc	85 db		 test	 ebx, ebx
  006fe	0f 84 64 02 00
	00		 je	 $LN47@SprawdŸ_P

; 749  : 		{
; 750  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o
; 751  : 			{
; 752  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00704	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  0070b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00712	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00717	48 8b c8	 mov	 rcx, rax
  0071a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00721	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 753  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00727	41 0f b6 f6	 movzx	 esi, r14b

; 755  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0072b	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00732	48 8d 4d 98	 lea	 rcx, QWORD PTR $T85[rbp-256]
  00736	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0073b	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0073c	41 b8 05 00 00
	00		 mov	 r8d, 5
  00742	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  00749	48 8b c8	 mov	 rcx, rax
  0074c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00751	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00754	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T94[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0075a	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0075d	0f 11 44 24 50	 movups	 XMMWORD PTR $T94[rsp], xmm0
  00762	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00766	0f 11 4c 24 60	 movups	 XMMWORD PTR $T94[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  0076b	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0076f	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00777	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 755  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0077a	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00781	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  00788	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T103[rsp]
  0078d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00792	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00793	41 b8 05 00 00
	00		 mov	 r8d, 5
  00799	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05PNHGCFLK@p?4wav?$AA@
  007a0	48 8b c8	 mov	 rcx, rax
  007a3	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  007a8	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  007ab	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T112[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  007b1	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  007b4	0f 11 44 24 30	 movups	 XMMWORD PTR $T112[rsp], xmm0
  007b9	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  007bd	0f 11 4c 24 40	 movups	 XMMWORD PTR $T112[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  007c2	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  007c6	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  007ce	c6 00 00	 mov	 BYTE PTR [rax], 0
  007d1	41 be 0d 00 00
	00		 mov	 r14d, 13
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007d7	4c 8d 44 24 50	 lea	 r8, QWORD PTR $T94[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007dc	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T94[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  007e2	4c 0f 43 44 24
	50		 cmovae	 r8, QWORD PTR $T94[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007e8	48 8d 54 24 30	 lea	 rdx, QWORD PTR $T112[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007ed	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T112[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  007f3	48 0f 43 54 24
	30		 cmovae	 rdx, QWORD PTR $T112[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 755  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "p.wav").c_str(), ("G³os/" + g³os2 + "p.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  007f9	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  007fe	45 33 c9	 xor	 r9d, r9d
  00801	33 c9		 xor	 ecx, ecx
  00803	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  00809	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0080b	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T112[rsp+24]
  00810	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00814	72 40		 jb	 SHORT $LN957@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00816	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00819	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T112[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0081e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00825	72 27		 jb	 SHORT $LN960@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00827	f6 c2 1f	 test	 dl, 31
  0082a	75 1b		 jne	 SHORT $_Invalid_parameter$4433

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0082c	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00830	48 3b c2	 cmp	 rax, rdx
  00833	73 12		 jae	 SHORT $_Invalid_parameter$4433
  00835	48 2b d0	 sub	 rdx, rax
  00838	48 83 ea 08	 sub	 rdx, 8
  0083c	48 83 fa 1f	 cmp	 rdx, 31
  00840	77 05		 ja	 SHORT $_Invalid_parameter$4433

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00842	48 8b d0	 mov	 rdx, rax
  00845	eb 07		 jmp	 SHORT $LN960@SprawdŸ_P
$_Invalid_parameter$4433:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00847	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0084d	cc		 int	 3
$LN960@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0084e	48 8b ca	 mov	 rcx, rdx
  00851	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN957@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00856	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0085e	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T112[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00864	c6 44 24 30 00	 mov	 BYTE PTR $T112[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00869	48 8b 45 90	 mov	 rax, QWORD PTR $T103[rbp-232]
  0086d	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00871	72 3c		 jb	 SHORT $LN1003@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00873	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00876	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T103[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0087b	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00881	72 27		 jb	 SHORT $LN1006@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00883	f6 c1 1f	 test	 cl, 31
  00886	75 1b		 jne	 SHORT $_Invalid_parameter$4434

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00888	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0088c	48 3b c1	 cmp	 rax, rcx
  0088f	73 12		 jae	 SHORT $_Invalid_parameter$4434
  00891	48 2b c8	 sub	 rcx, rax
  00894	48 83 e9 08	 sub	 rcx, 8
  00898	48 83 f9 1f	 cmp	 rcx, 31
  0089c	77 05		 ja	 SHORT $_Invalid_parameter$4434

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0089e	48 8b c8	 mov	 rcx, rax
  008a1	eb 07		 jmp	 SHORT $LN1006@SprawdŸ_P
$_Invalid_parameter$4434:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  008a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  008a9	cc		 int	 3
$LN1006@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  008aa	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1003@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  008af	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  008b7	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T103[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  008bc	c6 44 24 78 00	 mov	 BYTE PTR $T103[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008c1	48 8b 44 24 68	 mov	 rax, QWORD PTR $T94[rsp+24]
  008c6	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  008ca	72 3c		 jb	 SHORT $LN1049@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  008cc	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  008cf	48 8b 4c 24 50	 mov	 rcx, QWORD PTR $T94[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  008d4	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  008da	72 27		 jb	 SHORT $LN1052@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  008dc	f6 c1 1f	 test	 cl, 31
  008df	75 1b		 jne	 SHORT $_Invalid_parameter$4435

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  008e1	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  008e5	48 3b c1	 cmp	 rax, rcx
  008e8	73 12		 jae	 SHORT $_Invalid_parameter$4435
  008ea	48 2b c8	 sub	 rcx, rax
  008ed	48 83 e9 08	 sub	 rcx, 8
  008f1	48 83 f9 1f	 cmp	 rcx, 31
  008f5	77 05		 ja	 SHORT $_Invalid_parameter$4435

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  008f7	48 8b c8	 mov	 rcx, rax
  008fa	eb 07		 jmp	 SHORT $LN1052@SprawdŸ_P
$_Invalid_parameter$4435:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  008fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00902	cc		 int	 3
$LN1052@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00903	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1049@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00908	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00910	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T94[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00916	c6 44 24 50 00	 mov	 BYTE PTR $T94[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0091b	48 8b 45 b0	 mov	 rax, QWORD PTR $T85[rbp-232]
  0091f	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00923	72 3b		 jb	 SHORT $LN1095@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00925	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00928	48 8b 4d 98	 mov	 rcx, QWORD PTR $T85[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0092c	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00932	72 27		 jb	 SHORT $LN1098@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00934	f6 c1 1f	 test	 cl, 31
  00937	75 1b		 jne	 SHORT $_Invalid_parameter$4436

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00939	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0093d	48 3b c1	 cmp	 rax, rcx
  00940	73 12		 jae	 SHORT $_Invalid_parameter$4436
  00942	48 2b c8	 sub	 rcx, rax
  00945	48 83 e9 08	 sub	 rcx, 8
  00949	48 83 f9 1f	 cmp	 rcx, 31
  0094d	77 05		 ja	 SHORT $_Invalid_parameter$4436

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0094f	48 8b c8	 mov	 rcx, rax
  00952	eb 07		 jmp	 SHORT $LN1098@SprawdŸ_P
$_Invalid_parameter$4436:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00954	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0095a	cc		 int	 3
$LN1098@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0095b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1095@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 756  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00960	85 db		 test	 ebx, ebx
  00962	0f 85 68 12 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN47@SprawdŸ_P:

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00968	41 8b de	 mov	 ebx, r14d
$_Invalid_parameter$4437:
$_Invalid_parameter$4438:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0096b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00973	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T151[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00979	c6 44 24 30 00	 mov	 BYTE PTR $T151[rsp], 0
  0097e	41 83 ce 10	 or	 r14d, 16
  00982	44 89 74 24 70	 mov	 DWORD PTR $T1[rsp], r14d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00987	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0098e	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  00992	48 83 fa 10	 cmp	 rdx, 16
  00996	72 16		 jb	 SHORT $LN1250@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00998	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T151[rsp]
  0099d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  009a2	4c 89 64 24 40	 mov	 QWORD PTR $T151[rsp+16], r12
  009a7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1250@SprawdŸ_P:

; 1607 : 		if (_Large_string_engaged())

  009ae	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009b1	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  009b9	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  009c1	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T151[rsp]
  009c6	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  009cb	41 b8 05 00 00
	00		 mov	 r8d, 5
  009d1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  009d8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T151[rsp]
  009dd	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  009e2	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T151[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009e7	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T151[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  009ed	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T151[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  009f3	33 d2		 xor	 edx, edx
  009f5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  009fb	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009fe	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T151[rsp+24]
  00a03	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00a07	72 40		 jb	 SHORT $LN1376@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00a09	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00a0c	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T151[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00a11	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00a18	72 27		 jb	 SHORT $LN1379@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00a1a	f6 c2 1f	 test	 dl, 31
  00a1d	75 1b		 jne	 SHORT $_Invalid_parameter$4439

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00a1f	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00a23	48 3b c2	 cmp	 rax, rdx
  00a26	73 12		 jae	 SHORT $_Invalid_parameter$4439
  00a28	48 2b d0	 sub	 rdx, rax
  00a2b	48 83 ea 08	 sub	 rdx, 8
  00a2f	48 83 fa 1f	 cmp	 rdx, 31
  00a33	77 05		 ja	 SHORT $_Invalid_parameter$4439

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00a35	48 8b d0	 mov	 rdx, rax
  00a38	eb 07		 jmp	 SHORT $LN1379@SprawdŸ_P
$_Invalid_parameter$4439:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00a3a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00a40	cc		 int	 3
$LN1379@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00a41	48 8b ca	 mov	 rcx, rdx
  00a44	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1376@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 764  : 		if ((_access((G³os + "n.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00a49	45 85 f6	 test	 r14d, r14d
  00a4c	0f 84 67 02 00
	00		 je	 $LN50@SprawdŸ_P

; 765  : 		{
; 766  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00a52	40 84 f6	 test	 sil, sil
  00a55	75 26		 jne	 SHORT $LN49@SprawdŸ_P

; 767  : 			{
; 768  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00a57	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00a5e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00a65	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00a6a	48 8b c8	 mov	 rcx, rax
  00a6d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00a74	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 769  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00a7a	40 b6 01	 mov	 sil, 1
$LN49@SprawdŸ_P:

; 771  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00a7d	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00a84	48 8d 4d 98	 lea	 rcx, QWORD PTR $T175[rbp-256]
  00a88	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00a8d	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00a8e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00a94	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00a9b	48 8b c8	 mov	 rcx, rax
  00a9e	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00aa3	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00aa6	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T184[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00aac	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00aaf	0f 11 44 24 30	 movups	 XMMWORD PTR $T184[rsp], xmm0
  00ab4	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00ab8	0f 11 4c 24 40	 movups	 XMMWORD PTR $T184[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00abd	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00ac1	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00ac9	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 771  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00acc	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00ad3	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  00ada	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T193[rsp]
  00adf	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ae4	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ae5	41 b8 05 00 00
	00		 mov	 r8d, 5
  00aeb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05MEKKEGFB@n?4wav?$AA@
  00af2	48 8b c8	 mov	 rcx, rax
  00af5	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00afa	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00afd	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T202[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00b03	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00b06	0f 11 44 24 50	 movups	 XMMWORD PTR $T202[rsp], xmm0
  00b0b	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00b0f	0f 11 4c 24 60	 movups	 XMMWORD PTR $T202[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00b14	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00b18	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00b20	c6 00 00	 mov	 BYTE PTR [rax], 0
  00b23	83 cb 60	 or	 ebx, 96			; 00000060H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00b26	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T184[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b2b	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T184[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00b31	4c 0f 43 44 24
	30		 cmovae	 r8, QWORD PTR $T184[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00b37	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T202[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b3c	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T202[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00b42	48 0f 43 54 24
	50		 cmovae	 rdx, QWORD PTR $T202[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 771  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "n.wav").c_str(), ("G³os/" + g³os2 + "n.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00b48	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00b4d	45 33 c9	 xor	 r9d, r9d
  00b50	33 c9		 xor	 ecx, ecx
  00b52	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  00b58	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b5b	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T202[rsp+24]
  00b60	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00b64	72 40		 jb	 SHORT $LN1598@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00b66	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00b69	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T202[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00b6e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00b75	72 27		 jb	 SHORT $LN1601@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00b77	f6 c2 1f	 test	 dl, 31
  00b7a	75 1b		 jne	 SHORT $_Invalid_parameter$4440

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00b7c	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00b80	48 3b c2	 cmp	 rax, rdx
  00b83	73 12		 jae	 SHORT $_Invalid_parameter$4440
  00b85	48 2b d0	 sub	 rdx, rax
  00b88	48 83 ea 08	 sub	 rdx, 8
  00b8c	48 83 fa 1f	 cmp	 rdx, 31
  00b90	77 05		 ja	 SHORT $_Invalid_parameter$4440

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00b92	48 8b d0	 mov	 rdx, rax
  00b95	eb 07		 jmp	 SHORT $LN1601@SprawdŸ_P
$_Invalid_parameter$4440:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00b97	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00b9d	cc		 int	 3
$LN1601@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00b9e	48 8b ca	 mov	 rcx, rdx
  00ba1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1598@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00ba6	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00bae	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T202[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00bb4	c6 44 24 50 00	 mov	 BYTE PTR $T202[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bb9	48 8b 45 90	 mov	 rax, QWORD PTR $T193[rbp-232]
  00bbd	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00bc1	72 3c		 jb	 SHORT $LN1644@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00bc3	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00bc6	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T193[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00bcb	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00bd1	72 27		 jb	 SHORT $LN1647@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00bd3	f6 c1 1f	 test	 cl, 31
  00bd6	75 1b		 jne	 SHORT $_Invalid_parameter$4441

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00bd8	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00bdc	48 3b c1	 cmp	 rax, rcx
  00bdf	73 12		 jae	 SHORT $_Invalid_parameter$4441
  00be1	48 2b c8	 sub	 rcx, rax
  00be4	48 83 e9 08	 sub	 rcx, 8
  00be8	48 83 f9 1f	 cmp	 rcx, 31
  00bec	77 05		 ja	 SHORT $_Invalid_parameter$4441

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00bee	48 8b c8	 mov	 rcx, rax
  00bf1	eb 07		 jmp	 SHORT $LN1647@SprawdŸ_P
$_Invalid_parameter$4441:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00bf3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00bf9	cc		 int	 3
$LN1647@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00bfa	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1644@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00bff	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00c07	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T193[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00c0c	c6 44 24 78 00	 mov	 BYTE PTR $T193[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c11	48 8b 44 24 48	 mov	 rax, QWORD PTR $T184[rsp+24]
  00c16	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00c1a	72 3c		 jb	 SHORT $LN1690@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c1c	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00c1f	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T184[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00c24	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00c2a	72 27		 jb	 SHORT $LN1693@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00c2c	f6 c1 1f	 test	 cl, 31
  00c2f	75 1b		 jne	 SHORT $_Invalid_parameter$4442

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c31	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00c35	48 3b c1	 cmp	 rax, rcx
  00c38	73 12		 jae	 SHORT $_Invalid_parameter$4442
  00c3a	48 2b c8	 sub	 rcx, rax
  00c3d	48 83 e9 08	 sub	 rcx, 8
  00c41	48 83 f9 1f	 cmp	 rcx, 31
  00c45	77 05		 ja	 SHORT $_Invalid_parameter$4442

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00c47	48 8b c8	 mov	 rcx, rax
  00c4a	eb 07		 jmp	 SHORT $LN1693@SprawdŸ_P
$_Invalid_parameter$4442:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00c4c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00c52	cc		 int	 3
$LN1693@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00c53	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1690@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00c58	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00c60	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T184[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00c66	c6 44 24 30 00	 mov	 BYTE PTR $T184[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c6b	48 8b 45 b0	 mov	 rax, QWORD PTR $T175[rbp-232]
  00c6f	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00c73	72 3b		 jb	 SHORT $LN1736@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00c75	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00c78	48 8b 4d 98	 mov	 rcx, QWORD PTR $T175[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00c7c	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00c82	72 27		 jb	 SHORT $LN1739@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00c84	f6 c1 1f	 test	 cl, 31
  00c87	75 1b		 jne	 SHORT $_Invalid_parameter$4443

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00c89	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00c8d	48 3b c1	 cmp	 rax, rcx
  00c90	73 12		 jae	 SHORT $_Invalid_parameter$4443
  00c92	48 2b c8	 sub	 rcx, rax
  00c95	48 83 e9 08	 sub	 rcx, 8
  00c99	48 83 f9 1f	 cmp	 rcx, 31
  00c9d	77 05		 ja	 SHORT $_Invalid_parameter$4443

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00c9f	48 8b c8	 mov	 rcx, rax
  00ca2	eb 07		 jmp	 SHORT $LN1739@SprawdŸ_P
$_Invalid_parameter$4443:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ca4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00caa	cc		 int	 3
$LN1739@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00cab	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN1736@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 772  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  00cb0	45 85 f6	 test	 r14d, r14d
  00cb3	0f 85 17 0f 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN50@SprawdŸ_P:

; 780  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00cb9	44 8b f3	 mov	 r14d, ebx
$_Invalid_parameter$4444:
$_Invalid_parameter$4445:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00cbc	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00cc4	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T241[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00cca	c6 44 24 30 00	 mov	 BYTE PTR $T241[rsp], 0
  00ccf	0f ba eb 07	 bts	 ebx, 7
  00cd3	89 5c 24 70	 mov	 DWORD PTR $T1[rsp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00cd7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00cde	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  00ce2	48 83 fa 10	 cmp	 rdx, 16
  00ce6	72 16		 jb	 SHORT $LN1891@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00ce8	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T241[rsp]
  00ced	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00cf2	4c 89 64 24 40	 mov	 QWORD PTR $T241[rsp+16], r12
  00cf7	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN1891@SprawdŸ_P:

; 1607 : 		if (_Large_string_engaged())

  00cfe	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d01	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  00d09	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00d11	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T241[rsp]
  00d16	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00d1b	41 b8 05 00 00
	00		 mov	 r8d, 5
  00d21	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  00d28	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T241[rsp]
  00d2d	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00d32	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T241[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d37	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T241[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00d3d	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T241[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 780  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d43	33 d2		 xor	 edx, edx
  00d45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00d4b	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00d4d	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T241[rsp+24]
  00d52	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00d56	72 40		 jb	 SHORT $LN2017@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00d58	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00d5b	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T241[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00d60	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00d67	72 27		 jb	 SHORT $LN2020@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00d69	f6 c2 1f	 test	 dl, 31
  00d6c	75 1b		 jne	 SHORT $_Invalid_parameter$4446

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00d6e	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00d72	48 3b c2	 cmp	 rax, rdx
  00d75	73 12		 jae	 SHORT $_Invalid_parameter$4446
  00d77	48 2b d0	 sub	 rdx, rax
  00d7a	48 83 ea 08	 sub	 rdx, 8
  00d7e	48 83 fa 1f	 cmp	 rdx, 31
  00d82	77 05		 ja	 SHORT $_Invalid_parameter$4446

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00d84	48 8b d0	 mov	 rdx, rax
  00d87	eb 07		 jmp	 SHORT $LN2020@SprawdŸ_P
$_Invalid_parameter$4446:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00d89	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00d8f	cc		 int	 3
$LN2020@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00d90	48 8b ca	 mov	 rcx, rdx
  00d93	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2017@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 780  : 		if ((_access((G³os + "r.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  00d98	85 db		 test	 ebx, ebx
  00d9a	0f 84 69 02 00
	00		 je	 $LN53@SprawdŸ_P

; 781  : 		{
; 782  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  00da0	40 84 f6	 test	 sil, sil
  00da3	75 26		 jne	 SHORT $LN52@SprawdŸ_P

; 783  : 			{
; 784  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  00da5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  00dac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00db3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00db8	48 8b c8	 mov	 rcx, rax
  00dbb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00dc2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 785  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  00dc8	40 b6 01	 mov	 sil, 1
$LN52@SprawdŸ_P:

; 787  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00dcb	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00dd2	48 8d 4d 98	 lea	 rcx, QWORD PTR $T265[rbp-256]
  00dd6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00ddb	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00ddc	41 b8 05 00 00
	00		 mov	 r8d, 5
  00de2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  00de9	48 8b c8	 mov	 rcx, rax
  00dec	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00df1	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00df4	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T274[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00dfa	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00dfd	0f 11 44 24 30	 movups	 XMMWORD PTR $T274[rsp], xmm0
  00e02	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00e06	0f 11 4c 24 40	 movups	 XMMWORD PTR $T274[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00e0b	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e0f	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00e17	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 787  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00e1a	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  00e21	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  00e28	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T283[rsp]
  00e2d	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  00e32	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00e33	41 b8 05 00 00
	00		 mov	 r8d, 5
  00e39	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LALOIELB@r?4wav?$AA@
  00e40	48 8b c8	 mov	 rcx, rax
  00e43	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00e48	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  00e4b	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T292[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00e51	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00e54	0f 11 44 24 50	 movups	 XMMWORD PTR $T292[rsp], xmm0
  00e59	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00e5d	0f 11 4c 24 60	 movups	 XMMWORD PTR $T292[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00e62	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00e66	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00e6e	c6 00 00	 mov	 BYTE PTR [rax], 0
  00e71	41 81 ce 00 03
	00 00		 or	 r14d, 768		; 00000300H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00e78	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T274[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e7d	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T274[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00e83	4c 0f 43 44 24
	30		 cmovae	 r8, QWORD PTR $T274[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00e89	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T292[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00e8e	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T292[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  00e94	48 0f 43 54 24
	50		 cmovae	 rdx, QWORD PTR $T292[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 787  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "r.wav").c_str(), ("G³os/" + g³os2 + "r.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  00e9a	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  00e9f	45 33 c9	 xor	 r9d, r9d
  00ea2	33 c9		 xor	 ecx, ecx
  00ea4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  00eaa	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00eac	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T292[rsp+24]
  00eb1	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00eb5	72 40		 jb	 SHORT $LN2239@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00eb7	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00eba	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T292[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00ebf	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00ec6	72 27		 jb	 SHORT $LN2242@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00ec8	f6 c2 1f	 test	 dl, 31
  00ecb	75 1b		 jne	 SHORT $_Invalid_parameter$4447

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00ecd	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00ed1	48 3b c2	 cmp	 rax, rdx
  00ed4	73 12		 jae	 SHORT $_Invalid_parameter$4447
  00ed6	48 2b d0	 sub	 rdx, rax
  00ed9	48 83 ea 08	 sub	 rdx, 8
  00edd	48 83 fa 1f	 cmp	 rdx, 31
  00ee1	77 05		 ja	 SHORT $_Invalid_parameter$4447

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00ee3	48 8b d0	 mov	 rdx, rax
  00ee6	eb 07		 jmp	 SHORT $LN2242@SprawdŸ_P
$_Invalid_parameter$4447:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ee8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00eee	cc		 int	 3
$LN2242@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00eef	48 8b ca	 mov	 rcx, rdx
  00ef2	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2239@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00ef7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00eff	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T292[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00f05	c6 44 24 50 00	 mov	 BYTE PTR $T292[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00f0a	48 8b 45 90	 mov	 rax, QWORD PTR $T283[rbp-232]
  00f0e	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00f12	72 3c		 jb	 SHORT $LN2285@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00f14	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00f17	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T283[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00f1c	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00f22	72 27		 jb	 SHORT $LN2288@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00f24	f6 c1 1f	 test	 cl, 31
  00f27	75 1b		 jne	 SHORT $_Invalid_parameter$4448

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f29	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00f2d	48 3b c1	 cmp	 rax, rcx
  00f30	73 12		 jae	 SHORT $_Invalid_parameter$4448
  00f32	48 2b c8	 sub	 rcx, rax
  00f35	48 83 e9 08	 sub	 rcx, 8
  00f39	48 83 f9 1f	 cmp	 rcx, 31
  00f3d	77 05		 ja	 SHORT $_Invalid_parameter$4448

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00f3f	48 8b c8	 mov	 rcx, rax
  00f42	eb 07		 jmp	 SHORT $LN2288@SprawdŸ_P
$_Invalid_parameter$4448:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f44	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00f4a	cc		 int	 3
$LN2288@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00f4b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2285@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00f50	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00f58	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T283[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00f5d	c6 44 24 78 00	 mov	 BYTE PTR $T283[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00f62	48 8b 44 24 48	 mov	 rax, QWORD PTR $T274[rsp+24]
  00f67	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00f6b	72 3c		 jb	 SHORT $LN2331@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00f6d	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00f70	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T274[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00f75	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00f7b	72 27		 jb	 SHORT $LN2334@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00f7d	f6 c1 1f	 test	 cl, 31
  00f80	75 1b		 jne	 SHORT $_Invalid_parameter$4449

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00f82	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00f86	48 3b c1	 cmp	 rax, rcx
  00f89	73 12		 jae	 SHORT $_Invalid_parameter$4449
  00f8b	48 2b c8	 sub	 rcx, rax
  00f8e	48 83 e9 08	 sub	 rcx, 8
  00f92	48 83 f9 1f	 cmp	 rcx, 31
  00f96	77 05		 ja	 SHORT $_Invalid_parameter$4449

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00f98	48 8b c8	 mov	 rcx, rax
  00f9b	eb 07		 jmp	 SHORT $LN2334@SprawdŸ_P
$_Invalid_parameter$4449:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00f9d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00fa3	cc		 int	 3
$LN2334@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00fa4	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2331@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00fa9	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00fb1	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T274[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00fb7	c6 44 24 30 00	 mov	 BYTE PTR $T274[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00fbc	48 8b 45 b0	 mov	 rax, QWORD PTR $T265[rbp-232]
  00fc0	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00fc4	72 3b		 jb	 SHORT $LN2377@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00fc6	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00fc9	48 8b 4d 98	 mov	 rcx, QWORD PTR $T265[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00fcd	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00fd3	72 27		 jb	 SHORT $LN2380@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00fd5	f6 c1 1f	 test	 cl, 31
  00fd8	75 1b		 jne	 SHORT $_Invalid_parameter$4450

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00fda	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00fde	48 3b c1	 cmp	 rax, rcx
  00fe1	73 12		 jae	 SHORT $_Invalid_parameter$4450
  00fe3	48 2b c8	 sub	 rcx, rax
  00fe6	48 83 e9 08	 sub	 rcx, 8
  00fea	48 83 f9 1f	 cmp	 rcx, 31
  00fee	77 05		 ja	 SHORT $_Invalid_parameter$4450

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00ff0	48 8b c8	 mov	 rcx, rax
  00ff3	eb 07		 jmp	 SHORT $LN2380@SprawdŸ_P
$_Invalid_parameter$4450:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00ff5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00ffb	cc		 int	 3
$LN2380@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00ffc	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2377@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 788  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01001	85 db		 test	 ebx, ebx
  01003	0f 85 c7 0b 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN53@SprawdŸ_P:

; 796  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01009	41 8b de	 mov	 ebx, r14d
$_Invalid_parameter$4451:
$_Invalid_parameter$4452:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0100c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01014	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T331[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0101a	c6 44 24 30 00	 mov	 BYTE PTR $T331[rsp], 0
  0101f	41 0f ba ee 0a	 bts	 r14d, 10
  01024	44 89 74 24 70	 mov	 DWORD PTR $T1[rsp], r14d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  01029	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  01030	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  01034	48 83 fa 10	 cmp	 rdx, 16
  01038	72 16		 jb	 SHORT $LN2532@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0103a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T331[rsp]
  0103f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  01044	4c 89 64 24 40	 mov	 QWORD PTR $T331[rsp+16], r12
  01049	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN2532@SprawdŸ_P:

; 1607 : 		if (_Large_string_engaged())

  01050	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01053	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  0105b	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01063	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T331[rsp]
  01068	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0106d	41 b8 05 00 00
	00		 mov	 r8d, 5
  01073	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  0107a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T331[rsp]
  0107f	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01084	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T331[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01089	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T331[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  0108f	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T331[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 796  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01095	33 d2		 xor	 edx, edx
  01097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0109d	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  010a0	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T331[rsp+24]
  010a5	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  010a9	72 40		 jb	 SHORT $LN2658@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  010ab	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  010ae	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T331[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  010b3	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  010ba	72 27		 jb	 SHORT $LN2661@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  010bc	f6 c2 1f	 test	 dl, 31
  010bf	75 1b		 jne	 SHORT $_Invalid_parameter$4453

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  010c1	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  010c5	48 3b c2	 cmp	 rax, rdx
  010c8	73 12		 jae	 SHORT $_Invalid_parameter$4453
  010ca	48 2b d0	 sub	 rdx, rax
  010cd	48 83 ea 08	 sub	 rdx, 8
  010d1	48 83 fa 1f	 cmp	 rdx, 31
  010d5	77 05		 ja	 SHORT $_Invalid_parameter$4453

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  010d7	48 8b d0	 mov	 rdx, rax
  010da	eb 07		 jmp	 SHORT $LN2661@SprawdŸ_P
$_Invalid_parameter$4453:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  010dc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  010e2	cc		 int	 3
$LN2661@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  010e3	48 8b ca	 mov	 rcx, rdx
  010e6	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2658@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 796  : 		if ((_access((G³os + "b.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  010eb	45 85 f6	 test	 r14d, r14d
  010ee	0f 84 6a 02 00
	00		 je	 $LN56@SprawdŸ_P

; 797  : 		{
; 798  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  010f4	40 84 f6	 test	 sil, sil
  010f7	75 26		 jne	 SHORT $LN55@SprawdŸ_P

; 799  : 			{
; 800  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  010f9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01100	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01107	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0110c	48 8b c8	 mov	 rcx, rax
  0110f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01116	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 801  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0111c	40 b6 01	 mov	 sil, 1
$LN55@SprawdŸ_P:

; 803  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0111f	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01126	48 8d 4d 98	 lea	 rcx, QWORD PTR $T355[rbp-256]
  0112a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  0112f	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01130	41 b8 05 00 00
	00		 mov	 r8d, 5
  01136	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  0113d	48 8b c8	 mov	 rcx, rax
  01140	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  01145	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  01148	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T364[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0114e	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  01151	0f 11 44 24 30	 movups	 XMMWORD PTR $T364[rsp], xmm0
  01156	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0115a	0f 11 4c 24 40	 movups	 XMMWORD PTR $T364[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  0115f	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01163	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0116b	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 803  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0116e	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01175	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  0117c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T373[rsp]
  01181	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01186	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01187	41 b8 05 00 00
	00		 mov	 r8d, 5
  0118d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05LDGIIGCK@b?4wav?$AA@
  01194	48 8b c8	 mov	 rcx, rax
  01197	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0119c	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  0119f	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T382[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  011a5	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  011a8	0f 11 44 24 50	 movups	 XMMWORD PTR $T382[rsp], xmm0
  011ad	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  011b1	0f 11 4c 24 60	 movups	 XMMWORD PTR $T382[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  011b6	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  011ba	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  011c2	c6 00 00	 mov	 BYTE PTR [rax], 0
  011c5	81 cb 00 18 00
	00		 or	 ebx, 6144		; 00001800H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  011cb	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T364[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  011d0	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T364[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  011d6	4c 0f 43 44 24
	30		 cmovae	 r8, QWORD PTR $T364[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  011dc	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T382[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  011e1	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T382[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  011e7	48 0f 43 54 24
	50		 cmovae	 rdx, QWORD PTR $T382[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 803  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "b.wav").c_str(), ("G³os/" + g³os2 + "b.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  011ed	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  011f2	45 33 c9	 xor	 r9d, r9d
  011f5	33 c9		 xor	 ecx, ecx
  011f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  011fd	44 8b f0	 mov	 r14d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01200	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T382[rsp+24]
  01205	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01209	72 40		 jb	 SHORT $LN2880@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0120b	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0120e	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T382[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01213	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0121a	72 27		 jb	 SHORT $LN2883@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0121c	f6 c2 1f	 test	 dl, 31
  0121f	75 1b		 jne	 SHORT $_Invalid_parameter$4454

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01221	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01225	48 3b c2	 cmp	 rax, rdx
  01228	73 12		 jae	 SHORT $_Invalid_parameter$4454
  0122a	48 2b d0	 sub	 rdx, rax
  0122d	48 83 ea 08	 sub	 rdx, 8
  01231	48 83 fa 1f	 cmp	 rdx, 31
  01235	77 05		 ja	 SHORT $_Invalid_parameter$4454

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01237	48 8b d0	 mov	 rdx, rax
  0123a	eb 07		 jmp	 SHORT $LN2883@SprawdŸ_P
$_Invalid_parameter$4454:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0123c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01242	cc		 int	 3
$LN2883@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01243	48 8b ca	 mov	 rcx, rdx
  01246	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2880@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0124b	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01253	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T382[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01259	c6 44 24 50 00	 mov	 BYTE PTR $T382[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0125e	48 8b 45 90	 mov	 rax, QWORD PTR $T373[rbp-232]
  01262	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01266	72 3c		 jb	 SHORT $LN2926@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01268	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0126b	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T373[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01270	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01276	72 27		 jb	 SHORT $LN2929@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01278	f6 c1 1f	 test	 cl, 31
  0127b	75 1b		 jne	 SHORT $_Invalid_parameter$4455

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0127d	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01281	48 3b c1	 cmp	 rax, rcx
  01284	73 12		 jae	 SHORT $_Invalid_parameter$4455
  01286	48 2b c8	 sub	 rcx, rax
  01289	48 83 e9 08	 sub	 rcx, 8
  0128d	48 83 f9 1f	 cmp	 rcx, 31
  01291	77 05		 ja	 SHORT $_Invalid_parameter$4455

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01293	48 8b c8	 mov	 rcx, rax
  01296	eb 07		 jmp	 SHORT $LN2929@SprawdŸ_P
$_Invalid_parameter$4455:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01298	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0129e	cc		 int	 3
$LN2929@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0129f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2926@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  012a4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  012ac	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T373[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  012b1	c6 44 24 78 00	 mov	 BYTE PTR $T373[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  012b6	48 8b 44 24 48	 mov	 rax, QWORD PTR $T364[rsp+24]
  012bb	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  012bf	72 3c		 jb	 SHORT $LN2972@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  012c1	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  012c4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T364[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  012c9	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  012cf	72 27		 jb	 SHORT $LN2975@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  012d1	f6 c1 1f	 test	 cl, 31
  012d4	75 1b		 jne	 SHORT $_Invalid_parameter$4456

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  012d6	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  012da	48 3b c1	 cmp	 rax, rcx
  012dd	73 12		 jae	 SHORT $_Invalid_parameter$4456
  012df	48 2b c8	 sub	 rcx, rax
  012e2	48 83 e9 08	 sub	 rcx, 8
  012e6	48 83 f9 1f	 cmp	 rcx, 31
  012ea	77 05		 ja	 SHORT $_Invalid_parameter$4456

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  012ec	48 8b c8	 mov	 rcx, rax
  012ef	eb 07		 jmp	 SHORT $LN2975@SprawdŸ_P
$_Invalid_parameter$4456:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  012f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  012f7	cc		 int	 3
$LN2975@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  012f8	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN2972@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  012fd	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01305	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T364[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0130b	c6 44 24 30 00	 mov	 BYTE PTR $T364[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01310	48 8b 45 b0	 mov	 rax, QWORD PTR $T355[rbp-232]
  01314	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01318	72 3b		 jb	 SHORT $LN3018@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0131a	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0131d	48 8b 4d 98	 mov	 rcx, QWORD PTR $T355[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01321	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01327	72 27		 jb	 SHORT $LN3021@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01329	f6 c1 1f	 test	 cl, 31
  0132c	75 1b		 jne	 SHORT $_Invalid_parameter$4457

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0132e	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01332	48 3b c1	 cmp	 rax, rcx
  01335	73 12		 jae	 SHORT $_Invalid_parameter$4457
  01337	48 2b c8	 sub	 rcx, rax
  0133a	48 83 e9 08	 sub	 rcx, 8
  0133e	48 83 f9 1f	 cmp	 rcx, 31
  01342	77 05		 ja	 SHORT $_Invalid_parameter$4457

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01344	48 8b c8	 mov	 rcx, rax
  01347	eb 07		 jmp	 SHORT $LN3021@SprawdŸ_P
$_Invalid_parameter$4457:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01349	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0134f	cc		 int	 3
$LN3021@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01350	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3018@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 804  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01355	45 85 f6	 test	 r14d, r14d
  01358	0f 85 72 08 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN56@SprawdŸ_P:

; 812  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0135e	44 8b f3	 mov	 r14d, ebx
$_Invalid_parameter$4458:
$_Invalid_parameter$4459:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  01361	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01369	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T421[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0136f	c6 44 24 30 00	 mov	 BYTE PTR $T421[rsp], 0
  01374	0f ba eb 0d	 bts	 ebx, 13
  01378	89 5c 24 70	 mov	 DWORD PTR $T1[rsp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0137c	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  01383	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  01387	48 83 fa 10	 cmp	 rdx, 16
  0138b	72 16		 jb	 SHORT $LN3173@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  0138d	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T421[rsp]
  01392	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  01397	4c 89 64 24 40	 mov	 QWORD PTR $T421[rsp+16], r12
  0139c	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN3173@SprawdŸ_P:

; 1607 : 		if (_Large_string_engaged())

  013a3	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013a6	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  013ae	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  013b6	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T421[rsp]
  013bb	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  013c0	41 b8 05 00 00
	00		 mov	 r8d, 5
  013c6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  013cd	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T421[rsp]
  013d2	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  013d7	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T421[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013dc	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T421[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  013e2	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T421[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  013e8	33 d2		 xor	 edx, edx
  013ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  013f0	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  013f2	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T421[rsp+24]
  013f7	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  013fb	72 40		 jb	 SHORT $LN3299@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  013fd	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01400	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T421[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01405	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0140c	72 27		 jb	 SHORT $LN3302@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0140e	f6 c2 1f	 test	 dl, 31
  01411	75 1b		 jne	 SHORT $_Invalid_parameter$4460

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01413	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01417	48 3b c2	 cmp	 rax, rdx
  0141a	73 12		 jae	 SHORT $_Invalid_parameter$4460
  0141c	48 2b d0	 sub	 rdx, rax
  0141f	48 83 ea 08	 sub	 rdx, 8
  01423	48 83 fa 1f	 cmp	 rdx, 31
  01427	77 05		 ja	 SHORT $_Invalid_parameter$4460

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01429	48 8b d0	 mov	 rdx, rax
  0142c	eb 07		 jmp	 SHORT $LN3302@SprawdŸ_P
$_Invalid_parameter$4460:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0142e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01434	cc		 int	 3
$LN3302@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01435	48 8b ca	 mov	 rcx, rdx
  01438	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3299@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 812  : 		if ((_access((G³os + "g.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0143d	85 db		 test	 ebx, ebx
  0143f	0f 84 69 02 00
	00		 je	 $LN59@SprawdŸ_P

; 813  : 		{
; 814  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01445	40 84 f6	 test	 sil, sil
  01448	75 26		 jne	 SHORT $LN58@SprawdŸ_P

; 815  : 			{
; 816  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  0144a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01451	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01458	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0145d	48 8b c8	 mov	 rcx, rax
  01460	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01467	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 817  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  0146d	40 b6 01	 mov	 sil, 1
$LN58@SprawdŸ_P:

; 819  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01470	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01477	48 8d 4d 98	 lea	 rcx, QWORD PTR $T445[rbp-256]
  0147b	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01480	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01481	41 b8 05 00 00
	00		 mov	 r8d, 5
  01487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  0148e	48 8b c8	 mov	 rcx, rax
  01491	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  01496	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  01499	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T454[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0149f	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  014a2	0f 11 44 24 30	 movups	 XMMWORD PTR $T454[rsp], xmm0
  014a7	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  014ab	0f 11 4c 24 40	 movups	 XMMWORD PTR $T454[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  014b0	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  014b4	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  014bc	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 819  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  014bf	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  014c6	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  014cd	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T463[rsp]
  014d2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  014d7	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  014d8	41 b8 05 00 00
	00		 mov	 r8d, 5
  014de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05ODKFBHJJ@g?4wav?$AA@
  014e5	48 8b c8	 mov	 rcx, rax
  014e8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  014ed	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  014f0	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T472[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  014f6	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  014f9	0f 11 44 24 50	 movups	 XMMWORD PTR $T472[rsp], xmm0
  014fe	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  01502	0f 11 4c 24 60	 movups	 XMMWORD PTR $T472[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  01507	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0150b	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01513	c6 00 00	 mov	 BYTE PTR [rax], 0
  01516	41 81 ce 00 c0
	00 00		 or	 r14d, 49152		; 0000c000H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0151d	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T454[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01522	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T454[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  01528	4c 0f 43 44 24
	30		 cmovae	 r8, QWORD PTR $T454[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0152e	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T472[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01533	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T472[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  01539	48 0f 43 54 24
	50		 cmovae	 rdx, QWORD PTR $T472[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 819  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "g.wav").c_str(), ("G³os/" + g³os2 + "g.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0153f	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  01544	45 33 c9	 xor	 r9d, r9d
  01547	33 c9		 xor	 ecx, ecx
  01549	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  0154f	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01551	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T472[rsp+24]
  01556	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0155a	72 40		 jb	 SHORT $LN3521@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0155c	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0155f	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T472[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01564	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0156b	72 27		 jb	 SHORT $LN3524@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0156d	f6 c2 1f	 test	 dl, 31
  01570	75 1b		 jne	 SHORT $_Invalid_parameter$4461

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01572	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01576	48 3b c2	 cmp	 rax, rdx
  01579	73 12		 jae	 SHORT $_Invalid_parameter$4461
  0157b	48 2b d0	 sub	 rdx, rax
  0157e	48 83 ea 08	 sub	 rdx, 8
  01582	48 83 fa 1f	 cmp	 rdx, 31
  01586	77 05		 ja	 SHORT $_Invalid_parameter$4461

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01588	48 8b d0	 mov	 rdx, rax
  0158b	eb 07		 jmp	 SHORT $LN3524@SprawdŸ_P
$_Invalid_parameter$4461:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0158d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01593	cc		 int	 3
$LN3524@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01594	48 8b ca	 mov	 rcx, rdx
  01597	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3521@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0159c	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  015a4	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T472[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  015aa	c6 44 24 50 00	 mov	 BYTE PTR $T472[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  015af	48 8b 45 90	 mov	 rax, QWORD PTR $T463[rbp-232]
  015b3	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  015b7	72 3c		 jb	 SHORT $LN3567@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  015b9	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  015bc	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T463[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  015c1	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  015c7	72 27		 jb	 SHORT $LN3570@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  015c9	f6 c1 1f	 test	 cl, 31
  015cc	75 1b		 jne	 SHORT $_Invalid_parameter$4462

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  015ce	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  015d2	48 3b c1	 cmp	 rax, rcx
  015d5	73 12		 jae	 SHORT $_Invalid_parameter$4462
  015d7	48 2b c8	 sub	 rcx, rax
  015da	48 83 e9 08	 sub	 rcx, 8
  015de	48 83 f9 1f	 cmp	 rcx, 31
  015e2	77 05		 ja	 SHORT $_Invalid_parameter$4462

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  015e4	48 8b c8	 mov	 rcx, rax
  015e7	eb 07		 jmp	 SHORT $LN3570@SprawdŸ_P
$_Invalid_parameter$4462:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  015e9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  015ef	cc		 int	 3
$LN3570@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  015f0	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3567@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  015f5	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  015fd	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T463[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01602	c6 44 24 78 00	 mov	 BYTE PTR $T463[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01607	48 8b 44 24 48	 mov	 rax, QWORD PTR $T454[rsp+24]
  0160c	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01610	72 3c		 jb	 SHORT $LN3613@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01612	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01615	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T454[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0161a	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01620	72 27		 jb	 SHORT $LN3616@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01622	f6 c1 1f	 test	 cl, 31
  01625	75 1b		 jne	 SHORT $_Invalid_parameter$4463

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01627	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0162b	48 3b c1	 cmp	 rax, rcx
  0162e	73 12		 jae	 SHORT $_Invalid_parameter$4463
  01630	48 2b c8	 sub	 rcx, rax
  01633	48 83 e9 08	 sub	 rcx, 8
  01637	48 83 f9 1f	 cmp	 rcx, 31
  0163b	77 05		 ja	 SHORT $_Invalid_parameter$4463

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0163d	48 8b c8	 mov	 rcx, rax
  01640	eb 07		 jmp	 SHORT $LN3616@SprawdŸ_P
$_Invalid_parameter$4463:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01642	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01648	cc		 int	 3
$LN3616@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01649	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3613@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0164e	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01656	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T454[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0165c	c6 44 24 30 00	 mov	 BYTE PTR $T454[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01661	48 8b 45 b0	 mov	 rax, QWORD PTR $T445[rbp-232]
  01665	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01669	72 3b		 jb	 SHORT $LN3659@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0166b	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0166e	48 8b 4d 98	 mov	 rcx, QWORD PTR $T445[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01672	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01678	72 27		 jb	 SHORT $LN3662@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0167a	f6 c1 1f	 test	 cl, 31
  0167d	75 1b		 jne	 SHORT $_Invalid_parameter$4464

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0167f	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01683	48 3b c1	 cmp	 rax, rcx
  01686	73 12		 jae	 SHORT $_Invalid_parameter$4464
  01688	48 2b c8	 sub	 rcx, rax
  0168b	48 83 e9 08	 sub	 rcx, 8
  0168f	48 83 f9 1f	 cmp	 rcx, 31
  01693	77 05		 ja	 SHORT $_Invalid_parameter$4464

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01695	48 8b c8	 mov	 rcx, rax
  01698	eb 07		 jmp	 SHORT $LN3662@SprawdŸ_P
$_Invalid_parameter$4464:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0169a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  016a0	cc		 int	 3
$LN3662@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  016a1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3659@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 820  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  016a6	85 db		 test	 ebx, ebx
  016a8	0f 85 22 05 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN59@SprawdŸ_P:
$_Invalid_parameter$4465:
$_Invalid_parameter$4466:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  016ae	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  016b6	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T511[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  016bc	c6 44 24 30 00	 mov	 BYTE PTR $T511[rsp], 0
  016c1	41 0f ba ee 10	 bts	 r14d, 16
  016c6	44 89 74 24 70	 mov	 DWORD PTR $T1[rsp], r14d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  016cb	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  016d2	49 8d 50 05	 lea	 rdx, QWORD PTR [r8+5]
  016d6	48 83 fa 10	 cmp	 rdx, 16
  016da	72 16		 jb	 SHORT $LN3814@SprawdŸ_P

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  016dc	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T511[rsp]
  016e1	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  016e6	4c 89 64 24 40	 mov	 QWORD PTR $T511[rsp+16], r12
  016eb	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN3814@SprawdŸ_P:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  016f2	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  016fa	48 0f 43 3d 00
	00 00 00	 cmovae	 rdi, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  01702	48 8b d7	 mov	 rdx, rdi
  01705	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T511[rsp]
  0170a	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0170f	41 b8 05 00 00
	00		 mov	 r8d, 5
  01715	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  0171c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T511[rsp]
  01721	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01726	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T511[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0172b	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T511[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  01731	48 0f 43 4c 24
	30		 cmovae	 rcx, QWORD PTR $T511[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 828  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01737	33 d2		 xor	 edx, edx
  01739	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  0173f	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01741	48 8b 4c 24 48	 mov	 rcx, QWORD PTR $T511[rsp+24]
  01746	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0174a	72 40		 jb	 SHORT $LN3940@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0174c	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0174f	48 8b 54 24 30	 mov	 rdx, QWORD PTR $T511[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01754	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0175b	72 27		 jb	 SHORT $LN3943@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0175d	f6 c2 1f	 test	 dl, 31
  01760	75 1b		 jne	 SHORT $_Invalid_parameter$4467

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01762	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01766	48 3b c2	 cmp	 rax, rdx
  01769	73 12		 jae	 SHORT $_Invalid_parameter$4467
  0176b	48 2b d0	 sub	 rdx, rax
  0176e	48 83 ea 08	 sub	 rdx, 8
  01772	48 83 fa 1f	 cmp	 rdx, 31
  01776	77 05		 ja	 SHORT $_Invalid_parameter$4467

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01778	48 8b d0	 mov	 rdx, rax
  0177b	eb 07		 jmp	 SHORT $LN3943@SprawdŸ_P
$_Invalid_parameter$4467:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0177d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01783	cc		 int	 3
$LN3943@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01784	48 8b ca	 mov	 rcx, rdx
  01787	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3940@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 828  : 		if ((_access((G³os + "d.wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  0178c	85 db		 test	 ebx, ebx
  0178e	0f 84 62 02 00
	00		 je	 $LN62@SprawdŸ_P

; 829  : 		{
; 830  : 			if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01794	40 84 f6	 test	 sil, sil
  01797	75 26		 jne	 SHORT $LN61@SprawdŸ_P

; 831  : 			{
; 832  : 				cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01799	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  017a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  017a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  017ac	48 8b c8	 mov	 rcx, rax
  017af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  017b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 833  : 				czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  017bc	40 b6 01	 mov	 sil, 1
$LN61@SprawdŸ_P:

; 835  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  017bf	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  017c6	48 8d 4d 98	 lea	 rcx, QWORD PTR $T535[rbp-256]
  017ca	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  017cf	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  017d0	41 b8 05 00 00
	00		 mov	 r8d, 5
  017d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  017dd	48 8b c8	 mov	 rcx, rax
  017e0	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  017e5	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  017e8	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T544[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  017ee	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  017f1	0f 11 44 24 30	 movups	 XMMWORD PTR $T544[rsp], xmm0
  017f6	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  017fa	0f 11 4c 24 40	 movups	 XMMWORD PTR $T544[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  017ff	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  01803	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0180b	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 835  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  0180e	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01815	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  0181c	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T553[rsp]
  01821	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01826	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  01827	41 b8 05 00 00
	00		 mov	 r8d, 5
  0182d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05GFDBGFDH@d?4wav?$AA@
  01834	48 8b c8	 mov	 rcx, rax
  01837	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  0183c	0f 57 c0	 xorps	 xmm0, xmm0

; 1576 : 		_Mysize(0),

  0183f	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T562[rsp+16], xmm0

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  01845	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  01848	0f 11 44 24 50	 movups	 XMMWORD PTR $T562[rsp], xmm0
  0184d	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  01851	0f 11 4c 24 60	 movups	 XMMWORD PTR $T562[rsp+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  01856	4c 89 60 10	 mov	 QWORD PTR [rax+16], r12

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0185a	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  01862	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01865	4c 8d 44 24 30	 lea	 r8, QWORD PTR $T544[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0186a	48 83 7c 24 48
	10		 cmp	 QWORD PTR $T544[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  01870	4c 0f 43 44 24
	30		 cmovae	 r8, QWORD PTR $T544[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  01876	48 8d 54 24 50	 lea	 rdx, QWORD PTR $T562[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0187b	48 83 7c 24 68
	10		 cmp	 QWORD PTR $T562[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  01881	48 0f 43 54 24
	50		 cmovae	 rdx, QWORD PTR $T562[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 835  : 			auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "d.wav").c_str(), ("G³os/" + g³os2 + "d.wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01887	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  0188c	45 33 c9	 xor	 r9d, r9d
  0188f	33 c9		 xor	 ecx, ecx
  01891	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01897	8b d8		 mov	 ebx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  01899	48 8b 4c 24 68	 mov	 rcx, QWORD PTR $T562[rsp+24]
  0189e	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  018a2	72 40		 jb	 SHORT $LN4162@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  018a4	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  018a7	48 8b 54 24 50	 mov	 rdx, QWORD PTR $T562[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  018ac	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  018b3	72 27		 jb	 SHORT $LN4165@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  018b5	f6 c2 1f	 test	 dl, 31
  018b8	75 1b		 jne	 SHORT $_Invalid_parameter$4468

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  018ba	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  018be	48 3b c2	 cmp	 rax, rdx
  018c1	73 12		 jae	 SHORT $_Invalid_parameter$4468
  018c3	48 2b d0	 sub	 rdx, rax
  018c6	48 83 ea 08	 sub	 rdx, 8
  018ca	48 83 fa 1f	 cmp	 rdx, 31
  018ce	77 05		 ja	 SHORT $_Invalid_parameter$4468

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  018d0	48 8b d0	 mov	 rdx, rax
  018d3	eb 07		 jmp	 SHORT $LN4165@SprawdŸ_P
$_Invalid_parameter$4468:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  018d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  018db	cc		 int	 3
$LN4165@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  018dc	48 8b ca	 mov	 rcx, rdx
  018df	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN4162@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  018e4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  018ec	f3 0f 7f 44 24
	60		 movdqu	 XMMWORD PTR $T562[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  018f2	c6 44 24 50 00	 mov	 BYTE PTR $T562[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  018f7	48 8b 45 90	 mov	 rax, QWORD PTR $T553[rbp-232]
  018fb	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  018ff	72 3c		 jb	 SHORT $LN4208@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  01901	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  01904	48 8b 4c 24 78	 mov	 rcx, QWORD PTR $T553[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01909	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0190f	72 27		 jb	 SHORT $LN4211@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  01911	f6 c1 1f	 test	 cl, 31
  01914	75 1b		 jne	 SHORT $_Invalid_parameter$4469

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  01916	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0191a	48 3b c1	 cmp	 rax, rcx
  0191d	73 12		 jae	 SHORT $_Invalid_parameter$4469
  0191f	48 2b c8	 sub	 rcx, rax
  01922	48 83 e9 08	 sub	 rcx, 8
  01926	48 83 f9 1f	 cmp	 rcx, 31
  0192a	77 05		 ja	 SHORT $_Invalid_parameter$4469

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0192c	48 8b c8	 mov	 rcx, rax
  0192f	eb 07		 jmp	 SHORT $LN4211@SprawdŸ_P
$_Invalid_parameter$4469:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  01931	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01937	cc		 int	 3
$LN4211@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01938	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN4208@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  0193d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  01945	f3 0f 7f 45 88	 movdqu	 XMMWORD PTR $T553[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0194a	c6 44 24 78 00	 mov	 BYTE PTR $T553[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0194f	48 8b 44 24 48	 mov	 rax, QWORD PTR $T544[rsp+24]
  01954	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  01958	72 3c		 jb	 SHORT $LN4254@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0195a	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0195d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T544[rsp]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  01962	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  01968	72 27		 jb	 SHORT $LN4257@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0196a	f6 c1 1f	 test	 cl, 31
  0196d	75 1b		 jne	 SHORT $_Invalid_parameter$4470

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0196f	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  01973	48 3b c1	 cmp	 rax, rcx
  01976	73 12		 jae	 SHORT $_Invalid_parameter$4470
  01978	48 2b c8	 sub	 rcx, rax
  0197b	48 83 e9 08	 sub	 rcx, 8
  0197f	48 83 f9 1f	 cmp	 rcx, 31
  01983	77 05		 ja	 SHORT $_Invalid_parameter$4470

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  01985	48 8b c8	 mov	 rcx, rax
  01988	eb 07		 jmp	 SHORT $LN4257@SprawdŸ_P
$_Invalid_parameter$4470:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0198a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  01990	cc		 int	 3
$LN4257@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  01991	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN4254@SprawdŸ_P:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  01996	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  0199e	f3 0f 7f 44 24
	40		 movdqu	 XMMWORD PTR $T544[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  019a4	c6 44 24 30 00	 mov	 BYTE PTR $T544[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  019a9	48 8b 45 b0	 mov	 rax, QWORD PTR $T535[rbp-232]
  019ad	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  019b1	72 3b		 jb	 SHORT $LN4300@SprawdŸ_P

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  019b3	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  019b6	48 8b 4d 98	 mov	 rcx, QWORD PTR $T535[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  019ba	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  019c0	72 27		 jb	 SHORT $LN4303@SprawdŸ_P

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  019c2	f6 c1 1f	 test	 cl, 31
  019c5	75 1b		 jne	 SHORT $_Invalid_parameter$4471

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  019c7	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  019cb	48 3b c1	 cmp	 rax, rcx
  019ce	73 12		 jae	 SHORT $_Invalid_parameter$4471
  019d0	48 2b c8	 sub	 rcx, rax
  019d3	48 83 e9 08	 sub	 rcx, 8
  019d7	48 83 f9 1f	 cmp	 rcx, 31
  019db	77 05		 ja	 SHORT $_Invalid_parameter$4471

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  019dd	48 8b c8	 mov	 rcx, rax
  019e0	eb 07		 jmp	 SHORT $LN4303@SprawdŸ_P
$_Invalid_parameter$4471:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  019e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  019e8	cc		 int	 3
$LN4303@SprawdŸ_P:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  019e9	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN4300@SprawdŸ_P:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 836  : 			if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  019ee	85 db		 test	 ebx, ebx
  019f0	0f 85 da 01 00
	00		 jne	 $LN4368@SprawdŸ_P
$LN62@SprawdŸ_P:
$_Invalid_parameter$4472:

; 837  : 			{
; 838  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 839  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio
; 840  : 				return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 841  : 			}
; 842  : 		}
; 843  : 
; 844  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  019f6	41 0f b7 ff	 movzx	 edi, r15w
  019fa	66 0f 1f 44 00
	00		 npad	 6
$LL6@SprawdŸ_P:

; 845  : 		{
; 846  : 			if ((_access((G³os + "k" + (char)(48 + i) + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01a00	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01a07	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T597[rsp]
  01a0c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01a11	90		 npad	 1
  01a12	44 8d 77 30	 lea	 r14d, DWORD PTR [rdi+48]
  01a16	45 0f b6 c6	 movzx	 r8d, r14b
  01a1a	48 8b d0	 mov	 rdx, rax
  01a1d	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T598[rsp]
  01a22	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01a27	90		 npad	 1
  01a28	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01a2f	48 8b d0	 mov	 rdx, rax
  01a32	48 8d 4d 98	 lea	 rcx, QWORD PTR $T599[rbp-256]
  01a36	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01a3b	48 8b c8	 mov	 rcx, rax
  01a3e	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01a43	48 8b c8	 mov	 rcx, rax
  01a46	33 d2		 xor	 edx, edx
  01a48	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01a4e	8b d8		 mov	 ebx, eax
  01a50	48 8d 4d 98	 lea	 rcx, QWORD PTR $T599[rbp-256]
  01a54	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a59	90		 npad	 1
  01a5a	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T598[rsp]
  01a5f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a64	90		 npad	 1
  01a65	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T597[rsp]
  01a6a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01a6f	85 db		 test	 ebx, ebx
  01a71	0f 84 4b 01 00
	00		 je	 $LN4@SprawdŸ_P

; 847  : 			{
; 848  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01a77	40 84 f6	 test	 sil, sil
  01a7a	75 26		 jne	 SHORT $LN64@SprawdŸ_P

; 849  : 				{
; 850  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01a7c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01a83	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01a8a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01a8f	48 8b c8	 mov	 rcx, rax
  01a92	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01a99	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 851  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01a9f	40 b6 01	 mov	 sil, 1
$LN64@SprawdŸ_P:

; 852  : 				}
; 853  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), ("G³os/" + g³os2 + "k" + (char)(48 + i) + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01aa2	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01aa9	48 8d 4d b8	 lea	 rcx, QWORD PTR $T601[rbp-256]
  01aad	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ab2	90		 npad	 1
  01ab3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01aba	48 8b d0	 mov	 rdx, rax
  01abd	48 8d 4d 18	 lea	 rcx, QWORD PTR $T602[rbp-256]
  01ac1	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ac6	90		 npad	 1
  01ac7	45 0f b6 c6	 movzx	 r8d, r14b
  01acb	48 8b d0	 mov	 rdx, rax
  01ace	48 8d 4d f8	 lea	 rcx, QWORD PTR $T603[rbp-256]
  01ad2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ad7	90		 npad	 1
  01ad8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01adf	48 8b d0	 mov	 rdx, rax
  01ae2	48 8d 4d d8	 lea	 rcx, QWORD PTR $T604[rbp-256]
  01ae6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01aeb	48 8b d8	 mov	 rbx, rax
  01aee	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01af5	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  01afc	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T605[rsp]
  01b01	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b06	90		 npad	 1
  01b07	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01DICPFPGM@k?$AA@
  01b0e	48 8b d0	 mov	 rdx, rax
  01b11	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T606[rsp]
  01b16	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b1b	90		 npad	 1
  01b1c	45 0f b6 c6	 movzx	 r8d, r14b
  01b20	48 8b d0	 mov	 rdx, rax
  01b23	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T607[rsp]
  01b28	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b2d	90		 npad	 1
  01b2e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01b35	48 8b d0	 mov	 rdx, rax
  01b38	48 8d 4d 98	 lea	 rcx, QWORD PTR $T608[rbp-256]
  01b3c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01b41	48 8b d0	 mov	 rdx, rax
  01b44	48 8b cb	 mov	 rcx, rbx
  01b47	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01b4c	4c 8b c0	 mov	 r8, rax
  01b4f	48 8b ca	 mov	 rcx, rdx
  01b52	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01b57	48 8b d0	 mov	 rdx, rax
  01b5a	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  01b5f	45 33 c9	 xor	 r9d, r9d
  01b62	33 c9		 xor	 ecx, ecx
  01b64	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01b6a	8b d8		 mov	 ebx, eax
  01b6c	48 8d 4d 98	 lea	 rcx, QWORD PTR $T608[rbp-256]
  01b70	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b75	90		 npad	 1
  01b76	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T607[rsp]
  01b7b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b80	90		 npad	 1
  01b81	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T606[rsp]
  01b86	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b8b	90		 npad	 1
  01b8c	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T605[rsp]
  01b91	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01b96	90		 npad	 1
  01b97	48 8d 4d d8	 lea	 rcx, QWORD PTR $T604[rbp-256]
  01b9b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ba0	90		 npad	 1
  01ba1	48 8d 4d f8	 lea	 rcx, QWORD PTR $T603[rbp-256]
  01ba5	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01baa	90		 npad	 1
  01bab	48 8d 4d 18	 lea	 rcx, QWORD PTR $T602[rbp-256]
  01baf	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01bb4	90		 npad	 1
  01bb5	48 8d 4d b8	 lea	 rcx, QWORD PTR $T601[rbp-256]
  01bb9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 854  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01bbe	85 db		 test	 ebx, ebx
  01bc0	75 0e		 jne	 SHORT $LN4368@SprawdŸ_P
$LN4@SprawdŸ_P:

; 837  : 			{
; 838  : 				cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego
; 839  : 				G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio
; 840  : 				return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 841  : 			}
; 842  : 		}
; 843  : 
; 844  : 		for (unsigned short i = 1; i <= 3; ++i) //Pêtla licz¹ca od 1 do 3

  01bc2	66 ff c7	 inc	 di
  01bc5	66 83 ff 03	 cmp	 di, 3
  01bc9	77 35		 ja	 SHORT $LL9@SprawdŸ_P
  01bcb	e9 30 fe ff ff	 jmp	 $LL6@SprawdŸ_P
$LN4368@SprawdŸ_P:

; 855  : 				{
; 856  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  01bd0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  01bd7	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01bde	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01be3	48 8b c8	 mov	 rcx, rax
  01be6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01bed	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 857  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  01bf3	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  01bfa	e9 e6 04 00 00	 jmp	 $LN72@SprawdŸ_P
  01bff	90		 npad	 1
$LL9@SprawdŸ_P:

; 864  : 		{
; 865  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  01c00	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01c07	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  01c0c	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01c13	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  01c18	90		 npad	 1

; 866  : 			numers << i; //Wpisanie do typu wartoœci z obrotu pêtli

  01c19	41 0f b7 d7	 movzx	 edx, r15w
  01c1d	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-240]
  01c24	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 867  : 			if ((_access((G³os + "w" + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01c2a	48 8d 55 d8	 lea	 rdx, QWORD PTR $T609[rbp-256]
  01c2e	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01c35	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01c3a	48 8b d8	 mov	 rbx, rax
  01c3d	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01c44	48 8d 4d f8	 lea	 rcx, QWORD PTR $T610[rbp-256]
  01c48	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c4d	90		 npad	 1
  01c4e	4c 8b c3	 mov	 r8, rbx
  01c51	48 8b d0	 mov	 rdx, rax
  01c54	48 8d 4d 18	 lea	 rcx, QWORD PTR $T611[rbp-256]
  01c58	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c5d	90		 npad	 1
  01c5e	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01c65	48 8b d0	 mov	 rdx, rax
  01c68	48 8d 4d b8	 lea	 rcx, QWORD PTR $T612[rbp-256]
  01c6c	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01c71	48 8b c8	 mov	 rcx, rax
  01c74	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01c79	48 8b c8	 mov	 rcx, rax
  01c7c	33 d2		 xor	 edx, edx
  01c7e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01c84	8b d8		 mov	 ebx, eax
  01c86	48 8d 4d b8	 lea	 rcx, QWORD PTR $T612[rbp-256]
  01c8a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c8f	90		 npad	 1
  01c90	48 8d 4d 18	 lea	 rcx, QWORD PTR $T611[rbp-256]
  01c94	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01c99	90		 npad	 1
  01c9a	48 8d 4d f8	 lea	 rcx, QWORD PTR $T610[rbp-256]
  01c9e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01ca3	90		 npad	 1
  01ca4	48 8d 4d d8	 lea	 rcx, QWORD PTR $T609[rbp-256]
  01ca8	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01cad	85 db		 test	 ebx, ebx
  01caf	0f 84 83 01 00
	00		 je	 $LN68@SprawdŸ_P

; 868  : 			{
; 869  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01cb5	40 84 f6	 test	 sil, sil
  01cb8	75 26		 jne	 SHORT $LN67@SprawdŸ_P

; 870  : 				{
; 871  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01cba	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01cc1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01cc8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01ccd	48 8b c8	 mov	 rcx, rax
  01cd0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01cd7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 872  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01cdd	40 b6 01	 mov	 sil, 1
$LN67@SprawdŸ_P:

; 873  : 				}
; 874  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + "w" + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + "w" + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01ce0	48 8d 55 58	 lea	 rdx, QWORD PTR $T614[rbp-256]
  01ce4	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01ceb	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01cf0	48 8b d8	 mov	 rbx, rax
  01cf3	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01cfa	48 8d 4d 38	 lea	 rcx, QWORD PTR $T615[rbp-256]
  01cfe	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d03	90		 npad	 1
  01d04	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01d0b	48 8b d0	 mov	 rdx, rax
  01d0e	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T616[rsp]
  01d13	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d18	90		 npad	 1
  01d19	4c 8b c3	 mov	 r8, rbx
  01d1c	48 8b d0	 mov	 rdx, rax
  01d1f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T617[rsp]
  01d24	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d29	90		 npad	 1
  01d2a	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01d31	48 8b d0	 mov	 rdx, rax
  01d34	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T618[rsp]
  01d39	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d3e	48 8b f8	 mov	 rdi, rax
  01d41	48 8d 55 98	 lea	 rdx, QWORD PTR $T619[rbp-256]
  01d45	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01d4c	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01d51	48 8b d8	 mov	 rbx, rax
  01d54	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01d5b	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  01d62	48 8d 4d d8	 lea	 rcx, QWORD PTR $T620[rbp-256]
  01d66	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d6b	90		 npad	 1
  01d6c	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_01NOFIACDB@w?$AA@
  01d73	48 8b d0	 mov	 rdx, rax
  01d76	48 8d 4d f8	 lea	 rcx, QWORD PTR $T621[rbp-256]
  01d7a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d7f	90		 npad	 1
  01d80	4c 8b c3	 mov	 r8, rbx
  01d83	48 8b d0	 mov	 rdx, rax
  01d86	48 8d 4d 18	 lea	 rcx, QWORD PTR $T622[rbp-256]
  01d8a	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01d8f	90		 npad	 1
  01d90	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01d97	48 8b d0	 mov	 rdx, rax
  01d9a	48 8d 4d b8	 lea	 rcx, QWORD PTR $T623[rbp-256]
  01d9e	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01da3	48 8b d0	 mov	 rdx, rax
  01da6	48 8b cf	 mov	 rcx, rdi
  01da9	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01dae	4c 8b c0	 mov	 r8, rax
  01db1	48 8b ca	 mov	 rcx, rdx
  01db4	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01db9	48 8b d0	 mov	 rdx, rax
  01dbc	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  01dc1	45 33 c9	 xor	 r9d, r9d
  01dc4	33 c9		 xor	 ecx, ecx
  01dc6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  01dcc	8b d8		 mov	 ebx, eax
  01dce	48 8d 4d b8	 lea	 rcx, QWORD PTR $T623[rbp-256]
  01dd2	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01dd7	90		 npad	 1
  01dd8	48 8d 4d 18	 lea	 rcx, QWORD PTR $T622[rbp-256]
  01ddc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01de1	90		 npad	 1
  01de2	48 8d 4d f8	 lea	 rcx, QWORD PTR $T621[rbp-256]
  01de6	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01deb	90		 npad	 1
  01dec	48 8d 4d d8	 lea	 rcx, QWORD PTR $T620[rbp-256]
  01df0	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01df5	90		 npad	 1
  01df6	48 8d 4d 98	 lea	 rcx, QWORD PTR $T619[rbp-256]
  01dfa	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01dff	90		 npad	 1
  01e00	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T618[rsp]
  01e05	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e0a	90		 npad	 1
  01e0b	48 8d 4c 24 50	 lea	 rcx, QWORD PTR $T617[rsp]
  01e10	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e15	90		 npad	 1
  01e16	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T616[rsp]
  01e1b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e20	90		 npad	 1
  01e21	48 8d 4d 38	 lea	 rcx, QWORD PTR $T615[rbp-256]
  01e25	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01e2a	90		 npad	 1
  01e2b	48 8d 4d 58	 lea	 rcx, QWORD PTR $T614[rbp-256]
  01e2f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 875  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  01e34	85 db		 test	 ebx, ebx
  01e36	75 1c		 jne	 SHORT $LN4369@SprawdŸ_P
$LN68@SprawdŸ_P:

; 879  : 					return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 880  : 				}
; 881  : 			}
; 882  : 		}

  01e38	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$640[rbp-256]
  01e3f	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ

; 858  : 					return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej
; 859  : 				}
; 860  : 			}
; 861  : 		}
; 862  : 
; 863  : 		for (unsigned short i = 1; i <= 12; ++i) //Pêtla licz¹ca od 1 do 12

  01e44	66 41 ff c7	 inc	 r15w
  01e48	66 41 83 ff 0c	 cmp	 r15w, 12
  01e4d	77 34		 ja	 SHORT $LN4422@SprawdŸ_P
  01e4f	e9 ac fd ff ff	 jmp	 $LL9@SprawdŸ_P
$LN4369@SprawdŸ_P:

; 876  : 				{
; 877  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  01e54	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  01e5b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01e62	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01e67	48 8b c8	 mov	 rcx, rax
  01e6a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01e71	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 878  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  01e77	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
  01e7e	e9 2b 02 00 00	 jmp	 $LN4428@SprawdŸ_P
$LN4422@SprawdŸ_P:

; 883  : 
; 884  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  01e83	45 0f b7 f4	 movzx	 r14d, r12w
  01e87	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL12@SprawdŸ_P:

; 885  : 		{
; 886  : 			stringstream numers; //Utworzenie typu do zamiany liczby na tekst

  01e90	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  01e97	e8 00 00 00 00	 call	 ?__autoclassinit2@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
  01e9c	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  01ea3	e8 00 00 00 00	 call	 ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
  01ea8	90		 npad	 1

; 887  : 			numers << i; //Wpisanie do typu wartoœci z obrotu pêtli

  01ea9	41 0f b7 d6	 movzx	 edx, r14w
  01ead	48 8d 8d d0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-240]
  01eb4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@G@Z

; 888  : 			if ((_access((G³os + numers.str() + ".wav").c_str(), 0))) //Sprawdzenie czy plik nie istnieje

  01eba	48 8d 55 b8	 lea	 rdx, QWORD PTR $T624[rbp-256]
  01ebe	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  01ec5	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01eca	90		 npad	 1
  01ecb	4c 8b c0	 mov	 r8, rax
  01ece	48 8d 4d 38	 lea	 rcx, QWORD PTR $T625[rbp-256]
  01ed2	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01ed7	90		 npad	 1
  01ed8	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01edf	48 8b d0	 mov	 rdx, rax
  01ee2	48 8d 4d 58	 lea	 rcx, QWORD PTR $T626[rbp-256]
  01ee6	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01eeb	48 8b c8	 mov	 rcx, rax
  01eee	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01ef3	48 8b c8	 mov	 rcx, rax
  01ef6	33 d2		 xor	 edx, edx
  01ef8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  01efe	8b d8		 mov	 ebx, eax
  01f00	48 8d 4d 58	 lea	 rcx, QWORD PTR $T626[rbp-256]
  01f04	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f09	90		 npad	 1
  01f0a	48 8d 4d 38	 lea	 rcx, QWORD PTR $T625[rbp-256]
  01f0e	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f13	90		 npad	 1
  01f14	48 8d 4d b8	 lea	 rcx, QWORD PTR $T624[rbp-256]
  01f18	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  01f1d	85 db		 test	 ebx, ebx
  01f1f	0f 84 43 01 00
	00		 je	 $LN71@SprawdŸ_P

; 889  : 			{
; 890  : 				if (!czy_pobierano) //Sprawdzanie czy jakieœ pobieranie siê rozpocze³o

  01f25	40 84 f6	 test	 sil, sil
  01f28	75 26		 jne	 SHORT $LN70@SprawdŸ_P

; 891  : 				{
; 892  : 					cout << "Rozpoczynam pobieranie brakuj¹cych plików g³osów" << endl; //Poinformowaniu o rozpoczêciu pobierania

  01f2a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DB@JAANGCNE@Rozpoczynam?5pobieranie?5brakuj?$LJcy@
  01f31	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  01f38	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  01f3d	48 8b c8	 mov	 rcx, rax
  01f40	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  01f47	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 893  : 					czy_pobierano = true; //Zmiana zmiennej aby wiadomo, ¿e rozpoczêto pobieranie

  01f4d	40 b6 01	 mov	 sil, 1
$LN70@SprawdŸ_P:

; 894  : 				}
; 895  : 				auto res = URLDownloadToFileA(nullptr, (link + g³os2 + numers.str() + ".wav").c_str(), ("G³os/" + g³os2 + numers.str() + ".wav").c_str(), 0, nullptr); //Rozpoczêcie pobierania pliku

  01f50	48 8d 54 24 78	 lea	 rdx, QWORD PTR $T628[rsp]
  01f55	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  01f5c	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01f61	48 8b d8	 mov	 rbx, rax
  01f64	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01f6b	48 8d 4d 98	 lea	 rcx, QWORD PTR $T629[rbp-256]
  01f6f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f74	90		 npad	 1
  01f75	4c 8b c3	 mov	 r8, rbx
  01f78	48 8b d0	 mov	 rdx, rax
  01f7b	48 8d 4d d8	 lea	 rcx, QWORD PTR $T630[rbp-256]
  01f7f	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f84	90		 npad	 1
  01f85	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01f8c	48 8b d0	 mov	 rdx, rax
  01f8f	48 8d 4d f8	 lea	 rcx, QWORD PTR $T631[rbp-256]
  01f93	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01f98	48 8b f8	 mov	 rdi, rax
  01f9b	48 8d 55 18	 lea	 rdx, QWORD PTR $T632[rbp-256]
  01f9f	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  01fa6	e8 00 00 00 00	 call	 ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
  01fab	48 8b d8	 mov	 rbx, rax
  01fae	4c 8d 85 80 00
	00 00		 lea	 r8, QWORD PTR g³os2$637[rbp-256]
  01fb5	48 8d 95 a0 00
	00 00		 lea	 rdx, QWORD PTR link$638[rbp-256]
  01fbc	48 8d 4d b8	 lea	 rcx, QWORD PTR $T633[rbp-256]
  01fc0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fc5	90		 npad	 1
  01fc6	4c 8b c3	 mov	 r8, rbx
  01fc9	48 8b d0	 mov	 rdx, rax
  01fcc	48 8d 4d 38	 lea	 rcx, QWORD PTR $T634[rbp-256]
  01fd0	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fd5	90		 npad	 1
  01fd6	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_04IBLEHOMF@?4wav?$AA@
  01fdd	48 8b d0	 mov	 rdx, rax
  01fe0	48 8d 4d 58	 lea	 rcx, QWORD PTR $T635[rbp-256]
  01fe4	e8 00 00 00 00	 call	 ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
  01fe9	48 8b d0	 mov	 rdx, rax
  01fec	48 8b cf	 mov	 rcx, rdi
  01fef	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01ff4	4c 8b c0	 mov	 r8, rax
  01ff7	48 8b ca	 mov	 rcx, rdx
  01ffa	e8 00 00 00 00	 call	 ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
  01fff	48 8b d0	 mov	 rdx, rax
  02002	4c 89 64 24 20	 mov	 QWORD PTR [rsp+32], r12
  02007	45 33 c9	 xor	 r9d, r9d
  0200a	33 c9		 xor	 ecx, ecx
  0200c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_URLDownloadToFileA
  02012	8b d8		 mov	 ebx, eax
  02014	48 8d 4d 58	 lea	 rcx, QWORD PTR $T635[rbp-256]
  02018	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0201d	90		 npad	 1
  0201e	48 8d 4d 38	 lea	 rcx, QWORD PTR $T634[rbp-256]
  02022	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02027	90		 npad	 1
  02028	48 8d 4d b8	 lea	 rcx, QWORD PTR $T633[rbp-256]
  0202c	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02031	90		 npad	 1
  02032	48 8d 4d 18	 lea	 rcx, QWORD PTR $T632[rbp-256]
  02036	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0203b	90		 npad	 1
  0203c	48 8d 4d f8	 lea	 rcx, QWORD PTR $T631[rbp-256]
  02040	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02045	90		 npad	 1
  02046	48 8d 4d d8	 lea	 rcx, QWORD PTR $T630[rbp-256]
  0204a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  0204f	90		 npad	 1
  02050	48 8d 4d 98	 lea	 rcx, QWORD PTR $T629[rbp-256]
  02054	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  02059	90		 npad	 1
  0205a	48 8d 4c 24 78	 lea	 rcx, QWORD PTR $T628[rsp]
  0205f	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >

; 896  : 				if (res != S_OK) //Je¿eli nie powiod³o siê pobieranie pliku

  02064	85 db		 test	 ebx, ebx
  02066	75 1c		 jne	 SHORT $LN4370@SprawdŸ_P
$LN71@SprawdŸ_P:

; 901  : 				}
; 902  : 			}
; 903  : 		}

  02068	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  0206f	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ

; 883  : 
; 884  : 		for (unsigned short i = 0; i <= 36; ++i) //Pêtla licz¹ca od 0 do 36

  02074	66 41 ff c6	 inc	 r14w
  02078	66 41 83 fe 24	 cmp	 r14w, 36		; 00000024H
  0207d	77 3d		 ja	 SHORT $LN4423@SprawdŸ_P
  0207f	e9 0c fe ff ff	 jmp	 $LL12@SprawdŸ_P
$LN4370@SprawdŸ_P:

; 897  : 				{
; 898  : 					cout << "Brak plików dla g³osu oraz nie mo¿na pobraæ danych, wy³¹czono odczytywanie wyniku" << endl; //Poinformowanie o nieudajnym pobieraniu i konsekwencji tego

  02084	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0FC@DPJNGIHL@Brak?5plik?sw?5dla?5g?$LDosu?5oraz?5nie?5m@
  0208b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  02092	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  02097	48 8b c8	 mov	 rcx, rax
  0209a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  020a1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 899  : 					G³osyKompletne = false; //Wpisanie do zmiennej wartoœci false informuj¹cej o niekompletnych plikach audio

  020a7	c6 05 00 00 00
	00 00		 mov	 BYTE PTR ?G³osyKompletne@@3_NA, 0 ; G³osyKompletne
$LN4428@SprawdŸ_P:

; 900  : 					return; //Wyjœcie z funkcji poniewa¿ nie ma sensu sprawdzania dalej

  020ae	48 8d 8d c0 00
	00 00		 lea	 rcx, QWORD PTR numers$639[rbp-256]
  020b5	e8 00 00 00 00	 call	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
  020ba	eb 29		 jmp	 SHORT $LN72@SprawdŸ_P
$LN4423@SprawdŸ_P:

; 904  : 
; 905  : 		if (czy_pobierano) cout << "Pobrano brakuj¹ce pliki g³osów" << endl; //Poinformowanie o ukoñczonu pobierania plików

  020bc	40 84 f6	 test	 sil, sil
  020bf	74 24		 je	 SHORT $LN72@SprawdŸ_P
  020c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@KIMEIPBM@Pobrano?5brakuj?$LJce?5pliki?5g?$LDos?sw?$AA@
  020c8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  020cf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  020d4	48 8b c8	 mov	 rcx, rax
  020d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  020de	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  020e4	90		 npad	 1
$LN72@SprawdŸ_P:

; 906  : 	}

  020e5	48 8d 8d 80 00
	00 00		 lea	 rcx, QWORD PTR g³os2$637[rbp-256]
  020ec	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
  020f1	90		 npad	 1
  020f2	48 8d 8d a0 00
	00 00		 lea	 rcx, QWORD PTR link$638[rbp-256]
  020f9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN32@SprawdŸ_P:

; 907  : }

  020fe	48 8b 8d c0 01
	00 00		 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  02105	48 33 cc	 xor	 rcx, rsp
  02108	e8 00 00 00 00	 call	 __security_check_cookie
  0210d	4c 8d 9c 24 d0
	02 00 00	 lea	 r11, QWORD PTR [rsp+720]
  02115	49 8b 5b 20	 mov	 rbx, QWORD PTR [r11+32]
  02119	49 8b 73 28	 mov	 rsi, QWORD PTR [r11+40]
  0211d	49 8b 7b 30	 mov	 rdi, QWORD PTR [r11+48]
  02121	4d 8b 63 38	 mov	 r12, QWORD PTR [r11+56]
  02125	49 8b e3	 mov	 rsp, r11
  02128	41 5f		 pop	 r15
  0212a	41 5e		 pop	 r14
  0212c	5d		 pop	 rbp
  0212d	c3		 ret	 0
$LN4425@SprawdŸ_P:
  0212e	66 90		 npad	 2
$LN4424@SprawdŸ_P:
  02130	00 00 00 00	 DD	 $LN33@SprawdŸ_P
  02134	00 00 00 00	 DD	 $LN34@SprawdŸ_P
  02138	00 00 00 00	 DD	 $LN35@SprawdŸ_P
  0213c	00 00 00 00	 DD	 $LN36@SprawdŸ_P
  02140	00 00 00 00	 DD	 $LN37@SprawdŸ_P
  02144	00 00 00 00	 DD	 $LN38@SprawdŸ_P
  02148	00 00 00 00	 DD	 $LN39@SprawdŸ_P
  0214c	00 00 00 00	 DD	 $LN40@SprawdŸ_P
  02150	00 00 00 00	 DD	 $LN41@SprawdŸ_P
?SprawdŸ_Pliki@@YAXXZ ENDP				; SprawdŸ_Pliki
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$0@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$0
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR link$638[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$0
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$1@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$1
  0000c	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR g³os2$637[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$1
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$136
  00018	40 55		 push	 rbp
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN568@dtor$136
  0002b	83 65 70 fd	 and	 DWORD PTR $T1[rbp], -3
  0002f	48 8d 4d 30	 lea	 rcx, QWORD PTR $T61[rbp]
  00033	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN568@dtor$136:
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$136
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$5@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$5
  0003e	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T85[rdx]
  00045	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$5
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$6@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$6
  0004a	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T94[rdx]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$6
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$7@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$7
  00056	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T103[rdx]
  0005d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$7
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$254
  00062	40 55		 push	 rbp
  00064	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00068	48 8b ea	 mov	 rbp, rdx
  0006b	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  0006e	83 e0 10	 and	 eax, 16
  00071	85 c0		 test	 eax, eax
  00073	74 0d		 je	 SHORT $LN1209@dtor$254
  00075	83 65 70 ef	 and	 DWORD PTR $T1[rbp], -17
  00079	48 8d 4d 30	 lea	 rcx, QWORD PTR $T151[rbp]
  0007d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1209@dtor$254:
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5d		 pop	 rbp
  00087	c3		 ret	 0
?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$254
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$10@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$10
  00088	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T175[rdx]
  0008f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$10
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$11@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$11
  00094	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T184[rdx]
  0009b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$11
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$12@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$12
  000a0	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T193[rdx]
  000a7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$12
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$372
  000ac	40 55		 push	 rbp
  000ae	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000b2	48 8b ea	 mov	 rbp, rdx
  000b5	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  000b8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000bd	85 c0		 test	 eax, eax
  000bf	74 10		 je	 SHORT $LN1850@dtor$372
  000c1	81 65 70 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  000c8	48 8d 4d 30	 lea	 rcx, QWORD PTR $T241[rbp]
  000cc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1850@dtor$372:
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5d		 pop	 rbp
  000d6	c3		 ret	 0
?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$372
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$15@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$15
  000d7	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T265[rdx]
  000de	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$15
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$16@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$16
  000e3	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T274[rdx]
  000ea	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$16
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$17@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$17
  000ef	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T283[rdx]
  000f6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$17
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$490
  000fb	40 55		 push	 rbp
  000fd	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00101	48 8b ea	 mov	 rbp, rdx
  00104	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00107	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0010c	85 c0		 test	 eax, eax
  0010e	74 10		 je	 SHORT $LN2491@dtor$490
  00110	81 65 70 ff fb
	ff ff		 and	 DWORD PTR $T1[rbp], -1025 ; fffffffffffffbffH
  00117	48 8d 4d 30	 lea	 rcx, QWORD PTR $T331[rbp]
  0011b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2491@dtor$490:
  00120	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00124	5d		 pop	 rbp
  00125	c3		 ret	 0
?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$490
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$20@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$20
  00126	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T355[rdx]
  0012d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$20
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$21@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$21
  00132	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T364[rdx]
  00139	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$21
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$22@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$22
  0013e	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T373[rdx]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$22
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$608
  0014a	40 55		 push	 rbp
  0014c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00150	48 8b ea	 mov	 rbp, rdx
  00153	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00156	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0015b	85 c0		 test	 eax, eax
  0015d	74 10		 je	 SHORT $LN3132@dtor$608
  0015f	81 65 70 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00166	48 8d 4d 30	 lea	 rcx, QWORD PTR $T421[rbp]
  0016a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3132@dtor$608:
  0016f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00173	5d		 pop	 rbp
  00174	c3		 ret	 0
?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$608
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$25@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$25
  00175	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T445[rdx]
  0017c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$25@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$25
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$26@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$26
  00181	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T454[rdx]
  00188	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$26
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$27@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$27
  0018d	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T463[rdx]
  00194	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$27
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$726
  00199	40 55		 push	 rbp
  0019b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0019f	48 8b ea	 mov	 rbp, rdx
  001a2	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  001a5	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001aa	85 c0		 test	 eax, eax
  001ac	74 10		 je	 SHORT $LN3773@dtor$726
  001ae	81 65 70 ff ff
	fe ff		 and	 DWORD PTR $T1[rbp], -65537 ; fffffffffffeffffH
  001b5	48 8d 4d 30	 lea	 rcx, QWORD PTR $T511[rbp]
  001b9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3773@dtor$726:
  001be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c2	5d		 pop	 rbp
  001c3	c3		 ret	 0
?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$726
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$30@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$30
  001c4	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T535[rdx]
  001cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$30
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$31@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$31
  001d0	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T544[rdx]
  001d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$31@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$31
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$32@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$32
  001dc	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T553[rdx]
  001e3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$32
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$34@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$34
  001e8	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T597[rdx]
  001ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$34
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$35@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$35
  001f4	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T598[rdx]
  001fb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$35@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$35
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$37@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$37
  00200	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T601[rdx]
  00207	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$37
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$38@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$38
  0020c	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T602[rdx]
  00213	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$38
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$39@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$39
  00218	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T603[rdx]
  0021f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$39
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$40@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$40
  00224	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T604[rdx]
  0022b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$40@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$40
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$41@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$41
  00230	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T605[rdx]
  00237	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$41
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$42@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$42
  0023c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T606[rdx]
  00243	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$42
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$43@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$43
  00248	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T607[rdx]
  0024f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$43@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$43
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$45@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$45
  00254	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$640[rdx]
  0025b	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$45@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$45
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$46@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$46
  00260	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T609[rdx]
  00267	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$46@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$46
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$47@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$47
  0026c	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T610[rdx]
  00273	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$47
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$48@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$48
  00278	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T611[rdx]
  0027f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$48
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$50@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$50
  00284	48 8d 8a 58 01
	00 00		 lea	 rcx, QWORD PTR $T614[rdx]
  0028b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$50@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$50
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$51@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$51
  00290	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T615[rdx]
  00297	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$51@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$51
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$52@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$52
  0029c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T616[rdx]
  002a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$52@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$52
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$53@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$53
  002a8	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T617[rdx]
  002af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$53@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$53
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$54@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$54
  002b4	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T618[rdx]
  002bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$54@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$54
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$55@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$55
  002c0	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T619[rdx]
  002c7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$55@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$55
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$56@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$56
  002cc	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T620[rdx]
  002d3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$56@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$56
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$57@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$57
  002d8	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T621[rdx]
  002df	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$57@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$57
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$58@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$58
  002e4	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T622[rdx]
  002eb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$58@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$58
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$60@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$60
  002f0	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$639[rdx]
  002f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$60@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$60
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$61@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$61
  002fc	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T624[rdx]
  00303	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$61@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$61
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$62@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$62
  00308	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T625[rdx]
  0030f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$62@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$62
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$64@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$64
  00314	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T628[rdx]
  0031b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$64@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$64
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$65@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$65
  00320	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T629[rdx]
  00327	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$65@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$65
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$66@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$66
  0032c	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T630[rdx]
  00333	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$66
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$67@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$67
  00338	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T631[rdx]
  0033f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$67@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$67
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$68@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$68
  00344	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T632[rdx]
  0034b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$68@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$68
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$69@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$69
  00350	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T633[rdx]
  00357	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$69@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$69
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$70@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$70
  0035c	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T634[rdx]
  00363	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$70@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$70
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$0@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$0
  00000	48 8d 8a a0 01
	00 00		 lea	 rcx, QWORD PTR link$638[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$1@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$1
  0000c	48 8d 8a 80 01
	00 00		 lea	 rcx, QWORD PTR g³os2$637[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$136
  00018	40 55		 push	 rbp
  0001a	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001e	48 8b ea	 mov	 rbp, rdx
  00021	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00024	83 e0 02	 and	 eax, 2
  00027	85 c0		 test	 eax, eax
  00029	74 0d		 je	 SHORT $LN568@dtor$136
  0002b	83 65 70 fd	 and	 DWORD PTR $T1[rbp], -3
  0002f	48 8d 4d 30	 lea	 rcx, QWORD PTR $T61[rbp]
  00033	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN568@dtor$136:
  00038	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003c	5d		 pop	 rbp
  0003d	c3		 ret	 0
?dtor$136@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$136
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$5@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$5
  0003e	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T85[rdx]
  00045	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$5@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$6@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$6
  0004a	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T94[rdx]
  00051	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$6@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$6
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$7@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$7
  00056	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T103[rdx]
  0005d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$7@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$254
  00062	40 55		 push	 rbp
  00064	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00068	48 8b ea	 mov	 rbp, rdx
  0006b	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  0006e	83 e0 10	 and	 eax, 16
  00071	85 c0		 test	 eax, eax
  00073	74 0d		 je	 SHORT $LN1209@dtor$254
  00075	83 65 70 ef	 and	 DWORD PTR $T1[rbp], -17
  00079	48 8d 4d 30	 lea	 rcx, QWORD PTR $T151[rbp]
  0007d	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1209@dtor$254:
  00082	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00086	5d		 pop	 rbp
  00087	c3		 ret	 0
?dtor$254@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$254
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$10@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$10
  00088	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T175[rdx]
  0008f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$10@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$10
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$11@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$11
  00094	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T184[rdx]
  0009b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$11@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$11
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$12@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$12
  000a0	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T193[rdx]
  000a7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$12@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$12
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$372
  000ac	40 55		 push	 rbp
  000ae	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  000b2	48 8b ea	 mov	 rbp, rdx
  000b5	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  000b8	25 80 00 00 00	 and	 eax, 128		; 00000080H
  000bd	85 c0		 test	 eax, eax
  000bf	74 10		 je	 SHORT $LN1850@dtor$372
  000c1	81 65 70 7f ff
	ff ff		 and	 DWORD PTR $T1[rbp], -129 ; ffffffffffffff7fH
  000c8	48 8d 4d 30	 lea	 rcx, QWORD PTR $T241[rbp]
  000cc	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN1850@dtor$372:
  000d1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d5	5d		 pop	 rbp
  000d6	c3		 ret	 0
?dtor$372@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$372
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$15@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$15
  000d7	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T265[rdx]
  000de	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$15@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$15
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$16@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$16
  000e3	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T274[rdx]
  000ea	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$16@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$16
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$17@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$17
  000ef	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T283[rdx]
  000f6	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$17@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$17
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$490
  000fb	40 55		 push	 rbp
  000fd	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00101	48 8b ea	 mov	 rbp, rdx
  00104	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00107	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0010c	85 c0		 test	 eax, eax
  0010e	74 10		 je	 SHORT $LN2491@dtor$490
  00110	81 65 70 ff fb
	ff ff		 and	 DWORD PTR $T1[rbp], -1025 ; fffffffffffffbffH
  00117	48 8d 4d 30	 lea	 rcx, QWORD PTR $T331[rbp]
  0011b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN2491@dtor$490:
  00120	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00124	5d		 pop	 rbp
  00125	c3		 ret	 0
?dtor$490@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$490
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$20@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$20
  00126	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T355[rdx]
  0012d	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$20@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$20
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$21@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$21
  00132	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T364[rdx]
  00139	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$21@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$21
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$22@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$22
  0013e	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T373[rdx]
  00145	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$22@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$22
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$608
  0014a	40 55		 push	 rbp
  0014c	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00150	48 8b ea	 mov	 rbp, rdx
  00153	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  00156	25 00 20 00 00	 and	 eax, 8192		; 00002000H
  0015b	85 c0		 test	 eax, eax
  0015d	74 10		 je	 SHORT $LN3132@dtor$608
  0015f	81 65 70 ff df
	ff ff		 and	 DWORD PTR $T1[rbp], -8193 ; ffffffffffffdfffH
  00166	48 8d 4d 30	 lea	 rcx, QWORD PTR $T421[rbp]
  0016a	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3132@dtor$608:
  0016f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00173	5d		 pop	 rbp
  00174	c3		 ret	 0
?dtor$608@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$608
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$25@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$25
  00175	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T445[rdx]
  0017c	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$25@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$25
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$26@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$26
  00181	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T454[rdx]
  00188	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$26@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$26
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$27@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$27
  0018d	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T463[rdx]
  00194	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$27@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$27
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$726
  00199	40 55		 push	 rbp
  0019b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0019f	48 8b ea	 mov	 rbp, rdx
  001a2	8b 45 70	 mov	 eax, DWORD PTR $T1[rbp]
  001a5	25 00 00 01 00	 and	 eax, 65536		; 00010000H
  001aa	85 c0		 test	 eax, eax
  001ac	74 10		 je	 SHORT $LN3773@dtor$726
  001ae	81 65 70 ff ff
	fe ff		 and	 DWORD PTR $T1[rbp], -65537 ; fffffffffffeffffH
  001b5	48 8d 4d 30	 lea	 rcx, QWORD PTR $T511[rbp]
  001b9	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN3773@dtor$726:
  001be	48 83 c4 20	 add	 rsp, 32			; 00000020H
  001c2	5d		 pop	 rbp
  001c3	c3		 ret	 0
?dtor$726@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$726
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$30@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$30
  001c4	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T535[rdx]
  001cb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$30@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$30
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$31@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$31
  001d0	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T544[rdx]
  001d7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$31@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$31
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$32@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$32
  001dc	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T553[rdx]
  001e3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$32@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$32
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$34@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$34
  001e8	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T597[rdx]
  001ef	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$34@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$34
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$35@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$35
  001f4	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T598[rdx]
  001fb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$35@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$35
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$37@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$37
  00200	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T601[rdx]
  00207	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$37@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$37
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$38@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$38
  0020c	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T602[rdx]
  00213	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$38@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$38
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$39@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$39
  00218	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T603[rdx]
  0021f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$39@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$39
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$40@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$40
  00224	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T604[rdx]
  0022b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$40@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$40
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$41@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$41
  00230	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T605[rdx]
  00237	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$41@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$41
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$42@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$42
  0023c	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T606[rdx]
  00243	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$42@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$42
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$43@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$43
  00248	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T607[rdx]
  0024f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$43@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$43
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$45@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$45
  00254	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$640[rdx]
  0025b	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$45@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$45
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$46@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$46
  00260	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T609[rdx]
  00267	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$46@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$46
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$47@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$47
  0026c	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T610[rdx]
  00273	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$47@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$47
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$48@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$48
  00278	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T611[rdx]
  0027f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$48@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$48
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$50@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$50
  00284	48 8d 8a 58 01
	00 00		 lea	 rcx, QWORD PTR $T614[rdx]
  0028b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$50@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$50
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$51@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$51
  00290	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T615[rdx]
  00297	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$51@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$51
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$52@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$52
  0029c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR $T616[rdx]
  002a3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$52@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$52
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$53@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$53
  002a8	48 8d 8a 50 00
	00 00		 lea	 rcx, QWORD PTR $T617[rdx]
  002af	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$53@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$53
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$54@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$54
  002b4	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T618[rdx]
  002bb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$54@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$54
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$55@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$55
  002c0	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T619[rdx]
  002c7	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$55@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$55
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$56@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$56
  002cc	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T620[rdx]
  002d3	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$56@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$56
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$57@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$57
  002d8	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T621[rdx]
  002df	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$57@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$57
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$58@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$58
  002e4	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T622[rdx]
  002eb	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$58@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$58
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$60@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$60
  002f0	48 8d 8a c0 01
	00 00		 lea	 rcx, QWORD PTR numers$639[rdx]
  002f7	e9 00 00 00 00	 jmp	 ??_D?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
?dtor$60@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$60
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$61@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$61
  002fc	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T624[rdx]
  00303	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$61@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$61
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$62@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$62
  00308	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T625[rdx]
  0030f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$62@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$62
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$64@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$64
  00314	48 8d 8a 78 00
	00 00		 lea	 rcx, QWORD PTR $T628[rdx]
  0031b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$64@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$64
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$65@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$65
  00320	48 8d 8a 98 00
	00 00		 lea	 rcx, QWORD PTR $T629[rdx]
  00327	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$65@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$65
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$66@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$66
  0032c	48 8d 8a d8 00
	00 00		 lea	 rcx, QWORD PTR $T630[rdx]
  00333	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$66@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$66
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$67@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$67
  00338	48 8d 8a f8 00
	00 00		 lea	 rcx, QWORD PTR $T631[rdx]
  0033f	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$67@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$67
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$68@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$68
  00344	48 8d 8a 18 01
	00 00		 lea	 rcx, QWORD PTR $T632[rdx]
  0034b	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$68@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$68
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$69@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$69
  00350	48 8d 8a b8 00
	00 00		 lea	 rcx, QWORD PTR $T633[rdx]
  00357	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$69@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$69
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T616 = 48
$T605 = 48
$T544 = 48
$T511 = 48
$T454 = 48
$T421 = 48
$T364 = 48
$T331 = 48
$T274 = 48
$T241 = 48
$T184 = 48
$T151 = 48
$T112 = 48
$T61 = 48
$T617 = 80
$T606 = 80
$T597 = 80
$T562 = 80
$T472 = 80
$T382 = 80
$T292 = 80
$T202 = 80
$T94 = 80
$T1 = 112
$T628 = 120
$T618 = 120
$T607 = 120
$T598 = 120
$T553 = 120
$T463 = 120
$T373 = 120
$T283 = 120
$T193 = 120
$T103 = 120
$T52 = 120
$T42 = 120
$T629 = 152
$T619 = 152
$T608 = 152
$T599 = 152
$T535 = 152
$T445 = 152
$T355 = 152
$T265 = 152
$T175 = 152
$T85 = 152
$T633 = 184
$T624 = 184
$T623 = 184
$T612 = 184
$T601 = 184
$T630 = 216
$T620 = 216
$T609 = 216
$T604 = 216
$T631 = 248
$T621 = 248
$T610 = 248
$T603 = 248
$T632 = 280
$T622 = 280
$T611 = 280
$T602 = 280
$T634 = 312
$T625 = 312
$T615 = 312
$T635 = 344
$T626 = 344
$T614 = 344
$T636 = 376
g³os2$637 = 384
link$638 = 416
numers$639 = 448
numers$640 = 448
__$ArrayPad$ = 704
?dtor$70@?0??SprawdŸ_Pliki@@YAXXZ@4HA PROC		; `SprawdŸ_Pliki'::`1'::dtor$70
  0035c	48 8d 8a 38 01
	00 00		 lea	 rcx, QWORD PTR $T634[rdx]
  00363	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$70@?0??SprawdŸ_Pliki@@YAXXZ@4HA ENDP		; `SprawdŸ_Pliki'::`1'::dtor$70
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?SprawdŸ_ustawienia@@YAXXZ
_TEXT	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?SprawdŸ_ustawienia@@YAXXZ PROC				; SprawdŸ_ustawienia, COMDAT

; 910  : {

$LN150:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 6c 24 80	 lea	 rbp, QWORD PTR [rsp-128]
  00009	48 81 ec 80 01
	00 00		 sub	 rsp, 384		; 00000180H
  00010	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T10[rsp], -2
  00019	48 89 58 08	 mov	 QWORD PTR [rax+8], rbx
  0001d	48 89 70 10	 mov	 QWORD PTR [rax+16], rsi
  00021	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0002c	48 33 c4	 xor	 rax, rsp
  0002f	48 89 45 70	 mov	 QWORD PTR __$ArrayPad$[rbp-256], rax
  00033	33 db		 xor	 ebx, ebx
  00035	89 5c 24 20	 mov	 DWORD PTR $T1[rsp], ebx

; 911  : 	if (!_access("setting.txt", 0)) // Sprawdzenie dostêpu do pliku (je¿eli takowy istnieje, musi istnieæ plik)

  00039	33 d2		 xor	 edx, edx
  0003b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00042	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__access
  00048	8d 7b 01	 lea	 edi, QWORD PTR [rbx+1]
  0004b	33 d2		 xor	 edx, edx
  0004d	85 c0		 test	 eax, eax
  0004f	0f 85 bf 01 00
	00		 jne	 $LN4@SprawdŸ_u
  00055	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  0005b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$12[rsp]
  00060	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 759  : 		{	// construct unopened

  00065	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0006c	48 89 44 24 40	 mov	 QWORD PTR ustawienia$12[rsp], rax
  00071	48 8d 4d f0	 lea	 rcx, QWORD PTR ustawienia$12[rbp-80]
  00075	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0007b	90		 npad	 1
  0007c	89 7c 24 20	 mov	 DWORD PTR $T1[rsp], edi

; 654  : 		}
; 655  : 
; 656  : 	bool _Endwrite()
; 657  : 		{	// put shift to initial conversion state, as needed
; 658  : 		if (_Pcvt == 0 || !_Wrotesome)
; 659  : 			return (true);
; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 665  : 				return (false);
; 666  : 
; 667  : 			string _Str(_STRING_INC, '\0');
; 668  : 			for (; ; )
; 669  : 				switch (_Pcvt->unshift(_State,
; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully
; 674  : 
; 675  : 				case codecvt_base::partial:	// fall through
; 676  : 					{	// put any generated bytes
; 677  : 					size_t _Count = _Dest - &*_Str.begin();
; 678  : 					if (0 < _Count && _Count !=
; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)
; 682  : 						return (true);
; 683  : 					if (_Count == 0)
; 684  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 685  : 					break;
; 686  : 					}
; 687  : 
; 688  : 				case codecvt_base::noconv:
; 689  : 					return (true);	// nothing to do
; 690  : 
; 691  : 				default:
; 692  : 					return (false);	// conversion failed
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 
; 697  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 698  : 		{	// initialize codecvt pointer
; 699  : 		if (_Newpcvt->always_noconv())
; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering
; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : private:
; 709  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 710  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 711  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 712  : 	typename _Traits::state_type _State;	// current conversion state
; 713  : 	bool _Closef;	// true if C stream must be closed
; 714  : 	_Filet *_Myfile;	// pointer to C stream
; 715  : 
; 716  : 	void _Reset_back()
; 717  : 		{	// restore buffer after putback
; 718  : 		if (_Mysb::eback() == &_Mychar)
; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 720  : 		}
; 721  : 
; 722  : 	void _Set_back()
; 723  : 		{	// set up putback area
; 724  : 		if (_Mysb::eback() != &_Mychar)
; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();
; 727  : 			_Set_egptr = _Mysb::egptr();
; 728  : 			}
; 729  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 730  : 		}
; 731  : 
; 732  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 733  : 	_Elem *_Set_egptr;	// saves egptr()
; 734  : 	};
; 735  : 
; 736  : 	// basic_filebuf TEMPLATE OPERATORS
; 737  : template<class _Elem,
; 738  : 	class _Traits> inline
; 739  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 740  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 741  : 	{	// swap _Left and _Right basic_filebufs
; 742  : 	_Left.swap(_Right);
; 743  : 	}
; 744  : 
; 745  : 		// TEMPLATE CLASS basic_ifstream
; 746  : template<class _Elem,
; 747  : 	class _Traits>
; 748  : 	class basic_ifstream
; 749  : 		: public basic_istream<_Elem, _Traits>
; 750  : 	{	// input stream associated with a C stream
; 751  : public:
; 752  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 753  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 754  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 755  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 756  : 
; 757  : 	basic_ifstream()
; 758  : 		: _Mybase(&_Filebuffer)

  00080	45 33 c9	 xor	 r9d, r9d
  00083	45 33 c0	 xor	 r8d, r8d
  00086	48 8d 54 24 50	 lea	 rdx, QWORD PTR ustawienia$12[rsp+16]
  0008b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$12[rsp]
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  00096	90		 npad	 1

; 759  : 		{	// construct unopened

  00097	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$12[rsp]
  0009c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000a0	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  000a7	48 89 44 0c 40	 mov	 QWORD PTR ustawienia$12[rsp+rcx], rax
  000ac	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$12[rsp]
  000b1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000b5	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  000bb	89 54 0c 3c	 mov	 DWORD PTR ustawienia$12[rsp+rcx-4], edx
  000bf	48 8d 44 24 50	 lea	 rax, QWORD PTR ustawienia$12[rsp+16]
  000c4	48 89 44 24 30	 mov	 QWORD PTR this$[rsp], rax

; 155  : 		: _Mysb()

  000c9	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$12[rsp+16]
  000ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  000d4	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  000d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  000dc	48 89 44 24 50	 mov	 QWORD PTR ustawienia$12[rsp+16], rax

; 625  : 		_Closef = _Which == _Openfl;

  000e1	88 5d cc	 mov	 BYTE PTR ustawienia$12[rbp-116], bl

; 626  : 		_Wrotesome = false;

  000e4	88 5d c1	 mov	 BYTE PTR ustawienia$12[rbp-127], bl

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000e7	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$12[rsp+16]
  000ec	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  000f2	48 89 5d d0	 mov	 QWORD PTR ustawienia$12[rbp-112], rbx

; 652  : 		_State = _Stinit;

  000f6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000fd	48 89 45 c4	 mov	 QWORD PTR ustawienia$12[rbp-124], rax

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  00101	48 89 5d b8	 mov	 QWORD PTR ustawienia$12[rbp-136], rbx

; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00105	44 8b c7	 mov	 r8d, edi
  00108	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0010f	48 8d 4c 24 50	 lea	 rcx, QWORD PTR ustawienia$12[rsp+16]
  00114	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open
  00119	8d 5f 01	 lea	 ebx, QWORD PTR [rdi+1]

; 923  : 			_Myios::setstate(ios_base::failbit);

  0011c	45 33 c0	 xor	 r8d, r8d

; 760  : 		}
; 761  : 
; 762  : 	explicit basic_ifstream(const char *_Filename,
; 763  : 		ios_base::openmode _Mode = ios_base::in,
; 764  : 		int _Prot = (int)ios_base::_Openprot)
; 765  : 		: _Mybase(&_Filebuffer)
; 766  : 		{	// construct with named file and specified mode
; 767  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 768  : 			_Myios::setstate(ios_base::failbit);
; 769  : 		}
; 770  : 
; 771  : 	explicit basic_ifstream(const string& _Str,
; 772  : 		ios_base::openmode _Mode = ios_base::in,
; 773  : 		int _Prot = (int)ios_base::_Openprot)
; 774  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 775  : 		{	// construct with named file and specified mode
; 776  : 		}
; 777  : 
; 778  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 779  : 		ios_base::openmode _Mode = ios_base::in,
; 780  : 		int _Prot = (int)ios_base::_Openprot)
; 781  : 		: _Mybase(&_Filebuffer)
; 782  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 783  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 784  : 			_Myios::setstate(ios_base::failbit);
; 785  : 		}
; 786  : 
; 787  : 	explicit basic_ifstream(const wstring& _Str,
; 788  : 		ios_base::openmode _Mode = ios_base::in,
; 789  : 		int _Prot = (int)ios_base::_Openprot)
; 790  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 791  : 		{	// construct with wide-named file -- EXTENSION
; 792  : 		}
; 793  : 
; 794  : 	template<class _Path_ish = experimental::filesystem::path>
; 795  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 796  : 		ios_base::openmode _Mode = ios_base::in,
; 797  : 		int _Prot = (int)ios_base::_Openprot)
; 798  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 799  : 		{	// construct with path-named file
; 800  : 		}
; 801  : 
; 802  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 803  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 804  : 		ios_base::openmode _Mode = ios_base::in,
; 805  : 		int _Prot = (int)ios_base::_Openprot)
; 806  : 		: _Mybase(&_Filebuffer)
; 807  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 808  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 809  : 			_Myios::setstate(ios_base::failbit);
; 810  : 		}
; 811  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 812  : 
; 813  : 	explicit basic_ifstream(_Filet *_File)
; 814  : 		: _Mybase(&_Filebuffer),
; 815  : 			_Filebuffer(_File)
; 816  : 		{	// construct with specified C stream
; 817  : 		}
; 818  : 
; 819  : 	basic_ifstream(_Myt&& _Right)
; 820  : 		: _Mybase(&_Filebuffer)
; 821  : 		{	// construct by moving _Right
; 822  : 		_Assign_rv(_STD move(_Right));
; 823  : 		}
; 824  : 
; 825  : 	_Myt& operator=(_Myt&& _Right)
; 826  : 		{	// move from _Right
; 827  : 		_Assign_rv(_STD move(_Right));
; 828  : 		return (*this);
; 829  : 		}
; 830  : 
; 831  : 	void _Assign_rv(_Myt&& _Right)
; 832  : 		{	// assign by moving _Right
; 833  : 		if (this != _STD addressof(_Right))
; 834  : 			{	// different, worth moving
; 835  : 			_Filebuffer.close();
; 836  : 			this->swap(_Right);
; 837  : 			}
; 838  : 		}
; 839  : 
; 840  : 	void swap(_Myt& _Right)
; 841  : 		{	// swap with _Right
; 842  : 		if (this != _STD addressof(_Right))
; 843  : 			{	// different, swap base and buffer
; 844  : 			_Mybase::swap(_Right);
; 845  : 			_Filebuffer.swap(_Right._Filebuffer);
; 846  : 			}
; 847  : 		}
; 848  : 
; 849  : 	basic_ifstream(const _Myt&) = delete;
; 850  : 	_Myt& operator=(const _Myt&) = delete;
; 851  : 
; 852  : 	void open(const wchar_t *_Filename,
; 853  : 		ios_base::openmode _Mode = ios_base::in,
; 854  : 		int _Prot = (int)ios_base::_Openprot)
; 855  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 856  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 857  : 			_Myios::setstate(ios_base::failbit);
; 858  : 		else
; 859  : 			_Myios::clear();	// added with C++11
; 860  : 		}
; 861  : 
; 862  : 	void open(const wstring& _Str,
; 863  : 		ios_base::openmode _Mode = ios_base::in,
; 864  : 		int _Prot = (int)ios_base::_Openprot)
; 865  : 		{	// open a wide-named C stream -- EXTENSION
; 866  : 		open(_Str.c_str(), _Mode, _Prot);
; 867  : 		}
; 868  : 
; 869  : 	template<class _Path_ish = experimental::filesystem::path>
; 870  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 871  : 		ios_base::openmode _Mode = ios_base::in,
; 872  : 		int _Prot = (int)ios_base::_Openprot)
; 873  : 		{	// open a path-named C stream
; 874  : 		open(_Path.c_str(), _Mode, _Prot);
; 875  : 		}
; 876  : 
; 877  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 878  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 879  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 880  : 		open(_Filename, (ios_base::openmode)_Mode);
; 881  : 		}
; 882  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 883  : 
; 884  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 885  : 	void open(const unsigned short *_Filename,
; 886  : 		ios_base::openmode _Mode = ios_base::in,
; 887  : 		int _Prot = (int)ios_base::_Openprot)
; 888  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 889  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 890  : 			_Myios::setstate(ios_base::failbit);
; 891  : 		else
; 892  : 			_Myios::clear();	// added with C++11
; 893  : 		}
; 894  : 
; 895  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 896  : 	void open(const unsigned short *_Filename,
; 897  : 		ios_base::open_mode _Mode)
; 898  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 899  : 		open(_Filename, (ios_base::openmode)_Mode);
; 900  : 		}
; 901  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 902  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 903  : 
; 904  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 905  : 		{	// destroy the object
; 906  : 		}
; 907  : 
; 908  : 	_Myfb *rdbuf() const
; 909  : 		{	// return pointer to file buffer
; 910  : 		return ((_Myfb *)&_Filebuffer);
; 911  : 		}
; 912  : 
; 913  : 	bool is_open() const
; 914  : 		{	// test if C stream has been opened
; 915  : 		return (_Filebuffer.is_open());
; 916  : 		}
; 917  : 
; 918  : 	void open(const char *_Filename,
; 919  : 		ios_base::openmode _Mode = ios_base::in,
; 920  : 		int _Prot = (int)ios_base::_Openprot)
; 921  : 		{	// open a C stream with specified mode
; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  0011f	48 85 c0	 test	 rax, rax

; 923  : 			_Myios::setstate(ios_base::failbit);

  00122	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$12[rsp]
  00127	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012b	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$12[rsp]

; 760  : 		}
; 761  : 
; 762  : 	explicit basic_ifstream(const char *_Filename,
; 763  : 		ios_base::openmode _Mode = ios_base::in,
; 764  : 		int _Prot = (int)ios_base::_Openprot)
; 765  : 		: _Mybase(&_Filebuffer)
; 766  : 		{	// construct with named file and specified mode
; 767  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 768  : 			_Myios::setstate(ios_base::failbit);
; 769  : 		}
; 770  : 
; 771  : 	explicit basic_ifstream(const string& _Str,
; 772  : 		ios_base::openmode _Mode = ios_base::in,
; 773  : 		int _Prot = (int)ios_base::_Openprot)
; 774  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 775  : 		{	// construct with named file and specified mode
; 776  : 		}
; 777  : 
; 778  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 779  : 		ios_base::openmode _Mode = ios_base::in,
; 780  : 		int _Prot = (int)ios_base::_Openprot)
; 781  : 		: _Mybase(&_Filebuffer)
; 782  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 783  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 784  : 			_Myios::setstate(ios_base::failbit);
; 785  : 		}
; 786  : 
; 787  : 	explicit basic_ifstream(const wstring& _Str,
; 788  : 		ios_base::openmode _Mode = ios_base::in,
; 789  : 		int _Prot = (int)ios_base::_Openprot)
; 790  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 791  : 		{	// construct with wide-named file -- EXTENSION
; 792  : 		}
; 793  : 
; 794  : 	template<class _Path_ish = experimental::filesystem::path>
; 795  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 796  : 		ios_base::openmode _Mode = ios_base::in,
; 797  : 		int _Prot = (int)ios_base::_Openprot)
; 798  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 799  : 		{	// construct with path-named file
; 800  : 		}
; 801  : 
; 802  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 803  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 804  : 		ios_base::openmode _Mode = ios_base::in,
; 805  : 		int _Prot = (int)ios_base::_Openprot)
; 806  : 		: _Mybase(&_Filebuffer)
; 807  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 808  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 809  : 			_Myios::setstate(ios_base::failbit);
; 810  : 		}
; 811  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 812  : 
; 813  : 	explicit basic_ifstream(_Filet *_File)
; 814  : 		: _Mybase(&_Filebuffer),
; 815  : 			_Filebuffer(_File)
; 816  : 		{	// construct with specified C stream
; 817  : 		}
; 818  : 
; 819  : 	basic_ifstream(_Myt&& _Right)
; 820  : 		: _Mybase(&_Filebuffer)
; 821  : 		{	// construct by moving _Right
; 822  : 		_Assign_rv(_STD move(_Right));
; 823  : 		}
; 824  : 
; 825  : 	_Myt& operator=(_Myt&& _Right)
; 826  : 		{	// move from _Right
; 827  : 		_Assign_rv(_STD move(_Right));
; 828  : 		return (*this);
; 829  : 		}
; 830  : 
; 831  : 	void _Assign_rv(_Myt&& _Right)
; 832  : 		{	// assign by moving _Right
; 833  : 		if (this != _STD addressof(_Right))
; 834  : 			{	// different, worth moving
; 835  : 			_Filebuffer.close();
; 836  : 			this->swap(_Right);
; 837  : 			}
; 838  : 		}
; 839  : 
; 840  : 	void swap(_Myt& _Right)
; 841  : 		{	// swap with _Right
; 842  : 		if (this != _STD addressof(_Right))
; 843  : 			{	// different, swap base and buffer
; 844  : 			_Mybase::swap(_Right);
; 845  : 			_Filebuffer.swap(_Right._Filebuffer);
; 846  : 			}
; 847  : 		}
; 848  : 
; 849  : 	basic_ifstream(const _Myt&) = delete;
; 850  : 	_Myt& operator=(const _Myt&) = delete;
; 851  : 
; 852  : 	void open(const wchar_t *_Filename,
; 853  : 		ios_base::openmode _Mode = ios_base::in,
; 854  : 		int _Prot = (int)ios_base::_Openprot)
; 855  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 856  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 857  : 			_Myios::setstate(ios_base::failbit);
; 858  : 		else
; 859  : 			_Myios::clear();	// added with C++11
; 860  : 		}
; 861  : 
; 862  : 	void open(const wstring& _Str,
; 863  : 		ios_base::openmode _Mode = ios_base::in,
; 864  : 		int _Prot = (int)ios_base::_Openprot)
; 865  : 		{	// open a wide-named C stream -- EXTENSION
; 866  : 		open(_Str.c_str(), _Mode, _Prot);
; 867  : 		}
; 868  : 
; 869  : 	template<class _Path_ish = experimental::filesystem::path>
; 870  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 871  : 		ios_base::openmode _Mode = ios_base::in,
; 872  : 		int _Prot = (int)ios_base::_Openprot)
; 873  : 		{	// open a path-named C stream
; 874  : 		open(_Path.c_str(), _Mode, _Prot);
; 875  : 		}
; 876  : 
; 877  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 878  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 879  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 880  : 		open(_Filename, (ios_base::openmode)_Mode);
; 881  : 		}
; 882  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 883  : 
; 884  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 885  : 	void open(const unsigned short *_Filename,
; 886  : 		ios_base::openmode _Mode = ios_base::in,
; 887  : 		int _Prot = (int)ios_base::_Openprot)
; 888  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 889  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 890  : 			_Myios::setstate(ios_base::failbit);
; 891  : 		else
; 892  : 			_Myios::clear();	// added with C++11
; 893  : 		}
; 894  : 
; 895  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 896  : 	void open(const unsigned short *_Filename,
; 897  : 		ios_base::open_mode _Mode)
; 898  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 899  : 		open(_Filename, (ios_base::openmode)_Mode);
; 900  : 		}
; 901  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 902  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 903  : 
; 904  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 905  : 		{	// destroy the object
; 906  : 		}
; 907  : 
; 908  : 	_Myfb *rdbuf() const
; 909  : 		{	// return pointer to file buffer
; 910  : 		return ((_Myfb *)&_Filebuffer);
; 911  : 		}
; 912  : 
; 913  : 	bool is_open() const
; 914  : 		{	// test if C stream has been opened
; 915  : 		return (_Filebuffer.is_open());
; 916  : 		}
; 917  : 
; 918  : 	void open(const char *_Filename,
; 919  : 		ios_base::openmode _Mode = ios_base::in,
; 920  : 		int _Prot = (int)ios_base::_Openprot)
; 921  : 		{	// open a C stream with specified mode
; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00130	75 0d		 jne	 SHORT $LN47@SprawdŸ_u

; 923  : 			_Myios::setstate(ios_base::failbit);

  00132	48 03 c8	 add	 rcx, rax
  00135	8b d3		 mov	 edx, ebx
  00137	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 924  : 		else

  0013d	eb 0b		 jmp	 SHORT $LN48@SprawdŸ_u
$LN47@SprawdŸ_u:

; 925  : 			_Myios::clear();	// added with C++11

  0013f	48 03 c8	 add	 rcx, rax
  00142	33 d2		 xor	 edx, edx
  00144	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN48@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0014a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00152	f3 0f 7f 45 60	 movdqu	 XMMWORD PTR buf$13[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00157	32 d2		 xor	 dl, dl
  00159	88 55 50	 mov	 BYTE PTR buf$13[rbp-256], dl
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  0015c	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$12[rsp]
  00161	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  00165	f6 44 0c 50 01	 test	 BYTE PTR ustawienia$12[rsp+rcx+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  0016a	75 43		 jne	 SHORT $LN3@SprawdŸ_u
  0016c	0f 1f 40 00	 npad	 4
$LL2@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00170	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$12[rsp]
  00175	48 03 c8	 add	 rcx, rax
  00178	b2 0a		 mov	 dl, 10
  0017a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00180	44 0f b6 c0	 movzx	 r8d, al
  00184	48 8d 55 50	 lea	 rdx, QWORD PTR buf$13[rbp-256]
  00188	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$12[rsp]
  0018d	e8 00 00 00 00	 call	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 919  : 			Ustaw_ustawienia(buf); //Zamiana wczytanej lini na ustawienie programu

  00192	48 8d 4d 50	 lea	 rcx, QWORD PTR buf$13[rbp-256]
  00196	e8 00 00 00 00	 call	 ?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Ustaw_ustawienia

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  0019b	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$12[rsp]
  001a0	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 343  : 		return ((int)rdstate() & (int)eofbit);

  001a4	f6 44 0c 50 01	 test	 BYTE PTR ustawienia$12[rsp+rcx+16], 1
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 916  : 		while (!ustawienia.eof()) //Pêtla trwaj¹ca do koñca pliku

  001a9	74 c5		 je	 SHORT $LL2@SprawdŸ_u
  001ab	0f b6 55 50	 movzx	 edx, BYTE PTR buf$13[rbp-256]
$LN3@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001af	48 8b 45 68	 mov	 rax, QWORD PTR buf$13[rbp-232]
  001b3	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  001b7	72 3b		 jb	 SHORT $LN109@SprawdŸ_u

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001b9	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  001bc	48 8b 4d 50	 mov	 rcx, QWORD PTR buf$13[rbp-256]

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001c0	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  001c6	72 27		 jb	 SHORT $LN112@SprawdŸ_u

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  001c8	f6 c2 1f	 test	 dl, 31
  001cb	75 1b		 jne	 SHORT $_Invalid_parameter$151

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  001cd	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001d1	48 3b c1	 cmp	 rax, rcx
  001d4	73 12		 jae	 SHORT $_Invalid_parameter$151
  001d6	48 2b c8	 sub	 rcx, rax
  001d9	48 83 e9 08	 sub	 rcx, 8
  001dd	48 83 f9 1f	 cmp	 rcx, 31
  001e1	77 05		 ja	 SHORT $_Invalid_parameter$151

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001e3	48 8b c8	 mov	 rcx, rax
  001e6	eb 07		 jmp	 SHORT $LN112@SprawdŸ_u
$_Invalid_parameter$151:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001ee	cc		 int	 3
$LN112@SprawdŸ_u:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001ef	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN109@SprawdŸ_u:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  001f4	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  001fc	f3 0f 7f 45 60	 movdqu	 XMMWORD PTR buf$13[rbp-240], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00201	c6 45 50 00	 mov	 BYTE PTR buf$13[rbp-256], 0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 921  : 	}

  00205	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$12[rsp]
  0020a	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ

; 922  : 	else

  0020f	e9 f9 01 00 00	 jmp	 $LN5@SprawdŸ_u
$LN4@SprawdŸ_u:
  00214	41 b8 08 01 00
	00		 mov	 r8d, 264		; 00000108H
  0021a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  0021f	e8 00 00 00 00	 call	 memset

; 923  : 	{
; 924  : 		ofstream ustawienia; //Utworzenie typu do celu zapisu do pliku

  00224	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00229	e8 00 00 00 00	 call	 ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
  0022e	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  0022f	bb 02 00 00 00	 mov	 ebx, 2
  00234	44 8b c3	 mov	 r8d, ebx
  00237	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  0023e	48 8d 4c 24 48	 lea	 rcx, QWORD PTR ustawienia$11[rsp+8]
  00243	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1139 : 			_Myios::setstate(ios_base::failbit);

  00248	45 33 c0	 xor	 r8d, r8d

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  0024b	48 85 c0	 test	 rax, rax

; 1139 : 			_Myios::setstate(ios_base::failbit);

  0024e	48 8b 44 24 40	 mov	 rax, QWORD PTR ustawienia$11[rsp]
  00253	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00257	48 8d 44 24 40	 lea	 rax, QWORD PTR ustawienia$11[rsp]

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  0025c	75 0d		 jne	 SHORT $LN133@SprawdŸ_u

; 1139 : 			_Myios::setstate(ios_base::failbit);

  0025e	48 03 c8	 add	 rcx, rax
  00261	8b d3		 mov	 edx, ebx
  00263	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z

; 1140 : 		else

  00269	eb 0b		 jmp	 SHORT $LN134@SprawdŸ_u
$LN133@SprawdŸ_u:

; 1141 : 			_Myios::clear();	// added with C++11

  0026b	48 03 c8	 add	 rcx, rax
  0026e	33 d2		 xor	 edx, edx
  00270	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN134@SprawdŸ_u:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 926  : 		ustawienia << "iloœæ_minimalna_obrotów_ruletki 2" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych iloœæ_minimalna_obrotów_ruletki

  00276	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CC@GBEJJAFD@ilo?$JM?f_minimalna_obrot?sw_ruletki?5@
  0027d	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00282	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00287	48 8b c8	 mov	 rcx, rax
  0028a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00291	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 927  : 		ustawienia << "iloœæ_max_dodatkowych_obrotów_ruletki 3" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych iloœæ_max_dodatkowych_obrotów_ruletki

  00297	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CI@KGOEKJAK@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  0029e	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  002a3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002a8	48 8b c8	 mov	 rcx, rax
  002ab	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002b2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 928  : 		ustawienia << "czas_przeskoku_kulki_szybki 50" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przeskoku_kulki_szybki

  002b8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@NMHFMMDP@czas_przeskoku_kulki_szybki?550?$AA@
  002bf	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  002c4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002c9	48 8b c8	 mov	 rcx, rax
  002cc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 929  : 		ustawienia << "czas_przeskoku_kulki_wolny 75" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przeskoku_kulki_wolny

  002d9	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@ELNOLLHD@czas_przeskoku_kulki_wolny?575?$AA@
  002e0	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  002e5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002ea	48 8b c8	 mov	 rcx, rax
  002ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  002f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 930  : 		ustawienia << "czas_przerwy_dzwiêku 500" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czas_przerwy_dzwiêku

  002fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@OHAGCGBG@czas_przerwy_dzwi?jku?5500?$AA@
  00301	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00306	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0030b	48 8b c8	 mov	 rcx, rax
  0030e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00315	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 931  : 		ustawienia << "styl_liczenia_wygranej 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych styl_liczenia_wygranej

  0031b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@NJDCNPPC@styl_liczenia_wygranej?51?$AA@
  00322	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00327	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0032c	48 8b c8	 mov	 rcx, rax
  0032f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00336	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 932  : 		ustawienia << "kwota_pocz¹tkowa 1000" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych kwota_pocz¹tkowa

  0033c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@DNDOADBI@kwota_pocz?$LJtkowa?51000?$AA@
  00343	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00348	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0034d	48 8b c8	 mov	 rcx, rax
  00350	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00357	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 933  : 		ustawienia << "stan_dŸwiêków 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych stan_dŸwiêków

  0035d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BA@ILKGKHCK@stan_d?$JPwi?jk?sw?51?$AA@
  00364	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00369	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0036e	48 8b c8	 mov	 rcx, rax
  00371	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00378	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 934  : 		ustawienia << "czy_kontynuowaæ_grê 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych czy_kontynuowaæ_grê

  0037e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@EMABALP@czy_kontynuowa?f_gr?j?51?$AA@
  00385	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  0038a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0038f	48 8b c8	 mov	 rcx, rax
  00392	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00399	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 935  : 		ustawienia << "g³os_odczytu_numeru 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych g³os_odczytu_numeru

  0039f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BG@COMBOMN@g?$LDos_odczytu_numeru?51?$AA@
  003a6	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  003ab	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003b0	48 8b c8	 mov	 rcx, rax
  003b3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 936  : 		ustawienia << "g³os_szybkoœæ_odczytu_numeru 4" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych g³os_szybkoœæ_odczytu_numeru

  003c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BP@CJDLAIMM@g?$LDos_szybko?$JM?f_odczytu_numeru?54?$AA@
  003c7	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  003cc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003d1	48 8b c8	 mov	 rcx, rax
  003d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  003db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 937  : 		ustawienia << "efekty_dŸwiêkowe 1" << endl; //Wpisanie do pliku domyœnych ustawieñ dotycz¹cych efekty_dŸwiêkowe

  003e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@MFIDEEIL@efekty_d?$JPwi?jkowe?51?$AA@
  003e8	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  003ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003f2	48 8b c8	 mov	 rcx, rax
  003f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  003fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00402	90		 npad	 1

; 938  : 	}

  00403	48 8d 4c 24 40	 lea	 rcx, QWORD PTR ustawienia$11[rsp]
  00408	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
$LN5@SprawdŸ_u:

; 939  : 
; 940  : 	if (czas_przeskoku_kulki_wolny < czas_przeskoku_kulki_szybki) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0040d	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?czas_przeskoku_kulki_szybki@@3FA ; czas_przeskoku_kulki_szybki
  00414	66 39 05 00 00
	00 00		 cmp	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny
  0041b	7d 5e		 jge	 SHORT $LN6@SprawdŸ_u

; 941  : 	{
; 942  : 		cout << "Wartoœæ wolnego czasu przeskoku kulki musi byæ ni¿sza ni¿ wartoœæ szybkiego czasu przeskoku kulki" << endl; //(Wartoœci tych zmiennych to czas opóŸnienia wiêc im jest wy¿szy tym d³u¿sza przerwa)

  0041d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0GC@FGDMKFMP@Warto?$JM?f?5wolnego?5czasu?5przeskoku?5@
  00424	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0042b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00430	48 8b c8	 mov	 rcx, rax
  00433	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0043a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 943  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00440	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00447	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0044e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00453	48 8b c8	 mov	 rcx, rax
  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0045d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 944  : 		czas_przeskoku_kulki_szybki = 50; //Ustawienie wartoœci domyœlnej

  00463	b8 32 00 00 00	 mov	 eax, 50			; 00000032H
  00468	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki

; 945  : 		czas_przeskoku_kulki_wolny = 75; //Ustawienie wartoœci domyœlnej

  0046f	b8 4b 00 00 00	 mov	 eax, 75			; 0000004bH
  00474	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny
$LN6@SprawdŸ_u:

; 946  : 	}
; 947  : 	if (iloœæ_minimalna_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0047b	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki
  00482	66 85 c0	 test	 ax, ax
  00485	79 4f		 jns	 SHORT $LN7@SprawdŸ_u

; 948  : 	{
; 949  : 		cout << "Iloœæ minimalna obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  00487	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DL@EDLBNLFA@Ilo?$JM?f?5minimalna?5obrot?sw?5ruletki?5@
  0048e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00495	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0049a	48 8b c8	 mov	 rcx, rax
  0049d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  004a4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 950  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  004aa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  004b1	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004b8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  004bd	48 8b c8	 mov	 rcx, rax
  004c0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  004c7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 951  : 		iloœæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoœci domyœlnej

  004cd	8b c3		 mov	 eax, ebx
  004cf	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, bx ; iloœæ_minimalna_obrotów_ruletki
$LN7@SprawdŸ_u:

; 952  : 	}
; 953  : 	if (iloœæ_max_dodatkowych_obrotów_ruletki < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  004d6	be 03 00 00 00	 mov	 esi, 3
  004db	0f b7 0d 00 00
	00 00		 movzx	 ecx, WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA ; iloœæ_max_dodatkowych_obrotów_ruletki
  004e2	66 85 c9	 test	 cx, cx
  004e5	79 56		 jns	 SHORT $LN8@SprawdŸ_u

; 954  : 	{
; 955  : 		cout << "Iloœæ max obrotów ruletki nie mo¿e byæ mniejsza od 0" << endl;

  004e7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@PACHBLM@Ilo?$JM?f?5max?5obrot?sw?5ruletki?5nie?5mo@
  004ee	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  004f5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  004fa	48 8b c8	 mov	 rcx, rax
  004fd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00504	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 956  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0050a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00511	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00518	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0051d	48 8b c8	 mov	 rcx, rax
  00520	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00527	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 957  : 		iloœæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoœci domyœlnej

  0052d	8b ce		 mov	 ecx, esi
  0052f	66 89 0d 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, cx ; iloœæ_max_dodatkowych_obrotów_ruletki
  00536	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA ; iloœæ_minimalna_obrotów_ruletki
$LN8@SprawdŸ_u:

; 958  : 	}
; 959  : 	if ((iloœæ_minimalna_obrotów_ruletki == 0) && (iloœæ_max_dodatkowych_obrotów_ruletki == 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0053d	66 85 c0	 test	 ax, ax
  00540	75 59		 jne	 SHORT $LN9@SprawdŸ_u
  00542	66 85 c9	 test	 cx, cx
  00545	75 54		 jne	 SHORT $LN9@SprawdŸ_u

; 960  : 	{
; 961  : 		cout << "Jedna z deklaracji w sprawie obrotów ruletki musi byæ wiêksza od zera" << endl;

  00547	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@FJFKONPC@Jedna?5z?5deklaracji?5w?5sprawie?5obr@
  0054e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00555	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0055a	48 8b c8	 mov	 rcx, rax
  0055d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00564	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 962  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0056a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00571	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00578	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0057d	48 8b c8	 mov	 rcx, rax
  00580	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00587	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 963  : 		iloœæ_minimalna_obrotów_ruletki = 2; //Ustawienie wartoœci domyœlnej

  0058d	66 89 1d 00 00
	00 00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, bx ; iloœæ_minimalna_obrotów_ruletki

; 964  : 		iloœæ_max_dodatkowych_obrotów_ruletki = 3; //Ustawienie wartoœci domyœlnej

  00594	66 89 35 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, si ; iloœæ_max_dodatkowych_obrotów_ruletki
$LN9@SprawdŸ_u:
  0059b	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?styl_liczenia_wygranej@@3FA, 1 ; styl_liczenia_wygranej
  005a3	76 4d		 jbe	 SHORT $LN10@SprawdŸ_u

; 965  : 	}
; 966  : 	if (((styl_liczenia_wygranej > 1) || (styl_liczenia_wygranej < 0))) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 967  : 	{
; 968  : 		cout << "Styl liczeia wygranej przyjmuje wartoœci tylko 0 lub 1" << endl;

  005a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DH@EDACBMH@Styl?5liczeia?5wygranej?5przyjmuje?5@
  005ac	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005b3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  005b8	48 8b c8	 mov	 rcx, rax
  005bb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  005c2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 969  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  005c8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  005cf	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  005d6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  005db	48 8b c8	 mov	 rcx, rax
  005de	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  005e5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 970  : 		styl_liczenia_wygranej = 1; //Ustawienie wartoœci domyœlnej

  005eb	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, di ; styl_liczenia_wygranej
$LN10@SprawdŸ_u:

; 971  : 	}
; 972  : 	if (czas_przerwy_dzwiêku < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  005f2	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?czas_przerwy_dzwiêku@@3FA, 0 ; czas_przerwy_dzwiêku
  005fa	7d 52		 jge	 SHORT $LN12@SprawdŸ_u

; 973  : 	{
; 974  : 		cout << "Czas przerwy dŸwiêku nie mo¿e byæ mniejszy od zera" << endl;

  005fc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DD@CJFGHGHP@Czas?5przerwy?5d?$JPwi?jku?5nie?5mo?$LPe?5by@
  00603	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0060a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0060f	48 8b c8	 mov	 rcx, rax
  00612	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00619	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 975  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0061f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00626	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0062d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00632	48 8b c8	 mov	 rcx, rax
  00635	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0063c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 976  : 		czas_przerwy_dzwiêku = 500; //Ustawienie wartoœci domyœlnej

  00642	b8 f4 01 00 00	 mov	 eax, 500		; 000001f4H
  00647	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przerwy_dzwiêku@@3FA, ax ; czas_przerwy_dzwiêku
$LN12@SprawdŸ_u:

; 977  : 	}
; 978  : 	if (kwota_pocz¹tkowa < 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  0064e	83 3d 00 00 00
	00 00		 cmp	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, 0 ; kwota_pocz¹tkowa
  00655	7d 50		 jge	 SHORT $LN13@SprawdŸ_u

; 979  : 	{
; 980  : 		cout << "Kwota pocz¹tkowa nie mo¿e byæ mniejsza od zera" << endl;

  00657	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@ODEFLMCC@Kwota?5pocz?$LJtkowa?5nie?5mo?$LPe?5by?f?5mn@
  0065e	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00665	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0066a	48 8b c8	 mov	 rcx, rax
  0066d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00674	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 981  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0067a	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00681	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00688	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0068d	48 8b c8	 mov	 rcx, rax
  00690	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00697	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 982  : 		kwota_pocz¹tkowa = 1000; //Ustawienie wartoœci domyœlnej

  0069d	c7 05 00 00 00
	00 e8 03 00 00	 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, 1000 ; kwota_pocz¹tkowa, 000003e8H
$LN13@SprawdŸ_u:
  006a7	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 1 ; stan_dŸwiêków
  006af	76 4d		 jbe	 SHORT $LN14@SprawdŸ_u

; 983  : 	}
; 984  : 	if ((stan_dŸwiêków > 1) || (stan_dŸwiêków < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 985  : 	{
; 986  : 		cout << "Stan dŸwiêków przyjmuje wartoœci tylko 0 lub 1" << endl;

  006b1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CP@LNDFINPO@Stan?5d?$JPwi?jk?sw?5przyjmuje?5warto?$JMci@
  006b8	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  006c4	48 8b c8	 mov	 rcx, rax
  006c7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  006ce	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 987  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  006d4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  006db	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  006e2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  006e7	48 8b c8	 mov	 rcx, rax
  006ea	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  006f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 988  : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  006f7	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, di ; stan_dŸwiêków
$LN14@SprawdŸ_u:
  006fe	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, 1 ; czy_kontynuowaæ_grê
  00706	76 4d		 jbe	 SHORT $LN16@SprawdŸ_u

; 989  : 	}
; 990  : 	if ((czy_kontynuowaæ_grê > 1) || (czy_kontynuowaæ_grê < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 991  : 	{
; 992  : 		cout << "Opcja kontynuowania gry przyjmuje wartoœci tylko 0 lub 1" << endl;

  00708	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DJ@OKKJHGDF@Opcja?5kontynuowania?5gry?5przyjmuj@
  0070f	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00716	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0071b	48 8b c8	 mov	 rcx, rax
  0071e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 993  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0072b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00732	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00739	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0073e	48 8b c8	 mov	 rcx, rax
  00741	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00748	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 994  : 		czy_kontynuowaæ_grê = 1; //Ustawienie wartoœci domyœlnej

  0074e	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, di ; czy_kontynuowaæ_grê
$LN16@SprawdŸ_u:
  00755	66 83 3d 00 00
	00 00 0a	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, 10 ; g³os_odczytu_numeru
  0075d	76 4d		 jbe	 SHORT $LN18@SprawdŸ_u

; 995  : 	}
; 996  : 	if ((g³os_odczytu_numeru > 10) || (g³os_odczytu_numeru < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 997  : 	{
; 998  : 		cout << "Opcja g³os odczytu numeru przyjmuje wartoœci w przedziale [0;10]" << endl;

  0075f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EB@BAPPBOHB@Opcja?5g?$LDos?5odczytu?5numeru?5przyjm@
  00766	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0076d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00772	48 8b c8	 mov	 rcx, rax
  00775	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0077c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 999  : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00782	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00789	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00790	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00795	48 8b c8	 mov	 rcx, rax
  00798	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0079f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1000 : 		g³os_odczytu_numeru = 1; //Ustawienie wartoœci domyœlnej

  007a5	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, di ; g³os_odczytu_numeru
$LN18@SprawdŸ_u:
  007ac	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA ; g³os_szybkoœæ_odczytu_numeru
  007b3	66 ff c8	 dec	 ax
  007b6	66 83 f8 04	 cmp	 ax, 4
  007ba	76 52		 jbe	 SHORT $LN20@SprawdŸ_u

; 1001 : 	}
; 1002 : 	if ((g³os_szybkoœæ_odczytu_numeru > 5) || (g³os_szybkoœæ_odczytu_numeru < 1)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 1003 : 	{
; 1004 : 		cout << "Opcja szybkoœæ g³osu odczytu przyjmuje wartoœci w przedziale [1;5]" << endl;

  007bc	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0ED@BNKOADPP@Opcja?5szybko?$JM?f?5g?$LDosu?5odczytu?5prz@
  007c3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  007cf	48 8b c8	 mov	 rcx, rax
  007d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  007d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1005 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  007df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  007e6	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  007ed	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  007f2	48 8b c8	 mov	 rcx, rax
  007f5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  007fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1006 : 		g³os_szybkoœæ_odczytu_numeru = 4; //Ustawienie wartoœci domyœlnej

  00802	b8 04 00 00 00	 mov	 eax, 4
  00807	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru
$LN20@SprawdŸ_u:
  0080e	0f b7 05 00 00
	00 00		 movzx	 eax, WORD PTR ?efekty_dŸwiêkowe@@3FA ; efekty_dŸwiêkowe
  00815	66 83 f8 01	 cmp	 ax, 1
  00819	76 4f		 jbe	 SHORT $LN149@SprawdŸ_u

; 1007 : 	}
; 1008 : 	if ((efekty_dŸwiêkowe > 1) || (efekty_dŸwiêkowe < 0)) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach
; 1009 : 	{
; 1010 : 		cout << "Opcja efekty dŸwiêkowe przyjmuje wartoœci 0 lub 1" << endl;

  0081b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DC@HENMFLLO@Opcja?5efekty?5d?$JPwi?jkowe?5przyjmuje@
  00822	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00829	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0082e	48 8b c8	 mov	 rcx, rax
  00831	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00838	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1011 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  0083e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00845	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0084c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00851	48 8b c8	 mov	 rcx, rax
  00854	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0085b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1012 : 		efekty_dŸwiêkowe = 1; //Ustawienie wartoœci domyœlnej

  00861	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?efekty_dŸwiêkowe@@3FA, di ; efekty_dŸwiêkowe

; 1013 : 	}
; 1014 : 	if (efekty_dŸwiêkowe == 1 && stan_dŸwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  00868	eb 02		 jmp	 SHORT $LN140@SprawdŸ_u
$LN149@SprawdŸ_u:
  0086a	75 57		 jne	 SHORT $LN24@SprawdŸ_u
$LN140@SprawdŸ_u:
  0086c	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  00874	75 4d		 jne	 SHORT $LN24@SprawdŸ_u

; 1015 : 	{
; 1016 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dŸwiêków i w³¹czonych efektów dŸwiêkowych" << endl;

  00876	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0EG@GKBLFIMF@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  0087d	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00884	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00889	48 8b c8	 mov	 rcx, rax
  0088c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00893	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1017 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  00899	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  008a0	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008a7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  008ac	48 8b c8	 mov	 rcx, rax
  008af	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  008b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1018 : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  008bc	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, di ; stan_dŸwiêków
$LN24@SprawdŸ_u:

; 1019 : 	}
; 1020 : 	if (g³os_odczytu_numeru > 0 && stan_dŸwiêków == 0) //Sprawdzenie czy prawid³owo wprowadzono ustawienie, czy ³apie siê w zakresie i warunkach

  008c3	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?g³os_odczytu_numeru@@3FA, 0 ; g³os_odczytu_numeru
  008cb	7e 57		 jle	 SHORT $LN25@SprawdŸ_u
  008cd	66 83 3d 00 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 0 ; stan_dŸwiêków
  008d5	75 4d		 jne	 SHORT $LN25@SprawdŸ_u

; 1021 : 	{
; 1022 : 		cout << "Nie mo¿esz mieæ wy³¹czonych dŸwiêków i w³¹czon¹ mowê" << endl;

  008d7	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DF@LJEKJLPK@Nie?5mo?$LPesz?5mie?f?5wy?$LD?$LJczonych?5d?$JPwi@
  008de	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  008e5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  008ea	48 8b c8	 mov	 rcx, rax
  008ed	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  008f4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1023 : 		cout << "Ustawiam domyœlne ustawienie" << endl; //Poinformowanie u¿ytkownika, ¿e bie¿¹ce ustawienie zostaje zmienone na domyœlne

  008fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@KMOICOCN@Ustawiam?5domy?$JMlne?5ustawienie?$AA@
  00901	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00908	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0090d	48 8b c8	 mov	 rcx, rax
  00910	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00917	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1024 : 		stan_dŸwiêków = 1; //Ustawienie wartoœci domyœlnej

  0091d	66 89 3d 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, di ; stan_dŸwiêków
$LN25@SprawdŸ_u:

; 1025 : 	}
; 1026 : }

  00924	48 8b 4d 70	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-256]
  00928	48 33 cc	 xor	 rcx, rsp
  0092b	e8 00 00 00 00	 call	 __security_check_cookie
  00930	4c 8d 9c 24 80
	01 00 00	 lea	 r11, QWORD PTR [rsp+384]
  00938	49 8b 5b 10	 mov	 rbx, QWORD PTR [r11+16]
  0093c	49 8b 73 18	 mov	 rsi, QWORD PTR [r11+24]
  00940	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00944	49 8b e3	 mov	 rsp, r11
  00947	5d		 pop	 rbp
  00948	c3		 ret	 0
$LN148@SprawdŸ_u:
?SprawdŸ_ustawienia@@YAXXZ ENDP				; SprawdŸ_ustawienia
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN37@dtor$4
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 40	 lea	 rcx, QWORD PTR ustawienia$12[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN37@dtor$4:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$4
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$5@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$5
  0002e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$12[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$5@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$5
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$7@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$7
  00040	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$7@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$7
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$0@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$0
  0004e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$12[rdx]
  00055	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$0
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$1@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$1
  0005a	48 8d 8a 50 01
	00 00		 lea	 rcx, QWORD PTR buf$13[rdx]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$1
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$2@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$2
  00066	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$11[rdx]
  0006d	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$4
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN37@dtor$4
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 40	 lea	 rcx, QWORD PTR ustawienia$12[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN37@dtor$4:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$4@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$4
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$5@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$5
  0002e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$12[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$5@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$5
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$7@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$7
  00040	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$7@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$7
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$0@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$0
  0004e	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$12[rdx]
  00055	e9 00 00 00 00	 jmp	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$0@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$1@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$1
  0005a	48 8d 8a 50 01
	00 00		 lea	 rcx, QWORD PTR buf$13[rdx]
  00061	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$1@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T10 = 40
this$ = 48
ustawienia$11 = 64
ustawienia$12 = 64
buf$13 = 336
__$ArrayPad$ = 368
?dtor$2@?0??SprawdŸ_ustawienia@@YAXXZ@4HA PROC		; `SprawdŸ_ustawienia'::`1'::dtor$2
  00066	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR ustawienia$11[rdx]
  0006d	e9 00 00 00 00	 jmp	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
?dtor$2@?0??SprawdŸ_ustawienia@@YAXXZ@4HA ENDP		; `SprawdŸ_ustawienia'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor', COMDAT
$LN18:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8d b9 b0 00
	00 00		 lea	 rdi, QWORD PTR [rcx+176]

; 905  : 		{	// destroy the object

  0001b	48 8b 87 50 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-176]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  0002d	48 89 84 39 50
	ff ff ff	 mov	 QWORD PTR [rcx+rdi-176], rax
  00035	48 8b 87 50 ff
	ff ff		 mov	 rax, QWORD PTR [rdi-176]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00040	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  00046	89 94 39 4c ff
	ff ff		 mov	 DWORD PTR [rcx+rdi-180], edx

; 906  : 		}

  0004d	48 8d 9f 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rdi-160]

; 161  : 		{	// destroy the object

  00054	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0005b	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005e	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00066	74 2f		 je	 SHORT $LN12@vbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00068	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006c	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00070	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00073	75 22		 jne	 SHORT $LN12@vbase

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00075	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007c	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00083	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00086	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0008a	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008d	44 2b c2	 sub	 r8d, edx
  00090	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00094	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN12@vbase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00097	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0009b	74 09		 je	 SHORT $LN8@vbase

; 165  : 			close();

  0009d	48 8b cb	 mov	 rcx, rbx
  000a0	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a5	90		 npad	 1
$LN8@vbase:

; 166  : 		}

  000a6	48 8b cb	 mov	 rcx, rbx
  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000af	90		 npad	 1

; 906  : 		}

  000b0	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000bd	90		 npad	 1
  000be	48 8b cf	 mov	 rcx, rdi
  000c1	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000c6	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000ca	5f		 pop	 rdi
  000cb	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vbase destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
classSize$dead$ = 56
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2, COMDAT
$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	33 d2		 xor	 edx, edx
  00006	41 b8 10 01 00
	00		 mov	 r8d, 272		; 00000110H
  0000c	e8 00 00 00 00	 call	 memset
  00011	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00015	c3		 ret	 0
?__autoclassinit2@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAX_K@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::__autoclassinit2
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
$T25 = 72
wygrana$ = 160
kwota_zak³adu$ = 168
iloœæ_pieniêdzy$ = 176
log_ogólny$ = 184
log$ = 192
?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z PROC ; Og³oœ_wynik, COMDAT

; 1029 : {

$LN222:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 54		 push	 r12
  00007	41 55		 push	 r13
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 58	 sub	 rsp, 88			; 00000058H
  00011	48 c7 44 24 48
	fe ff ff ff	 mov	 QWORD PTR $T25[rsp], -2
  0001a	4d 8b e1	 mov	 r12, r9
  0001d	49 8b f0	 mov	 rsi, r8
  00020	4c 8b f2	 mov	 r14, rdx
  00023	4c 8b f9	 mov	 r15, rcx

; 1030 : 	if (wygrana >= kwota_zak³adu) //Je¿eli wygrana jest wiêksza lub równa kwocie zak³adu to znaczy, ¿e siê wygra³o zak³ad

  00026	4c 8b 84 24 c0
	00 00 00	 mov	 r8, QWORD PTR log$[rsp]
  0002e	45 33 ed	 xor	 r13d, r13d
  00031	44 89 6c 24 20	 mov	 DWORD PTR $T1[rsp], r13d
  00036	8b 09		 mov	 ecx, DWORD PTR [rcx]
  00038	8b 2a		 mov	 ebp, DWORD PTR [rdx]
  0003a	3b cd		 cmp	 ecx, ebp
  0003c	0f 8c 44 02 00
	00		 jl	 $LN2@Og?

; 1031 : 	{
; 1032 : 		iloœæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty wygranej z zak³adu

  00042	8b 16		 mov	 edx, DWORD PTR [rsi]
  00044	03 d1		 add	 edx, ecx
  00046	89 16		 mov	 DWORD PTR [rsi], edx

; 1033 : 		if (styl_liczenia_wygranej) iloœæ_pieniêdzy += kwota_zak³adu; //Dopisanie do salda kwoty zak³adu

  00048	66 44 39 2d 00
	00 00 00	 cmp	 WORD PTR ?styl_liczenia_wygranej@@3FA, r13w ; styl_liczenia_wygranej
  00050	74 07		 je	 SHORT $LN4@Og?
  00052	41 8b 0e	 mov	 ecx, DWORD PTR [r14]
  00055	03 ca		 add	 ecx, edx
  00057	89 0e		 mov	 DWORD PTR [rsi], ecx
$LN4@Og?:

; 1034 : 		log << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie wygranej zak³adu

  00059	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0005d	48 8b df	 mov	 rbx, rdi
  00060	4d 85 c0	 test	 r8, r8
  00063	49 0f 44 dd	 cmove	 rbx, r13
  00067	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  0006e	48 8b cb	 mov	 rcx, rbx
  00071	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00076	48 8b c8	 mov	 rcx, rax
  00079	41 8b 17	 mov	 edx, DWORD PTR [r15]
  0007c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00082	48 8b c8	 mov	 rcx, rax
  00085	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  0008c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1035 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00098	48 8b cb	 mov	 rcx, rbx
  0009b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	8b 16		 mov	 edx, DWORD PTR [rsi]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000ab	48 8b c8	 mov	 rcx, rax
  000ae	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000b5	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000ba	48 8b c8	 mov	 rcx, rax
  000bd	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000c4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1036 : 		log_ogólny << " Wygrywasz " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie wygranej zak³adu

  000ca	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GPFIMODH@?5Wygrywasz?5?$AA@
  000d1	49 8b cc	 mov	 rcx, r12
  000d4	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000d9	48 8b c8	 mov	 rcx, rax
  000dc	41 8b 17	 mov	 edx, DWORD PTR [r15]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000e5	48 8b c8	 mov	 rcx, rax
  000e8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1037 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000f4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  000fb	49 8b cc	 mov	 rcx, r12
  000fe	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00103	48 8b c8	 mov	 rcx, rax
  00106	8b 16		 mov	 edx, DWORD PTR [rsi]
  00108	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0010e	48 8b c8	 mov	 rcx, rax
  00111	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00118	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0011d	48 8b c8	 mov	 rcx, rax
  00120	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00127	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1038 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0012d	48 8b cf	 mov	 rcx, rdi
  00130	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1039 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00136	49 8b cc	 mov	 rcx, r12
  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1040 : 		if (stan_dŸwiêków)

  0013f	66 44 39 2d 00
	00 00 00	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, r13w ; stan_dŸwiêków
  00147	0f 84 4b 03 00
	00		 je	 $LN12@Og?

; 1041 : 		{
; 1042 : 			if (EfektyKompletne) //Je¿eli s¹ wszystkie pliki efektów dŸwiêkowych to

  0014d	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, r13b ; EfektyKompletne
  00154	0f 84 e7 00 00
	00		 je	 $LN6@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0015a	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
  00162	f3 0f 7f 44 24
	38		 movdqu	 XMMWORD PTR $T2[rsp+16], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00168	c6 44 24 28 00	 mov	 BYTE PTR $T2[rsp], 0
  0016d	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  00175	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  0017c	49 8d 50 07	 lea	 rdx, QWORD PTR [r8+7]
  00180	48 83 fa 10	 cmp	 rdx, 16
  00184	72 16		 jb	 SHORT $LN71@Og?

; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00186	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  0018b	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00190	4c 89 6c 24 38	 mov	 QWORD PTR $T2[rsp+16], r13
  00195	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
$LN71@Og?:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0019c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001a3	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  001ab	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  001b3	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  001b8	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  001bd	41 b8 07 00 00
	00		 mov	 r8d, 7
  001c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07KIPBKJCE@win?4wav?$AA@
  001ca	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]
  001cf	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1606 : 		const value_type * _Result = _Bx._Buf;

  001d4	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T2[rsp]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001d9	48 83 7c 24 40
	10		 cmp	 QWORD PTR $T2[rsp+24], 16

; 1607 : 		if (_Large_string_engaged())

  001df	48 0f 43 4c 24
	28		 cmovae	 rcx, QWORD PTR $T2[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1044 : 				PlaySound((G³os + "win.wav").c_str(), nullptr, SND_SYNC); //Odtworzenie efektu wygrania zak³adu

  001e5	45 33 c0	 xor	 r8d, r8d
  001e8	33 d2		 xor	 edx, edx
  001ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
  001f0	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001f1	48 8b 44 24 40	 mov	 rax, QWORD PTR $T2[rsp+24]
  001f6	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  001fa	0f 82 98 02 00
	00		 jb	 $LN12@Og?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00200	48 8b 4c 24 28	 mov	 rcx, QWORD PTR $T2[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00205	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00208	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0020e	72 27		 jb	 SHORT $LN201@Og?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00210	f6 c1 1f	 test	 cl, 31
  00213	75 1b		 jne	 SHORT $_Invalid_parameter$223

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00215	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00219	48 3b c1	 cmp	 rax, rcx
  0021c	73 12		 jae	 SHORT $_Invalid_parameter$223
  0021e	48 2b c8	 sub	 rcx, rax
  00221	48 83 e9 08	 sub	 rcx, 8
  00225	48 83 f9 1f	 cmp	 rcx, 31
  00229	77 05		 ja	 SHORT $_Invalid_parameter$223

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0022b	48 8b c8	 mov	 rcx, rax
  0022e	eb 07		 jmp	 SHORT $LN201@Og?
$_Invalid_parameter$223:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00230	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00236	cc		 int	 3
$LN201@Og?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00237	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1046 : 			else

  0023c	e9 57 02 00 00	 jmp	 $LN12@Og?
$LN6@Og?:

; 1047 : 			{
; 1048 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00241	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PBGHHLMH@?$AH?$AA@
  00248	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0024f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1049 : 				Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00254	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  0025b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
$LN221@Og?:

; 1050 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00261	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PBGHHLMH@?$AH?$AA@
  00268	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0026f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1051 : 				Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem

  00274	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  0027b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep

; 1052 : 				cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 1053 : 			}
; 1054 : 		}
; 1055 : 	}

  00281	e9 ff 01 00 00	 jmp	 $LN220@Og?
$LN2@Og?:

; 1056 : 	else if (wygrana == (kwota_zak³adu / 2)) //Je¿eli wygrana jest równa po³owie kwocie zak³adu to znaczy, ¿e dostaje siê zwrot po³owy kwoty zak³adu

  00286	8b c5		 mov	 eax, ebp
  00288	99		 cdq
  00289	2b c2		 sub	 eax, edx
  0028b	d1 f8		 sar	 eax, 1
  0028d	3b c8		 cmp	 ecx, eax
  0028f	0f 85 fa 00 00
	00		 jne	 $LN8@Og?

; 1057 : 	{
; 1058 : 		iloœæ_pieniêdzy += wygrana; //Dopisanie do salda kwoty zwrotu z zak³adu

  00295	01 0e		 add	 DWORD PTR [rsi], ecx

; 1059 : 		log << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie zwrotu zak³adu

  00297	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0029b	48 8b df	 mov	 rbx, rdi
  0029e	4d 85 c0	 test	 r8, r8
  002a1	49 0f 44 dd	 cmove	 rbx, r13
  002a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  002ac	48 8b cb	 mov	 rcx, rbx
  002af	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002b4	48 8b c8	 mov	 rcx, rax
  002b7	41 8b 17	 mov	 edx, DWORD PTR [r15]
  002ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  002c0	48 8b c8	 mov	 rcx, rax
  002c3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  002ca	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1060 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  002cf	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  002d6	48 8b cb	 mov	 rcx, rbx
  002d9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002de	48 8b c8	 mov	 rcx, rax
  002e1	8b 16		 mov	 edx, DWORD PTR [rsi]
  002e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  002e9	48 8b c8	 mov	 rcx, rax
  002ec	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  002f3	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  002f8	48 8b c8	 mov	 rcx, rax
  002fb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00302	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1061 : 		log_ogólny << " Dostajesz polowe zak³adu " << wygrana << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie zwrotu zak³adu

  00308	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LJEGNEAJ@?5Dostajesz?5polowe?5zak?$LDadu?5?$AA@
  0030f	49 8b cc	 mov	 rcx, r12
  00312	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00317	48 8b c8	 mov	 rcx, rax
  0031a	41 8b 17	 mov	 edx, DWORD PTR [r15]
  0031d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00323	48 8b c8	 mov	 rcx, rax
  00326	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  0032d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1062 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  00332	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00339	49 8b cc	 mov	 rcx, r12
  0033c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00341	48 8b c8	 mov	 rcx, rax
  00344	8b 16		 mov	 edx, DWORD PTR [rsi]
  00346	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0034c	48 8b c8	 mov	 rcx, rax
  0034f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00356	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0035b	48 8b c8	 mov	 rcx, rax
  0035e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00365	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1063 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0036b	48 8b cf	 mov	 rcx, rdi
  0036e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1064 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00374	49 8b cc	 mov	 rcx, r12
  00377	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1065 : 		if (!EfektyKompletne) //Je¿eli nie ma wszystkich plików efektów dŸwiêkowych to

  0037d	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, r13b ; EfektyKompletne
  00384	0f 85 0e 01 00
	00		 jne	 $LN12@Og?

; 1066 : 		{
; 1067 : 			cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 1068 : 			Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem
; 1069 : 			cout << "\a"; //Wywo³anie pikniêcia w g³oœniku
; 1070 : 		}
; 1071 : 	}

  0038a	e9 d2 fe ff ff	 jmp	 $LN221@Og?
$LN8@Og?:

; 1072 : 	else if (wygrana == 0) //Je¿eli wygrana jest równa 0 to znaczy, ¿e siê zak³ad przegra³o

  0038f	85 c9		 test	 ecx, ecx
  00391	0f 85 01 01 00
	00		 jne	 $LN12@Og?

; 1073 : 	{
; 1074 : 		log << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o przegranej kwocie

  00397	49 8d 78 10	 lea	 rdi, QWORD PTR [r8+16]
  0039b	48 8b df	 mov	 rbx, rdi
  0039e	4d 85 c0	 test	 r8, r8
  003a1	49 0f 44 dd	 cmove	 rbx, r13
  003a5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  003ac	48 8b cb	 mov	 rcx, rbx
  003af	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003b4	48 8b c8	 mov	 rcx, rax
  003b7	8b d5		 mov	 edx, ebp
  003b9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  003bf	48 8b c8	 mov	 rcx, rax
  003c2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  003c9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1075 : 		log << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  003ce	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  003d5	48 8b cb	 mov	 rcx, rbx
  003d8	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003dd	48 8b c8	 mov	 rcx, rax
  003e0	8b 16		 mov	 edx, DWORD PTR [rsi]
  003e2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  003e8	48 8b c8	 mov	 rcx, rax
  003eb	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  003f2	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003f7	48 8b c8	 mov	 rcx, rax
  003fa	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00401	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1076 : 		log_ogólny << " Przegrales " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o przegranej kwocie

  00407	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@NPCHEJIF@?5Przegrales?5?$AA@
  0040e	49 8b cc	 mov	 rcx, r12
  00411	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00416	48 8b c8	 mov	 rcx, rax
  00419	41 8b 16	 mov	 edx, DWORD PTR [r14]
  0041c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00422	48 8b c8	 mov	 rcx, rax
  00425	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  0042c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1077 : 		log_ogólny << " Posiadasz " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  00431	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@GNFNLGIH@?5Posiadasz?5?$AA@
  00438	49 8b cc	 mov	 rcx, r12
  0043b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00440	48 8b c8	 mov	 rcx, rax
  00443	8b 16		 mov	 edx, DWORD PTR [rsi]
  00445	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0044b	48 8b c8	 mov	 rcx, rax
  0044e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00455	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0045a	48 8b c8	 mov	 rcx, rax
  0045d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00464	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1078 : 		log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0046a	48 8b cf	 mov	 rcx, rdi
  0046d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1079 : 		log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00473	49 8b cc	 mov	 rcx, r12
  00476	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1080 : 		if (!EfektyKompletne) cout << "\a";  //Je¿eli nie ma wszystkich plików efektów dŸwiêkowych to wywo³anie pikniêcia w g³oœniku

  0047c	44 38 2d 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, r13b ; EfektyKompletne
  00483	75 13		 jne	 SHORT $LN12@Og?
$LN220@Og?:
  00485	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PBGHHLMH@?$AH?$AA@
  0048c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00493	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN12@Og?:

; 1081 : 	}
; 1082 : }

  00498	48 83 c4 58	 add	 rsp, 88			; 00000058H
  0049c	41 5f		 pop	 r15
  0049e	41 5e		 pop	 r14
  004a0	41 5d		 pop	 r13
  004a2	41 5c		 pop	 r12
  004a4	5f		 pop	 rdi
  004a5	5e		 pop	 rsi
  004a6	5d		 pop	 rbp
  004a7	5b		 pop	 rbx
  004a8	c3		 ret	 0
$LN219@Og?:
?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ENDP ; Og³oœ_wynik
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T25 = 72
wygrana$ = 160
kwota_zak³adu$ = 168
iloœæ_pieniêdzy$ = 176
log_ogólny$ = 184
log$ = 192
?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `Og³oœ_wynik'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN30@dtor$1
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 28	 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN30@dtor$1:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `Og³oœ_wynik'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
$T25 = 72
wygrana$ = 160
kwota_zak³adu$ = 168
iloœæ_pieniêdzy$ = 176
log_ogólny$ = 184
log$ = 192
?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA PROC ; `Og³oœ_wynik'::`1'::dtor$1
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN30@dtor$1
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8d 4d 28	 lea	 rcx, QWORD PTR $T2[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN30@dtor$1:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$1@?0??Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z@4HA ENDP ; `Og³oœ_wynik'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z
_TEXT	SEGMENT
log_ogólny$ = 48
log$ = 56
iloœæ_pieniêdzy$ = 64
?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z PROC ; Koniec_gry, COMDAT

; 1085 : {

$LN26:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00015	4c 8b f2	 mov	 r14, rdx
  00018	48 8b f9	 mov	 rdi, rcx

; 1086 : 	cout << endl << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Poinformowanie u¿ytkownika o saldzie konta

  0001b	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00022	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00029	49 8b f0	 mov	 rsi, r8
  0002c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00032	48 8b c8	 mov	 rcx, rax
  00035	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  0003c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00041	8b 16		 mov	 edx, DWORD PTR [rsi]
  00043	48 8b c8	 mov	 rcx, rax
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0004c	48 8b c8	 mov	 rcx, rax
  0004f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00056	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1087 : 	log << endl << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu aktualnego informacji o saldzie konta u¿ytkownika

  0006b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00072	49 8d 4e 10	 lea	 rcx, QWORD PTR [r14+16]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  0007c	48 8b c8	 mov	 rcx, rax
  0007f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  00086	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0008b	8b 16		 mov	 edx, DWORD PTR [rsi]
  0008d	48 8b c8	 mov	 rcx, rax
  00090	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00096	48 8b c8	 mov	 rcx, rax
  00099	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000a0	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a5	48 8b c8	 mov	 rcx, rax
  000a8	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1088 : 	log_ogólny << "Koñczysz grê z wynikiem " << iloœæ_pieniêdzy << "$" << endl; //Zapisanie do bufora pliku logu ogólnego informacji o saldzie konta u¿ytkownika

  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BJ@GCHIFPGC@Ko?qczysz?5gr?j?5z?5wynikiem?5?$AA@
  000bc	48 8b cf	 mov	 rcx, rdi
  000bf	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000c4	8b 16		 mov	 edx, DWORD PTR [rsi]
  000c6	48 8b c8	 mov	 rcx, rax
  000c9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000cf	48 8b c8	 mov	 rcx, rax
  000d2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000d9	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000de	48 8b c8	 mov	 rcx, rax
  000e1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  000e8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1089 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000ee	49 8d 4e 10	 lea	 rcx, QWORD PTR [r14+16]
  000f2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1090 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000f8	48 8b cf	 mov	 rcx, rdi
  000fb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 1381 : 		if (_Filebuffer.close() == 0)

  00101	49 8d 4e 18	 lea	 rcx, QWORD PTR [r14+24]
  00105	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  0010a	48 85 c0	 test	 rax, rax
  0010d	75 17		 jne	 SHORT $LN18@Koniec_gry

; 1382 : 			_Myios::setstate(ios_base::failbit);

  0010f	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00112	45 33 c0	 xor	 r8d, r8d
  00115	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00119	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  0011d	49 03 ce	 add	 rcx, r14
  00120	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN18@Koniec_gry:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1092 : 	remove("log_aktualny.txt"); //Usuniêcie pliku log aktualny poniewa¿ skoñczy³o siê grê

  00126	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  0012d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_remove

; 1093 : 
; 1094 : 	if (stan_dŸwiêków == 1) //Je¿eli stan_dŸwiêków == 1

  00133	66 83 3d 00 00
	00 00 01	 cmp	 WORD PTR ?stan_dŸwiêków@@3FA, 1 ; stan_dŸwiêków
  0013b	75 59		 jne	 SHORT $LN3@Koniec_gry

; 1095 : 		if (iloœæ_pieniêdzy == 0) //Je¿eli bud¿et jest równy 0 to

  0013d	83 3e 00	 cmp	 DWORD PTR [rsi], 0
  00140	75 54		 jne	 SHORT $LN3@Koniec_gry

; 1096 : 			if (EfektyKompletne) PlaySound("Efekty_dŸwiêkowe/bankrut.wav", nullptr, SND_SYNC); //Je¿eli pliki efektów s¹ dostêpne, odtworzenie efektu bankruta

  00142	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  00149	74 14		 je	 SHORT $LN7@Koniec_gry
  0014b	45 33 c0	 xor	 r8d, r8d
  0014e	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BN@JMMCOBLJ@Efekty_d?$JPwi?jkowe?1bankrut?4wav?$AA@
  00155	33 d2		 xor	 edx, edx
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA

; 1097 : 			else //W przeciwym wypadku

  0015d	eb 37		 jmp	 SHORT $LN3@Koniec_gry
$LN7@Koniec_gry:

; 1098 : 				for (unsigned short i = 0; i < 5; ++i) //Rozpoczêcie pêtli która wykona 5 obrotów

  0015f	bb 05 00 00 00	 mov	 ebx, 5
  00164	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@Koniec_gry:

; 1099 : 				{
; 1100 : 					cout << "\a"; //Wywo³anie pikniêcia w g³oœniku

  00170	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00177	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01PBGHHLMH@?$AH?$AA@
  0017e	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1101 : 					Sleep(czas_przerwy_dzwiêku); //Przerwa przed kolejnym pikniêciem //Przerwa przed kolejnym pikniêciem

  00183	0f bf 0d 00 00
	00 00		 movsx	 ecx, WORD PTR ?czas_przerwy_dzwiêku@@3FA ; czas_przerwy_dzwiêku
  0018a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_Sleep
  00190	48 83 eb 01	 sub	 rbx, 1
  00194	75 da		 jne	 SHORT $LL4@Koniec_gry
$LN3@Koniec_gry:

; 1102 : 				}
; 1103 : 
; 1104 : 	if (iloœæ_pieniêdzy > kwota_pocz¹tkowa && iloœæ_pieniêdzy < kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwiêkszy³o siê bud¿et

  00196	44 8b 06	 mov	 r8d, DWORD PTR [rsi]
  00199	44 8b 0d 00 00
	00 00		 mov	 r9d, DWORD PTR ?kwota_pocz¹tkowa@@3HA ; kwota_pocz¹tkowa
  001a0	45 3b c1	 cmp	 r8d, r9d
  001a3	7e 44		 jle	 SHORT $LN9@Koniec_gry
  001a5	43 8d 04 09	 lea	 eax, DWORD PTR [r9+r9]
  001a9	44 3b c0	 cmp	 r8d, eax
  001ac	7d 3b		 jge	 SHORT $LN9@Koniec_gry

; 1105 : 	{
; 1106 : 		cout << "Gratuluje zwiêkszy³eœ swój zasób finansowy" << endl; //Wyœwietlenie gratulacji z powodu zwiêkszenia bud¿etu

  001ae	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CL@DCKMMPCF@Gratuluje?5zwi?jkszy?$LDe?$JM?5sw?sj?5zas?sb@
  001bc	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  001c1	48 8b c8	 mov	 rcx, rax
  001c4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  001cb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1107 : 		if (EfektyKompletne) //Je¿eli pliki efektów s¹ dostêpne

  001d1	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  001d8	74 79		 je	 SHORT $LN15@Koniec_gry

; 1108 : 			if (rand() % 1) PlaySound("Efekty_dŸwiêkowe/wygrana1.wav", nullptr, SND_SYNC); //Wylosowanie numeru otworzonego efektu, odtworzenie je¿eli wylosowano efekt 0

  001da	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_rand

; 1109 : 			else PlaySound("Efekty_dŸwiêkowe/wygrana2.wav", nullptr, SND_SYNC); //Odtworzenie je¿eli wylosowano efekt 1

  001e0	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BO@GEPIDPJJ@Efekty_d?$JPwi?jkowe?1wygrana2?4wav?$AA@

; 1110 : 	}

  001e7	eb 5f		 jmp	 SHORT $LN24@Koniec_gry
$LN9@Koniec_gry:

; 1111 : 	else if (iloœæ_pieniêdzy >= kwota_pocz¹tkowa * 2) //Sprawdzenie czy zwielokrotniono przynajmniej 2 razy bud¿et

  001e9	43 8d 0c 09	 lea	 ecx, DWORD PTR [r9+r9]
  001ed	44 3b c1	 cmp	 r8d, ecx
  001f0	7c 61		 jl	 SHORT $LN15@Koniec_gry

; 1112 : 	{
; 1113 : 		cout << "Gratuluje zwiêkszy³eœ " << iloœæ_pieniêdzy / kwota_pocz¹tkowa << " krotnie swój zasób finansowy" << endl; //Wyœwietlenie gratulacji z powodu zwielokrotnienia przynajmniej 2 razy bud¿etu

  001f2	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  001f9	41 8b c0	 mov	 eax, r8d
  001fc	99		 cdq
  001fd	41 f7 f9	 idiv	 r9d
  00200	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@GDCLDFHN@Gratuluje?5zwi?jkszy?$LDe?$JM?5?$AA@
  00207	8b d8		 mov	 ebx, eax
  00209	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0020e	48 8b c8	 mov	 rcx, rax
  00211	8b d3		 mov	 edx, ebx
  00213	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  00219	48 8b c8	 mov	 rcx, rax
  0021c	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BO@CAHFKDBP@?5krotnie?5sw?sj?5zas?sb?5finansowy?$AA@
  00223	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00228	48 8b c8	 mov	 rcx, rax
  0022b	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z

; 1114 : 		if (EfektyKompletne) PlaySound("Efekty_dŸwiêkowe/zwielokrotnenie.wav", nullptr, SND_SYNC); //Odtworzenie efektu dŸwiêkowego wzamian za zwielokrotnienie bud¿etu, je¿eli pliki efektów s¹ dostêpne

  00238	80 3d 00 00 00
	00 00		 cmp	 BYTE PTR ?EfektyKompletne@@3_NA, 0 ; EfektyKompletne
  0023f	74 12		 je	 SHORT $LN15@Koniec_gry
  00241	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0CF@PNMICDIM@Efekty_d?$JPwi?jkowe?1zwielokrotnenie@
$LN24@Koniec_gry:
  00248	45 33 c0	 xor	 r8d, r8d
  0024b	33 d2		 xor	 edx, edx
  0024d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_PlaySoundA
$LN15@Koniec_gry:

; 1115 : 	}
; 1116 : }

  00253	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00258	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0025d	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  00262	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00266	41 5e		 pop	 r14
  00268	c3		 ret	 0
?Koniec_gry@@YAXAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEBH@Z ENDP ; Koniec_gry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z
_TEXT	SEGMENT
$T1 = 48
wygrana$ = 144
kwota_zak³adu$ = 152
iloœæ_pieniêdzy$ = 160
log_ogólny$ = 168
log$ = 176
co_kontynuowaæ$ = 184
typ_zak³adu$ = 192
wylosowana_liczba$ = 200
?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z PROC ; Pêtla_g³ówna, COMDAT

; 1119 : {

$LN281:
  00000	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	55		 push	 rbp
  0000c	56		 push	 rsi
  0000d	41 54		 push	 r12
  0000f	41 55		 push	 r13
  00011	41 56		 push	 r14
  00013	41 57		 push	 r15
  00015	48 83 ec 50	 sub	 rsp, 80			; 00000050H

; 1120 : 	if (co_kontynuowaæ == 'n') Wczytaj_Kwotê_Zak³adu(kwota_zak³adu, iloœæ_pieniêdzy); //Przypisanie do zmiennej pobranej od u¿ytkownika kwoty zak³adu

  00019	48 8b b4 24 b8
	00 00 00	 mov	 rsi, QWORD PTR co_kontynuowaæ$[rsp]
  00021	49 8b e9	 mov	 rbp, r9
  00024	49 8b d8	 mov	 rbx, r8
  00027	4c 8b fa	 mov	 r15, rdx
  0002a	80 3e 6e	 cmp	 BYTE PTR [rsi], 110	; 0000006eH
  0002d	75 0d		 jne	 SHORT $LN2@P?
  0002f	48 8b d3	 mov	 rdx, rbx
  00032	49 8b cf	 mov	 rcx, r15
  00035	e8 00 00 00 00	 call	 ?Wczytaj_Kwotê_Zak³adu@@YAXAEAHAEBH@Z ; Wczytaj_Kwotê_Zak³adu
  0003a	eb 3e		 jmp	 SHORT $LN3@P?
$LN2@P?:

; 1121 : 	else cout << "Obstawiono za " << kwota_zak³adu << "$" << endl; //Wypisanie wczytanej kwoty zak³adu

  0003c	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00043	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  0004a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0004f	41 8b 17	 mov	 edx, DWORD PTR [r15]
  00052	48 8b c8	 mov	 rcx, rax
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  0005b	48 8b c8	 mov	 rcx, rax
  0005e	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  00065	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  0006a	48 8b c8	 mov	 rcx, rax
  0006d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN3@P?:

; 1122 : 	if (co_kontynuowaæ == 'n') log << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu aktualnego informacji o kwocie obstawionego zak³adu

  0007a	4c 8b ac 24 b0
	00 00 00	 mov	 r13, QWORD PTR log$[rsp]
  00082	45 33 f6	 xor	 r14d, r14d
  00085	80 3e 6e	 cmp	 BYTE PTR [rsi], 110	; 0000006eH
  00088	75 61		 jne	 SHORT $LN5@P?
  0008a	4d 85 ed	 test	 r13, r13
  0008d	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  00091	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  00098	49 0f 44 ce	 cmove	 rcx, r14
  0009c	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000a1	41 8b 17	 mov	 edx, DWORD PTR [r15]
  000a4	48 8b c8	 mov	 rcx, rax
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000ad	48 8b c8	 mov	 rcx, rax
  000b0	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000b7	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1123 : 	if (co_kontynuowaæ == 'n') log_ogólny << "Obstawiono za " << kwota_zak³adu << "$"; //Zapisanie do bufora pliku logu ogólnego informacji o kwocie obstawionego zak³adu

  000bc	80 3e 6e	 cmp	 BYTE PTR [rsi], 110	; 0000006eH
  000bf	75 2a		 jne	 SHORT $LN5@P?
  000c1	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0P@LMKDJHDC@Obstawiono?5za?5?$AA@
  000c8	48 8b cd	 mov	 rcx, rbp
  000cb	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  000d0	41 8b 17	 mov	 edx, DWORD PTR [r15]
  000d3	48 8b c8	 mov	 rcx, rax
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
  000dc	48 8b c8	 mov	 rcx, rax
  000df	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_01EPMOAMKG@$?$AA@
  000e6	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
$LN5@P?:

; 1124 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  000eb	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  000ef	48 89 bc 24 98
	00 00 00	 mov	 QWORD PTR [rsp+152], rdi
  000f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1125 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  000fd	48 8b cd	 mov	 rcx, rbp
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  00106	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00109	3c 6e		 cmp	 al, 110			; 0000006eH
  0010b	74 4d		 je	 SHORT $LN8@P?
  0010d	3c 6b		 cmp	 al, 107			; 0000006bH
  0010f	74 49		 je	 SHORT $LN8@P?

; 1127 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00111	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00118	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BD@IOLLNBIB@Obstawiono?5zak?$LDad?5?$AA@
  0011f	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  00124	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR typ_zak³adu$[rsp]

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0012c	48 8b d7	 mov	 rdx, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0012f	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1607 : 		if (_Large_string_engaged())

  00134	72 03		 jb	 SHORT $LN201@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00136	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN201@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  00139	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  0013d	48 8b c8	 mov	 rcx, rax
  00140	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
  00145	48 8b c8	 mov	 rcx, rax
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1127 : 	else cout << "Obstawiono zak³ad " << typ_zak³adu << endl; //Wypisanie wczytanego typu zak³adu

  00148	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
  00155	e9 e3 00 00 00	 jmp	 $LN161@P?
$LN8@P?:

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0015a	48 8d 4c 24 30	 lea	 rcx, QWORD PTR $T1[rsp]
  0015f	e8 00 00 00 00	 call	 ?Obstaw@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@XZ ; Obstaw
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2086 : 		if (this != _STD addressof(_Right))

  00164	48 8b bc 24 c0
	00 00 00	 mov	 rdi, QWORD PTR typ_zak³adu$[rsp]
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1126 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') typ_zak³adu = Obstaw(); //Przypisanie do zmiennej pobranej od u¿ytkownika typu zak³adu

  0016c	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2086 : 		if (this != _STD addressof(_Right))

  0016f	48 3b f8	 cmp	 rdi, rax
  00172	74 77		 je	 SHORT $LN131@P?

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00174	48 8b 4f 18	 mov	 rcx, QWORD PTR [rdi+24]
  00178	48 83 f9 10	 cmp	 rcx, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0017c	72 41		 jb	 SHORT $LN69@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0017e	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00181	48 ff c1	 inc	 rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00184	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  0018b	72 2a		 jb	 SHORT $LN72@P?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0018d	f6 c2 1f	 test	 dl, 31
  00190	0f 85 a2 01 00
	00		 jne	 $_Invalid_parameter$282

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00196	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0019a	48 3b c2	 cmp	 rax, rdx
  0019d	0f 83 95 01 00
	00		 jae	 $_Invalid_parameter$282
  001a3	48 2b d0	 sub	 rdx, rax
  001a6	48 83 ea 08	 sub	 rdx, 8
  001aa	48 83 fa 1f	 cmp	 rdx, 31
  001ae	0f 87 84 01 00
	00		 ja	 $_Invalid_parameter$282

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001b4	48 8b d0	 mov	 rdx, rax
$LN72@P?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001b7	48 8b ca	 mov	 rcx, rdx
  001ba	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN69@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  001bf	4c 89 77 10	 mov	 QWORD PTR [rdi+16], r14

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001c3	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001cb	44 88 37	 mov	 BYTE PTR [rdi], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  001ce	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  001d1	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  001d4	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  001d8	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  001dc	4c 89 73 10	 mov	 QWORD PTR [rbx+16], r14

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  001e0	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  001e8	44 88 33	 mov	 BYTE PTR [rbx], r14b
$LN131@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001eb	48 8b 44 24 48	 mov	 rax, QWORD PTR $T1[rsp+24]
  001f0	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  001f4	72 3f		 jb	 SHORT $LN276@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  001f6	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  001fb	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  001fe	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00204	72 2a		 jb	 SHORT $LN164@P?

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00206	f6 c1 1f	 test	 cl, 31
  00209	0f 85 30 01 00
	00		 jne	 $_Invalid_parameter$283

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0020f	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00213	48 3b c1	 cmp	 rax, rcx
  00216	0f 83 23 01 00
	00		 jae	 $_Invalid_parameter$283
  0021c	48 2b c8	 sub	 rcx, rax
  0021f	48 83 e9 08	 sub	 rcx, 8
  00223	48 83 f9 1f	 cmp	 rcx, 31
  00227	0f 87 12 01 00
	00		 ja	 $_Invalid_parameter$283

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0022d	48 8b c8	 mov	 rcx, rax
$LN164@P?:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00230	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN276@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3709 : 		if (_My_data._Large_string_engaged())

  00235	48 8b 9c 24 a0
	00 00 00	 mov	 rbx, QWORD PTR iloœæ_pieniêdzy$[rsp]
$LN161@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1128 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu aktualnego informacji o typie obstawionego zak³adu

  0023d	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00240	3c 6e		 cmp	 al, 110			; 0000006eH
  00242	74 04		 je	 SHORT $LN10@P?
  00244	3c 6b		 cmp	 al, 107			; 0000006bH
  00246	75 30		 jne	 SHORT $LN9@P?
$LN10@P?:
  00248	4d 85 ed	 test	 r13, r13
  0024b	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  0024f	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  00256	49 0f 44 ce	 cmove	 rcx, r14
  0025a	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0025f	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00264	48 8b d7	 mov	 rdx, rdi

; 1607 : 		if (_Large_string_engaged())

  00267	72 03		 jb	 SHORT $LN228@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00269	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN228@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0026c	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  00270	48 8b c8	 mov	 rcx, rax
  00273	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
$LN9@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1129 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k') log_ogólny << " Obstawiono zaklad " << typ_zak³adu; //Zapisanie do bufora pliku logu ogólnego informacji o typie obstawionego zak³adu

  00278	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0027b	3c 6e		 cmp	 al, 110			; 0000006eH
  0027d	74 04		 je	 SHORT $LN12@P?
  0027f	3c 6b		 cmp	 al, 107			; 0000006bH
  00281	75 28		 jne	 SHORT $LN11@P?
$LN12@P?:
  00283	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@EKDPDLOA@?5Obstawiono?5zaklad?5?$AA@
  0028a	48 8b cd	 mov	 rcx, rbp
  0028d	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00292	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00297	48 8b d7	 mov	 rdx, rdi

; 1607 : 		if (_Large_string_engaged())

  0029a	72 03		 jb	 SHORT $LN255@P?
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0029c	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
$LN255@P?:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0029f	4c 8b 47 10	 mov	 r8, QWORD PTR [rdi+16]
  002a3	48 8b c8	 mov	 rcx, rax
  002a6	e8 00 00 00 00	 call	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
$LN11@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1130 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  002ab	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  002af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1131 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  002b5	48 8b cd	 mov	 rcx, rbp
  002b8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  002be	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  002c1	b9 09 12 00 00	 mov	 ecx, 4617		; 00001209H
  002c6	2c 6b		 sub	 al, 107			; 0000006bH
  002c8	3c 0c		 cmp	 al, 12
  002ca	77 0d		 ja	 SHORT $LN13@P?
  002cc	0f be c0	 movsx	 eax, al
  002cf	0f a3 c1	 bt	 ecx, eax
  002d2	73 05		 jae	 SHORT $LN13@P?

; 1132 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') iloœæ_pieniêdzy -= kwota_zak³adu; //Odjêcie od iloœci pieniêdzy kwoty zak³adu

  002d4	41 8b 07	 mov	 eax, DWORD PTR [r15]
  002d7	29 03		 sub	 DWORD PTR [rbx], eax
$LN13@P?:
  002d9	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  002dc	bb 09 02 00 00	 mov	 ebx, 521		; 00000209H
  002e1	2c 6b		 sub	 al, 107			; 0000006bH
  002e3	3c 09		 cmp	 al, 9
  002e5	77 2b		 ja	 SHORT $LN15@P?
  002e7	0f be c0	 movsx	 eax, al
  002ea	0f a3 c3	 bt	 ebx, eax
  002ed	73 23		 jae	 SHORT $LN15@P?

; 1133 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') cout << "Kulka w grze, zaczekaj na wylosowanie numeru..." << endl; //Poinformowanie u¿ytkownika o rozpoczêciu losowania

  002ef	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  002f6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0DA@EJNBAHOM@Kulka?5w?5grze?0?5zaczekaj?5na?5wyloso@
  002fd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00302	48 8b c8	 mov	 rcx, rax
  00305	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ; std::endl<char,std::char_traits<char> >
  0030c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@P6AAEAV01@AEAV01@@Z@Z
$LN15@P?:
  00312	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00315	2c 6b		 sub	 al, 107			; 0000006bH
  00317	3c 09		 cmp	 al, 9
  00319	77 2b		 ja	 SHORT $LN269@P?
  0031b	0f be c0	 movsx	 eax, al
  0031e	0f a3 c3	 bt	 ebx, eax
  00321	73 23		 jae	 SHORT $LN269@P?

; 1134 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') wylosowana_liczba = Zakrêæ_Ruletk¹(); //Wylosowanie i przypisanie do zmiennej liczby bêdêcej na  wylosowanej pozycji na kole ruletki

  00323	e8 00 00 00 00	 call	 ?Zakrêæ_Ruletk¹@@YAHXZ	; Zakrêæ_Ruletk¹
  00328	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR wylosowana_liczba$[rsp]
  00330	41 89 06	 mov	 DWORD PTR [r14], eax
  00333	e9 8f 00 00 00	 jmp	 $LN18@P?
$_Invalid_parameter$282:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00338	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0033e	cc		 int	 3
$_Invalid_parameter$283:
  0033f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00345	cc		 int	 3
$LN269@P?:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1136 : 		cout << "Wylosowano numer "; //Poinformowaniu o wylosowaniu liczby

  00346	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  0034d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BC@IEHJKDDM@Wylosowano?5numer?5?$AA@
  00354	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >

; 1137 : 		Change_Col(Ruletka_plansza_kolor_col[wylosowana_liczba]); //Zmiana koloru tekstu w konsoli zgodnie z kolorem numeru na ruletce

  00359	4c 8b b4 24 c8
	00 00 00	 mov	 r14, QWORD PTR wylosowana_liczba$[rsp]
  00361	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?Ruletka_plansza_kolor_col@@3QBHB
  00368	49 63 06	 movsxd	 rax, DWORD PTR [r14]
  0036b	48 8d 1c 81	 lea	 rbx, QWORD PTR [rcx+rax*4]

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  0036f	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  00374	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  0037a	0f b7 13	 movzx	 edx, WORD PTR [rbx]
  0037d	48 8b c8	 mov	 rcx, rax
  00380	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 1138 : 		cout << wylosowana_liczba; //Wypisanie wylosowanej liczby

  00386	41 8b 16	 mov	 edx, DWORD PTR [r14]
  00389	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  00390	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z

; 336  : 	HANDLE h_wyj = GetStdHandle(STD_OUTPUT_HANDLE); //Stworzenie zmiennej typu uchwyt i przypisanie do standardowego wyjœcia

  00396	b9 f5 ff ff ff	 mov	 ecx, -11		; fffffff5H
  0039b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_GetStdHandle

; 337  : 	SetConsoleTextAttribute(h_wyj, num_of_col); //Zmienia atrybut koloru tekstu w konsoli

  003a1	48 8b c8	 mov	 rcx, rax
  003a4	ba 07 00 00 00	 mov	 edx, 7
  003a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_SetConsoleTextAttribute

; 1139 : 		Change_Col(7); //Powrót do standardowego koloru tekstu w konsoli
; 1140 : 		cout << ". "; //Wypisanie kropki koñcz¹cej zdanie

  003af	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?cout@std@@3V?$basic_ostream@DU?$char_traits@D@std@@@1@A
  003b6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02KHOJGJKF@?4?5?$AA@
  003bd	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003c2	bb 09 02 00 00	 mov	 ebx, 521		; 00000209H
$LN18@P?:
  003c7	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  003ca	2c 6b		 sub	 al, 107			; 0000006bH
  003cc	3c 09		 cmp	 al, 9
  003ce	77 30		 ja	 SHORT $LN20@P?
  003d0	0f be c0	 movsx	 eax, al
  003d3	0f a3 c3	 bt	 ebx, eax
  003d6	73 28		 jae	 SHORT $LN20@P?

; 1141 : 	}
; 1142 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu aktualnego informacji o wylosowanej liczbie

  003d8	b8 00 00 00 00	 mov	 eax, 0
  003dd	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  003e1	4d 85 ed	 test	 r13, r13
  003e4	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  003eb	48 0f 44 c8	 cmove	 rcx, rax
  003ef	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  003f4	41 8b 16	 mov	 edx, DWORD PTR [r14]
  003f7	48 8b c8	 mov	 rcx, rax
  003fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
$LN20@P?:
  00400	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00403	2c 6b		 sub	 al, 107			; 0000006bH
  00405	3c 09		 cmp	 al, 9
  00407	77 23		 ja	 SHORT $LN22@P?
  00409	0f be c0	 movsx	 eax, al
  0040c	0f a3 c3	 bt	 ebx, eax
  0040f	73 1b		 jae	 SHORT $LN22@P?

; 1143 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') log_ogólny << " Wylosowano " << wylosowana_liczba; //Zapisanie do bufora pliku logu ogólnego informacji o wylosowanej liczbie

  00411	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0N@CGNKGGIC@?5Wylosowano?5?$AA@
  00418	48 8b cd	 mov	 rcx, rbp
  0041b	e8 00 00 00 00	 call	 ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ; std::operator<<<std::char_traits<char> >
  00420	41 8b 16	 mov	 edx, DWORD PTR [r14]
  00423	48 8b c8	 mov	 rcx, rax
  00426	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??6?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV01@H@Z
$LN22@P?:

; 1144 : 	log.flush(); //Zapisanie do pliku log_aktualny.txt danych wpisanych do bufora danych

  0042c	49 8d 4d 10	 lea	 rcx, QWORD PTR [r13+16]
  00430	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 1145 : 	log_ogólny.flush(); //Zapisanie do pliku log_ogólny.txt danych wpisanych do bufora danych

  00436	48 8b cd	 mov	 rcx, rbp
  00439	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
  0043f	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00442	2c 6b		 sub	 al, 107			; 0000006bH
  00444	3c 09		 cmp	 al, 9
  00446	77 13		 ja	 SHORT $LN24@P?
  00448	0f be c0	 movsx	 eax, al
  0044b	0f a3 c3	 bt	 ebx, eax
  0044e	73 0b		 jae	 SHORT $LN24@P?

; 1146 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't') Odczytaj_liczbê(wylosowana_liczba, typ_zak³adu);

  00450	48 8b d7	 mov	 rdx, rdi
  00453	49 8b ce	 mov	 rcx, r14
  00456	e8 00 00 00 00	 call	 ?Odczytaj_liczbê@@YAXAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ; Odczytaj_liczbê
$LN24@P?:
  0045b	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  0045e	bb 09 12 00 00	 mov	 ebx, 4617		; 00001209H
  00463	2c 6b		 sub	 al, 107			; 0000006bH
  00465	3c 0c		 cmp	 al, 12
  00467	77 22		 ja	 SHORT $LN278@P?
  00469	0f be c0	 movsx	 eax, al
  0046c	0f a3 c3	 bt	 ebx, eax
  0046f	73 1a		 jae	 SHORT $LN278@P?

; 1147 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') wygrana = SprawdŸ_Zak³ad(kwota_zak³adu, typ_zak³adu, wylosowana_liczba); //Przypisanie do wygranej kwoty zgodnej z wygran¹, je¿eli siê coœwygra³o

  00471	4d 8b c6	 mov	 r8, r14
  00474	48 8b d7	 mov	 rdx, rdi
  00477	49 8b cf	 mov	 rcx, r15
  0047a	e8 00 00 00 00	 call	 ?SprawdŸ_Zak³ad@@YAHAEBHAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@0@Z ; SprawdŸ_Zak³ad
  0047f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR wygrana$[rsp]
  00487	89 01		 mov	 DWORD PTR [rcx], eax
  00489	eb 08		 jmp	 SHORT $LN26@P?
$LN278@P?:
  0048b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR wygrana$[rsp]
$LN26@P?:
  00493	0f b6 06	 movzx	 eax, BYTE PTR [rsi]
  00496	2c 6b		 sub	 al, 107			; 0000006bH
  00498	3c 0c		 cmp	 al, 12
  0049a	77 20		 ja	 SHORT $LN28@P?
  0049c	0f be c0	 movsx	 eax, al
  0049f	0f a3 c3	 bt	 ebx, eax
  004a2	73 18		 jae	 SHORT $LN28@P?

; 1148 : 	if (co_kontynuowaæ == 'n' || co_kontynuowaæ == 'k' || co_kontynuowaæ == 't' || co_kontynuowaæ == 'w') Og³oœ_wynik(wygrana, kwota_zak³adu, iloœæ_pieniêdzy, log_ogólny, log); //Funkcja informuj¹ca u¿ytkownika czy wygra³ zak³ad

  004a4	4c 8b 84 24 a0
	00 00 00	 mov	 r8, QWORD PTR iloœæ_pieniêdzy$[rsp]
  004ac	4c 8b cd	 mov	 r9, rbp
  004af	49 8b d7	 mov	 rdx, r15
  004b2	4c 89 6c 24 20	 mov	 QWORD PTR [rsp+32], r13
  004b7	e8 00 00 00 00	 call	 ?Og³oœ_wynik@@YAXAEBH0AEAHAEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@@Z ; Og³oœ_wynik
$LN28@P?:

; 1149 : }

  004bc	48 8b bc 24 98
	00 00 00	 mov	 rdi, QWORD PTR [rsp+152]
  004c4	48 83 c4 50	 add	 rsp, 80			; 00000050H
  004c8	41 5f		 pop	 r15
  004ca	41 5e		 pop	 r14
  004cc	41 5d		 pop	 r13
  004ce	41 5c		 pop	 r12
  004d0	5e		 pop	 rsi
  004d1	5d		 pop	 rbp
  004d2	5b		 pop	 rbx
  004d3	c3		 ret	 0
$LN280@P?:
?Pêtla_g³ówna@@YAXAEAH00AEAV?$basic_ofstream@DU?$char_traits@D@std@@@std@@AEAV?$basic_fstream@DU?$char_traits@D@std@@@2@AEADAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@0@Z ENDP ; Pêtla_g³ówna
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp
;	COMDAT ?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z
_TEXT	SEGMENT
tekst$ = 64
?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z PROC ; Ustaw_ustawienia, COMDAT

; 1151 : {

$LN1673:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00008	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1151 : {

  0000d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00010	48 8b e9	 mov	 rbp, rcx

; 1607 : 		if (_Large_string_engaged())

  00013	72 03		 jb	 SHORT $LN103@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00015	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
$LN103@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  00018	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  0001c	48 8d 79 10	 lea	 rdi, QWORD PTR [rcx+16]
  00020	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  00025	4c 89 74 24 50	 mov	 QWORD PTR [rsp+80], r14

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0002a	48 83 f8 1f	 cmp	 rax, 31
  0002e	72 6d		 jb	 SHORT $LN35@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00030	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00034	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00039	4d 8d 46 e2	 lea	 r8, QWORD PTR [r14-30]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0003d	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00040	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00043	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00049	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0004c	48 85 c0	 test	 rax, rax
  0004f	74 4c		 je	 SHORT $LN35@Ustaw_usta
  00051	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL112@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00060	41 b8 1f 00 00
	00		 mov	 r8d, 31
  00066	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CA@FGPIEHEM@ilo?$JM?f_minimalna_obrot?sw_ruletki?$AA@
  0006d	48 8b ce	 mov	 rcx, rsi
  00070	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00075	85 c0		 test	 eax, eax
  00077	0f 84 12 05 00
	00		 je	 $LN1555@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0007d	48 ff c6	 inc	 rsi
  00080	4d 8d 46 e2	 lea	 r8, QWORD PTR [r14-30]
  00084	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00087	48 8b ce	 mov	 rcx, rsi
  0008a	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  0008f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00095	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00098	48 85 c0	 test	 rax, rax
  0009b	75 c3		 jne	 SHORT $LL112@Ustaw_usta
$LN35@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0009d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000a2	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  000a5	72 03		 jb	 SHORT $LN235@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000a7	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN235@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  000aa	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  000ad	48 83 f8 25	 cmp	 rax, 37			; 00000025H
  000b1	72 6a		 jb	 SHORT $LN40@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  000b3	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000b7	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000bc	4d 8d 46 dc	 lea	 r8, QWORD PTR [r14-36]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000c0	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000c3	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000cc	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  000cf	48 85 c0	 test	 rax, rax
  000d2	74 49		 je	 SHORT $LN40@Ustaw_usta
  000d4	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL244@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  000e0	41 b8 25 00 00
	00		 mov	 r8d, 37			; 00000025H
  000e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0CG@KNEPJEMG@ilo?$JM?f_max_dodatkowych_obrot?sw_ru@
  000ed	48 8b ce	 mov	 rcx, rsi
  000f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  000f5	85 c0		 test	 eax, eax
  000f7	0f 84 42 05 00
	00		 je	 $LN1558@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  000fd	48 ff c6	 inc	 rsi
  00100	4d 8d 46 dc	 lea	 r8, QWORD PTR [r14-36]
  00104	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00107	48 8b ce	 mov	 rcx, rsi
  0010a	ba 69 00 00 00	 mov	 edx, 105		; 00000069H
  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00115	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00118	48 85 c0	 test	 rax, rax
  0011b	75 c3		 jne	 SHORT $LL244@Ustaw_usta
$LN40@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0011d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00122	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  00125	72 03		 jb	 SHORT $LN366@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00127	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN366@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  0012a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0012d	41 be 1b 00 00
	00		 mov	 r14d, 27

; 3273 : 		return (static_cast<size_type>(

  00133	4c 89 7c 24 58	 mov	 QWORD PTR [rsp+88], r15

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00138	49 3b c6	 cmp	 rax, r14
  0013b	72 5d		 jb	 SHORT $LN45@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0013d	4c 8d 3c 28	 lea	 r15, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00141	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00144	4d 8d 47 e6	 lea	 r8, QWORD PTR [r15-26]
  00148	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0014b	41 8d 56 48	 lea	 edx, QWORD PTR [r14+72]
  0014f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00155	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00158	48 85 c0	 test	 rax, rax
  0015b	74 3d		 je	 SHORT $LN45@Ustaw_usta
  0015d	0f 1f 00	 npad	 3
$LL375@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00160	4d 8b c6	 mov	 r8, r14
  00163	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BM@MMKKMDHC@czas_przeskoku_kulki_szybki?$AA@
  0016a	48 8b ce	 mov	 rcx, rsi
  0016d	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00172	85 c0		 test	 eax, eax
  00174	0f 84 75 05 00
	00		 je	 $LN1561@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0017a	48 ff c6	 inc	 rsi
  0017d	4d 8d 47 e6	 lea	 r8, QWORD PTR [r15-26]
  00181	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00184	48 8b ce	 mov	 rcx, rsi
  00187	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0018c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00192	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00195	48 85 c0	 test	 rax, rax
  00198	75 c6		 jne	 SHORT $LL375@Ustaw_usta
$LN45@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0019a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0019f	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  001a2	72 03		 jb	 SHORT $LN497@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  001a4	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN497@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  001a7	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  001aa	48 83 f8 1a	 cmp	 rax, 26
  001ae	72 6d		 jb	 SHORT $LN50@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  001b0	4c 8d 3c 28	 lea	 r15, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  001b4	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001b9	4d 8d 47 e7	 lea	 r8, QWORD PTR [r15-25]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  001bd	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001c0	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  001c3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  001c9	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  001cc	48 85 c0	 test	 rax, rax
  001cf	74 4c		 je	 SHORT $LN50@Ustaw_usta
  001d1	0f 1f 40 00 66
	66 66 0f 1f 84
	00 00 00 00 00	 npad	 15
$LL506@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  001e0	41 b8 1a 00 00
	00		 mov	 r8d, 26
  001e6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BL@LHGCEKLG@czas_przeskoku_kulki_wolny?$AA@
  001ed	48 8b ce	 mov	 rcx, rsi
  001f0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  001f5	85 c0		 test	 eax, eax
  001f7	0f 84 a2 05 00
	00		 je	 $LN1564@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  001fd	48 ff c6	 inc	 rsi
  00200	4d 8d 47 e7	 lea	 r8, QWORD PTR [r15-25]
  00204	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00207	48 8b ce	 mov	 rcx, rsi
  0020a	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  0020f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00215	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00218	48 85 c0	 test	 rax, rax
  0021b	75 c3		 jne	 SHORT $LL506@Ustaw_usta
$LN50@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0021d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00222	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  00225	72 03		 jb	 SHORT $LN628@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00227	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN628@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  0022a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0022d	48 83 f8 16	 cmp	 rax, 22
  00231	72 6a		 jb	 SHORT $LN55@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00233	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00237	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0023c	4d 8d 46 eb	 lea	 r8, QWORD PTR [r14-21]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00240	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00243	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00246	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0024c	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0024f	48 85 c0	 test	 rax, rax
  00252	74 49		 je	 SHORT $LN55@Ustaw_usta
  00254	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL637@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00260	41 b8 16 00 00
	00		 mov	 r8d, 22
  00266	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BH@LAIPMCHF@styl_liczenia_wygranej?$AA@
  0026d	48 8b ce	 mov	 rcx, rsi
  00270	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00275	85 c0		 test	 eax, eax
  00277	0f 84 d2 05 00
	00		 je	 $LN1567@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0027d	48 ff c6	 inc	 rsi
  00280	4d 8d 46 eb	 lea	 r8, QWORD PTR [r14-21]
  00284	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00287	48 8b ce	 mov	 rcx, rsi
  0028a	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  0028f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00295	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00298	48 85 c0	 test	 rax, rax
  0029b	75 c3		 jne	 SHORT $LL637@Ustaw_usta
$LN55@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0029d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  002a2	48 8b f3	 mov	 rsi, rbx

; 1607 : 		if (_Large_string_engaged())

  002a5	72 03		 jb	 SHORT $LN759@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  002a7	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN759@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  002aa	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  002ad	48 83 f8 10	 cmp	 rax, 16
  002b1	72 58		 jb	 SHORT $LN1656@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  002b3	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  002b7	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002bc	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  002c0	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002c3	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  002c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  002cc	48 85 c0	 test	 rax, rax
  002cf	74 3a		 je	 SHORT $LN1656@Ustaw_usta
$LL768@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  002d1	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  002d4	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@
  002db	75 11		 jne	 SHORT $LN1655@Ustaw_usta
  002dd	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  002e1	48 3b 0d 08 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@KJAOIHBF@kwota_pocz?$LJtkowa?$AA@+8
  002e8	0f 84 11 06 00
	00		 je	 $LN1570@Ustaw_usta
$LN1655@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  002ee	48 ff c0	 inc	 rax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  002f1	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
  002f5	4c 2b c0	 sub	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  002f8	48 8b c8	 mov	 rcx, rax
  002fb	ba 6b 00 00 00	 mov	 edx, 107		; 0000006bH
  00300	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00306	48 85 c0	 test	 rax, rax
  00309	75 c6		 jne	 SHORT $LL768@Ustaw_usta
$LN1656@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0030b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00310	48 8b f3	 mov	 rsi, rbx

; 1607 : 		if (_Large_string_engaged())

  00313	72 03		 jb	 SHORT $LN890@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00315	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN890@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  00318	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0031b	48 83 f8 0d	 cmp	 rax, 13
  0031f	72 6a		 jb	 SHORT $LN1657@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00321	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00325	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0032a	4c 8d 45 f4	 lea	 r8, QWORD PTR [rbp-12]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0032e	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00331	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00334	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0033a	4c 8b c8	 mov	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0033d	48 85 c0	 test	 rax, rax
  00340	74 49		 je	 SHORT $LN1657@Ustaw_usta
$LL899@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00342	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  00345	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@
  0034c	75 1d		 jne	 SHORT $LN1654@Ustaw_usta
  0034e	41 8b 49 08	 mov	 ecx, DWORD PTR [r9+8]
  00352	3b 0d 08 00 00
	00		 cmp	 ecx, DWORD PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@+8
  00358	75 11		 jne	 SHORT $LN1654@Ustaw_usta
  0035a	41 0f b6 41 0c	 movzx	 eax, BYTE PTR [r9+12]
  0035f	3a 05 0c 00 00
	00		 cmp	 al, BYTE PTR ??_C@_0O@JDOJANCO@stan_d?$JPwi?jk?sw?$AA@+12
  00365	0f 84 43 06 00
	00		 je	 $LN1573@Ustaw_usta
$LN1654@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0036b	49 ff c1	 inc	 r9

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0036e	4c 8d 45 f4	 lea	 r8, QWORD PTR [rbp-12]
  00372	4d 2b c1	 sub	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00375	49 8b c9	 mov	 rcx, r9
  00378	ba 73 00 00 00	 mov	 edx, 115		; 00000073H
  0037d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00383	4c 8b c8	 mov	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00386	48 85 c0	 test	 rax, rax
  00389	75 b7		 jne	 SHORT $LL899@Ustaw_usta
$LN1657@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0038b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00390	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  00393	72 03		 jb	 SHORT $LN1021@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00395	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1021@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  00398	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0039b	48 83 f8 13	 cmp	 rax, 19
  0039f	72 6c		 jb	 SHORT $LN70@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  003a1	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  003a5	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003aa	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  003ae	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003b1	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  003b4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  003ba	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  003bd	48 85 c0	 test	 rax, rax
  003c0	74 4b		 je	 SHORT $LN70@Ustaw_usta
  003c2	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL1030@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  003d0	41 b8 13 00 00
	00		 mov	 r8d, 19
  003d6	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@MGBNNKM@czy_kontynuowa?f_gr?j?$AA@
  003dd	48 8b ce	 mov	 rcx, rsi
  003e0	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  003e5	85 c0		 test	 eax, eax
  003e7	0f 84 72 06 00
	00		 je	 $LN1576@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  003ed	48 ff c6	 inc	 rsi
  003f0	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
  003f4	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  003f7	48 8b ce	 mov	 rcx, rsi
  003fa	ba 63 00 00 00	 mov	 edx, 99			; 00000063H
  003ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00405	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00408	48 85 c0	 test	 rax, rax
  0040b	75 c3		 jne	 SHORT $LL1030@Ustaw_usta
$LN70@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0040d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00412	48 8b eb	 mov	 rbp, rbx

; 1607 : 		if (_Large_string_engaged())

  00415	72 03		 jb	 SHORT $LN1152@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00417	48 8b 2b	 mov	 rbp, QWORD PTR [rbx]
$LN1152@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  0041a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0041d	48 83 f8 13	 cmp	 rax, 19
  00421	72 6a		 jb	 SHORT $LN75@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00423	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00427	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0042c	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00430	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00433	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00436	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  0043c	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0043f	48 85 c0	 test	 rax, rax
  00442	74 49		 je	 SHORT $LN75@Ustaw_usta
  00444	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL1161@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00450	41 b8 13 00 00
	00		 mov	 r8d, 19
  00456	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BE@ILPCOCN@g?$LDos_odczytu_numeru?$AA@
  0045d	48 8b ce	 mov	 rcx, rsi
  00460	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  00465	85 c0		 test	 eax, eax
  00467	0f 84 a2 06 00
	00		 je	 $LN1579@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0046d	48 ff c6	 inc	 rsi
  00470	4d 8d 46 ee	 lea	 r8, QWORD PTR [r14-18]
  00474	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00477	48 8b ce	 mov	 rcx, rsi
  0047a	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  0047f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00485	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00488	48 85 c0	 test	 rax, rax
  0048b	75 c3		 jne	 SHORT $LL1161@Ustaw_usta
$LN75@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0048d	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00492	4c 8b f3	 mov	 r14, rbx

; 1607 : 		if (_Large_string_engaged())

  00495	72 03		 jb	 SHORT $LN1283@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00497	4c 8b 33	 mov	 r14, QWORD PTR [rbx]
$LN1283@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  0049a	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0049d	48 83 f8 1c	 cmp	 rax, 28
  004a1	72 67		 jb	 SHORT $LN80@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  004a3	4e 8d 3c 30	 lea	 r15, QWORD PTR [rax+r14]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  004a7	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004ac	4d 8d 47 e5	 lea	 r8, QWORD PTR [r15-27]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  004b0	49 8b ce	 mov	 rcx, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004b3	4d 2b c6	 sub	 r8, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  004b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  004bc	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  004bf	48 85 c0	 test	 rax, rax
  004c2	74 46		 je	 SHORT $LN80@Ustaw_usta
  004c4	bd 1c 00 00 00	 mov	 ebp, 28
  004c9	0f 1f 80 00 00
	00 00		 npad	 7
$LL1292@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  004d0	4c 8b c5	 mov	 r8, rbp
  004d3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BN@ECEAENDF@g?$LDos_szybko?$JM?f_odczytu_numeru?$AA@
  004da	48 8b ce	 mov	 rcx, rsi
  004dd	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  004e2	85 c0		 test	 eax, eax
  004e4	0f 84 d5 06 00
	00		 je	 $LN1582@Ustaw_usta

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  004ea	48 ff c6	 inc	 rsi
  004ed	4d 8d 47 e5	 lea	 r8, QWORD PTR [r15-27]
  004f1	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  004f4	48 8b ce	 mov	 rcx, rsi
  004f7	ba 67 00 00 00	 mov	 edx, 103		; 00000067H
  004fc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00502	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00505	48 85 c0	 test	 rax, rax
  00508	75 c6		 jne	 SHORT $LL1292@Ustaw_usta
$LN80@Ustaw_usta:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0050a	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0050f	48 8b f3	 mov	 rsi, rbx

; 1607 : 		if (_Large_string_engaged())

  00512	72 03		 jb	 SHORT $LN1414@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00514	48 8b 33	 mov	 rsi, QWORD PTR [rbx]
$LN1414@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  00517	48 8b 07	 mov	 rax, QWORD PTR [rdi]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  0051a	48 83 f8 10	 cmp	 rax, 16
  0051e	0f 82 e7 07 00
	00		 jb	 $LN1659@Ustaw_usta

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)
; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);
; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00524	48 8d 2c 30	 lea	 rbp, QWORD PTR [rax+rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00528	ba 65 00 00 00	 mov	 edx, 101		; 00000065H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  0052d	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00531	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00534	4c 2b c6	 sub	 r8, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00537	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0053d	48 85 c0	 test	 rax, rax
  00540	0f 84 c5 07 00
	00		 je	 $LN1659@Ustaw_usta
  00546	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL1423@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00550	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00553	48 3b 0d 00 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@
  0055a	75 11		 jne	 SHORT $LN1653@Ustaw_usta
  0055c	48 8b 48 08	 mov	 rcx, QWORD PTR [rax+8]
  00560	48 3b 0d 08 00
	00 00		 cmp	 rcx, QWORD PTR ??_C@_0BB@EHOIFKBK@efekty_d?$JPwi?jkowe?$AA@+8
  00567	0f 84 02 07 00
	00		 je	 $LN1585@Ustaw_usta
$LN1653@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 75   : 	for (auto _Match_try = _Haystack + _Start_at; ; ++_Match_try)

  0056d	48 ff c0	 inc	 rax

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00570	4c 8d 45 f1	 lea	 r8, QWORD PTR [rbp-15]
  00574	4c 2b c0	 sub	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00577	48 8b c8	 mov	 rcx, rax
  0057a	ba 65 00 00 00	 mov	 edx, 101		; 00000065H
  0057f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00585	48 85 c0	 test	 rax, rax
  00588	75 c6		 jne	 SHORT $LL1423@Ustaw_usta
  0058a	e9 7c 07 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1555@Ustaw_usta:

; 85   : 			return (_Match_try - _Haystack);

  0058f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1152 : 	if (tekst.find("iloœæ_minimalna_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00592	48 83 fe ff	 cmp	 rsi, -1
  00596	0f 84 01 fb ff
	ff		 je	 $LN35@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0059c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0059f	b8 20 00 00 00	 mov	 eax, 32			; 00000020H
  005a4	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  005a7	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  005aa	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005ae	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  005b3	72 03		 jb	 SHORT $LN148@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005b5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN148@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  005b8	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  005bb	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  005bf	4c 89 07	 mov	 QWORD PTR [rdi], r8
  005c2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  005c5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005cb	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  005d0	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  005d3	72 03		 jb	 SHORT $LN168@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005d5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN168@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1155 : 		if (atoi(tekst.c_str())) iloœæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  005d8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005de	85 c0		 test	 eax, eax
  005e0	74 1f		 je	 SHORT $LN37@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  005e2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  005e7	72 03		 jb	 SHORT $LN184@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  005e9	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN184@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1155 : 		if (atoi(tekst.c_str())) iloœæ_minimalna_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  005ec	48 8b cb	 mov	 rcx, rbx
  005ef	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  005f5	66 89 05 00 00
	00 00		 mov	 WORD PTR ?iloœæ_minimalna_obrotów_ruletki@@3FA, ax ; iloœæ_minimalna_obrotów_ruletki

; 1156 : 		else //W przeciwym wypadku

  005fc	e9 0f 07 00 00	 jmp	 $LN1658@Ustaw_usta
$LN37@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00601	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00605	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00608	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  0060c	72 06		 jb	 SHORT $LN216@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0060e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00611	48 8b d9	 mov	 rbx, rcx
$LN216@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00614	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00617	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1158 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0061a	48 3b ca	 cmp	 rcx, rdx
  0061d	74 12		 je	 SHORT $LN3@Ustaw_usta
  0061f	90		 npad	 1
$LL4@Ustaw_usta:

; 1159 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00620	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00623	0f 85 e7 06 00
	00		 jne	 $LN1658@Ustaw_usta

; 1158 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00629	48 ff c1	 inc	 rcx
  0062c	48 3b ca	 cmp	 rcx, rdx
  0062f	75 ef		 jne	 SHORT $LL4@Ustaw_usta
$LN3@Ustaw_usta:

; 1160 : 			g³os_szybkoœæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00631	33 c0		 xor	 eax, eax
  00633	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru

; 1163 : 	else if (tekst.find("iloœæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0063a	e9 d1 06 00 00	 jmp	 $LN1658@Ustaw_usta
$LN1558@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0063f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1163 : 	else if (tekst.find("iloœæ_max_dodatkowych_obrotów_ruletki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00642	48 83 fe ff	 cmp	 rsi, -1
  00646	0f 84 d1 fa ff
	ff		 je	 $LN40@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0064c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0064f	b8 26 00 00 00	 mov	 eax, 38			; 00000026H
  00654	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00657	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0065a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0065e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00663	72 03		 jb	 SHORT $LN280@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00665	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN280@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00668	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0066b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0066f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00672	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00675	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0067b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00680	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00683	72 03		 jb	 SHORT $LN299@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00685	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN299@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1166 : 		if (atoi(tekst.c_str())) iloœæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00688	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0068e	85 c0		 test	 eax, eax
  00690	74 1f		 je	 SHORT $LN42@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00692	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00697	72 03		 jb	 SHORT $LN315@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00699	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN315@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1166 : 		if (atoi(tekst.c_str())) iloœæ_max_dodatkowych_obrotów_ruletki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  0069c	48 8b cb	 mov	 rcx, rbx
  0069f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  006a5	66 89 05 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, ax ; iloœæ_max_dodatkowych_obrotów_ruletki

; 1167 : 		else //W przeciwym wypadku

  006ac	e9 5f 06 00 00	 jmp	 $LN1658@Ustaw_usta
$LN42@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006b1	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  006b5	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  006b8	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  006bc	72 06		 jb	 SHORT $LN347@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  006be	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  006c1	48 8b d9	 mov	 rbx, rcx
$LN347@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  006c4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  006c7	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1169 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  006ca	48 3b ca	 cmp	 rcx, rdx
  006cd	74 12		 je	 SHORT $LN6@Ustaw_usta
  006cf	90		 npad	 1
$LL7@Ustaw_usta:

; 1170 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  006d0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  006d3	0f 85 37 06 00
	00		 jne	 $LN1658@Ustaw_usta

; 1169 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  006d9	48 ff c1	 inc	 rcx
  006dc	48 3b ca	 cmp	 rcx, rdx
  006df	75 ef		 jne	 SHORT $LL7@Ustaw_usta
$LN6@Ustaw_usta:

; 1171 : 			iloœæ_max_dodatkowych_obrotów_ruletki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  006e1	33 c0		 xor	 eax, eax
  006e3	66 89 05 00 00
	00 00		 mov	 WORD PTR ?iloœæ_max_dodatkowych_obrotów_ruletki@@3FA, ax ; iloœæ_max_dodatkowych_obrotów_ruletki

; 1174 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  006ea	e9 21 06 00 00	 jmp	 $LN1658@Ustaw_usta
$LN1561@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  006ef	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1174 : 	else if (tekst.find("czas_przeskoku_kulki_szybki") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  006f2	48 83 fe ff	 cmp	 rsi, -1
  006f6	0f 84 9e fa ff
	ff		 je	 $LN45@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  006fc	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  006ff	bd 1c 00 00 00	 mov	 ebp, 28
  00704	4c 3b c5	 cmp	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00707	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0070a	49 0f 42 e8	 cmovb	 rbp, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0070e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00713	72 03		 jb	 SHORT $LN411@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00715	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN411@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00718	4c 2b c5	 sub	 r8, rbp

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0071b	48 8d 14 29	 lea	 rdx, QWORD PTR [rcx+rbp]
  0071f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00722	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00725	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0072b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00730	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00733	72 03		 jb	 SHORT $LN430@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00735	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN430@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1177 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00738	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0073e	85 c0		 test	 eax, eax
  00740	74 1f		 je	 SHORT $LN47@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00742	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00747	72 03		 jb	 SHORT $LN446@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00749	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN446@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1177 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_szybki = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  0074c	48 8b cb	 mov	 rcx, rbx
  0074f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00755	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki

; 1178 : 		else //W przeciwym wypadku

  0075c	e9 aa 05 00 00	 jmp	 $LN1659@Ustaw_usta
$LN47@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00761	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00765	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00768	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  0076c	72 06		 jb	 SHORT $LN478@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0076e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00771	48 8b d9	 mov	 rbx, rcx
$LN478@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00774	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00777	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1180 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  0077a	48 3b ca	 cmp	 rcx, rdx
  0077d	74 12		 je	 SHORT $LN9@Ustaw_usta
  0077f	90		 npad	 1
$LL10@Ustaw_usta:

; 1181 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00780	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00783	0f 85 82 05 00
	00		 jne	 $LN1659@Ustaw_usta

; 1180 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00789	48 ff c1	 inc	 rcx
  0078c	48 3b ca	 cmp	 rcx, rdx
  0078f	75 ef		 jne	 SHORT $LL10@Ustaw_usta
$LN9@Ustaw_usta:

; 1182 : 			czas_przeskoku_kulki_szybki = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00791	33 c0		 xor	 eax, eax
  00793	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_szybki@@3FA, ax ; czas_przeskoku_kulki_szybki

; 1185 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0079a	e9 6c 05 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1564@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0079f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1185 : 	else if (tekst.find("czas_przeskoku_kulki_wolny") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  007a2	48 83 fe ff	 cmp	 rsi, -1
  007a6	0f 84 71 fa ff
	ff		 je	 $LN50@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  007ac	4c 8b 07	 mov	 r8, QWORD PTR [rdi]

; 1595 : 		value_type * _Result = _Bx._Buf;

  007af	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  007b2	4d 3b c6	 cmp	 r8, r14
  007b5	4d 0f 42 f0	 cmovb	 r14, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007b9	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  007be	72 03		 jb	 SHORT $LN542@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007c0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN542@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  007c3	4d 2b c6	 sub	 r8, r14

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  007c6	4a 8d 14 31	 lea	 rdx, QWORD PTR [rcx+r14]
  007ca	4c 89 07	 mov	 QWORD PTR [rdi], r8
  007cd	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  007d0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007d6	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  007db	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  007de	72 03		 jb	 SHORT $LN561@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007e0	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN561@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1188 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  007e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  007e9	85 c0		 test	 eax, eax
  007eb	74 1f		 je	 SHORT $LN52@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  007ed	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  007f2	72 03		 jb	 SHORT $LN577@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  007f4	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN577@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1188 : 		if (atoi(tekst.c_str())) czas_przeskoku_kulki_wolny = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  007f7	48 8b cb	 mov	 rcx, rbx
  007fa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00800	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny

; 1189 : 		else //W przeciwym wypadku

  00807	e9 ff 04 00 00	 jmp	 $LN1659@Ustaw_usta
$LN52@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0080c	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00810	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00813	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00817	72 06		 jb	 SHORT $LN609@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00819	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  0081c	48 8b d9	 mov	 rbx, rcx
$LN609@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0081f	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00822	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1191 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00825	48 3b ca	 cmp	 rcx, rdx
  00828	74 17		 je	 SHORT $LN12@Ustaw_usta
  0082a	66 0f 1f 44 00
	00		 npad	 6
$LL13@Ustaw_usta:

; 1192 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00830	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00833	0f 85 d2 04 00
	00		 jne	 $LN1659@Ustaw_usta

; 1191 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00839	48 ff c1	 inc	 rcx
  0083c	48 3b ca	 cmp	 rcx, rdx
  0083f	75 ef		 jne	 SHORT $LL13@Ustaw_usta
$LN12@Ustaw_usta:

; 1193 : 			czas_przeskoku_kulki_wolny = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00841	33 c0		 xor	 eax, eax
  00843	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czas_przeskoku_kulki_wolny@@3FA, ax ; czas_przeskoku_kulki_wolny

; 1196 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  0084a	e9 bc 04 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1567@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  0084f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1196 : 	else if (tekst.find("styl_liczenia_wygranej") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00852	48 83 fe ff	 cmp	 rsi, -1
  00856	0f 84 41 fa ff
	ff		 je	 $LN55@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0085c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0085f	b8 17 00 00 00	 mov	 eax, 23
  00864	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00867	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0086a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0086e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00873	72 03		 jb	 SHORT $LN673@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00875	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN673@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00878	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0087b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0087f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00882	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00885	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0088b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00890	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00893	72 03		 jb	 SHORT $LN692@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00895	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN692@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 		if (atoi(tekst.c_str())) styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00898	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0089e	85 c0		 test	 eax, eax
  008a0	74 1f		 je	 SHORT $LN57@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008a2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  008a7	72 03		 jb	 SHORT $LN708@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008a9	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN708@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1199 : 		if (atoi(tekst.c_str())) styl_liczenia_wygranej = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  008ac	48 8b cb	 mov	 rcx, rbx
  008af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  008b5	66 89 05 00 00
	00 00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, ax ; styl_liczenia_wygranej

; 1200 : 		else //W przeciwym wypadku

  008bc	e9 4a 04 00 00	 jmp	 $LN1659@Ustaw_usta
$LN57@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008c1	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  008c5	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  008c8	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  008cc	72 06		 jb	 SHORT $LN740@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  008ce	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  008d1	48 8b d9	 mov	 rbx, rcx
$LN740@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  008d4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  008d7	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1202 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  008da	48 3b ca	 cmp	 rcx, rdx
  008dd	74 12		 je	 SHORT $LN15@Ustaw_usta
  008df	90		 npad	 1
$LL16@Ustaw_usta:

; 1203 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  008e0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  008e3	0f 85 22 04 00
	00		 jne	 $LN1659@Ustaw_usta

; 1202 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  008e9	48 ff c1	 inc	 rcx
  008ec	48 3b ca	 cmp	 rcx, rdx
  008ef	75 ef		 jne	 SHORT $LL16@Ustaw_usta
$LN15@Ustaw_usta:

; 1204 : 			styl_liczenia_wygranej = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  008f1	33 c0		 xor	 eax, eax
  008f3	66 89 05 00 00
	00 00		 mov	 WORD PTR ?styl_liczenia_wygranej@@3FA, ax ; styl_liczenia_wygranej

; 1207 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  008fa	e9 0c 04 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1570@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  008ff	48 2b c6	 sub	 rax, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1207 : 	else if (tekst.find("kwota_pocz¹tkowa") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00902	48 83 f8 ff	 cmp	 rax, -1
  00906	0f 84 ff f9 ff
	ff		 je	 $LN1656@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0090c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0090f	b8 11 00 00 00	 mov	 eax, 17
  00914	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00917	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0091a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0091e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00923	72 03		 jb	 SHORT $LN804@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00925	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN804@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00928	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0092b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  0092f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00932	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00935	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0093b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00940	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00943	72 03		 jb	 SHORT $LN823@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00945	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN823@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 		if (atoi(tekst.c_str())) kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00948	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  0094e	85 c0		 test	 eax, eax
  00950	74 1e		 je	 SHORT $LN62@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00952	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00957	72 03		 jb	 SHORT $LN839@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00959	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN839@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1210 : 		if (atoi(tekst.c_str())) kwota_pocz¹tkowa = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  0095c	48 8b cb	 mov	 rcx, rbx
  0095f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00965	89 05 00 00 00
	00		 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, eax ; kwota_pocz¹tkowa

; 1211 : 		else //W przeciwym wypadku

  0096b	e9 9b 03 00 00	 jmp	 $LN1659@Ustaw_usta
$LN62@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00970	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00974	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00977	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  0097b	72 06		 jb	 SHORT $LN871@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0097d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00980	48 8b d9	 mov	 rbx, rcx
$LN871@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00983	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00986	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1213 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00989	48 3b ca	 cmp	 rcx, rdx
  0098c	74 13		 je	 SHORT $LN18@Ustaw_usta
  0098e	66 90		 npad	 2
$LL19@Ustaw_usta:

; 1214 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00990	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00993	0f 85 72 03 00
	00		 jne	 $LN1659@Ustaw_usta

; 1213 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00999	48 ff c1	 inc	 rcx
  0099c	48 3b ca	 cmp	 rcx, rdx
  0099f	75 ef		 jne	 SHORT $LL19@Ustaw_usta
$LN18@Ustaw_usta:

; 1215 : 			kwota_pocz¹tkowa = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  009a1	33 c0		 xor	 eax, eax
  009a3	89 05 00 00 00
	00		 mov	 DWORD PTR ?kwota_pocz¹tkowa@@3HA, eax ; kwota_pocz¹tkowa

; 1218 : 	else if (tekst.find("stan_dŸwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  009a9	e9 5d 03 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1573@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  009ae	4c 2b ce	 sub	 r9, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1218 : 	else if (tekst.find("stan_dŸwiêków") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  009b1	49 83 f9 ff	 cmp	 r9, -1
  009b5	0f 84 d0 f9 ff
	ff		 je	 $LN1657@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  009bb	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  009be	b8 0e 00 00 00	 mov	 eax, 14
  009c3	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  009c6	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  009c9	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009cd	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  009d2	72 03		 jb	 SHORT $LN935@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  009d4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN935@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  009d7	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  009da	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  009de	4c 89 07	 mov	 QWORD PTR [rdi], r8
  009e1	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  009e4	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  009ea	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  009ef	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  009f2	72 03		 jb	 SHORT $LN954@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  009f4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN954@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 		if (atoi(tekst.c_str())) stan_dŸwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  009f7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  009fd	85 c0		 test	 eax, eax
  009ff	74 1f		 je	 SHORT $LN67@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a01	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00a06	72 03		 jb	 SHORT $LN970@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00a08	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN970@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1221 : 		if (atoi(tekst.c_str())) stan_dŸwiêków = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00a0b	48 8b cb	 mov	 rcx, rbx
  00a0e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00a14	66 89 05 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, ax ; stan_dŸwiêków

; 1222 : 		else //W przeciwym wypadku

  00a1b	e9 eb 02 00 00	 jmp	 $LN1659@Ustaw_usta
$LN67@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a20	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a24	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a27	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00a2b	72 06		 jb	 SHORT $LN1002@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00a2d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00a30	48 8b d9	 mov	 rbx, rcx
$LN1002@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00a33	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00a36	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1224 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00a39	48 3b ca	 cmp	 rcx, rdx
  00a3c	74 13		 je	 SHORT $LN21@Ustaw_usta
  00a3e	66 90		 npad	 2
$LL22@Ustaw_usta:

; 1225 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00a40	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00a43	0f 85 c2 02 00
	00		 jne	 $LN1659@Ustaw_usta

; 1224 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00a49	48 ff c1	 inc	 rcx
  00a4c	48 3b ca	 cmp	 rcx, rdx
  00a4f	75 ef		 jne	 SHORT $LL22@Ustaw_usta
$LN21@Ustaw_usta:

; 1226 : 			stan_dŸwiêków = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00a51	33 c0		 xor	 eax, eax
  00a53	66 89 05 00 00
	00 00		 mov	 WORD PTR ?stan_dŸwiêków@@3FA, ax ; stan_dŸwiêków

; 1229 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00a5a	e9 ac 02 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1576@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00a5f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1229 : 	else if (tekst.find("czy_kontynuowaæ_grê") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00a62	48 83 fe ff	 cmp	 rsi, -1
  00a66	0f 84 a1 f9 ff
	ff		 je	 $LN70@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00a6c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00a6f	b8 14 00 00 00	 mov	 eax, 20
  00a74	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00a77	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00a7a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a7e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00a83	72 03		 jb	 SHORT $LN1066@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00a85	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1066@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00a88	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00a8b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00a8f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00a92	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00a95	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00a9b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00aa0	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00aa3	72 03		 jb	 SHORT $LN1085@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00aa5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1085@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 		if (atoi(tekst.c_str())) czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00aa8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00aae	85 c0		 test	 eax, eax
  00ab0	74 1f		 je	 SHORT $LN72@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ab2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00ab7	72 03		 jb	 SHORT $LN1101@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00ab9	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1101@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1232 : 		if (atoi(tekst.c_str())) czy_kontynuowaæ_grê = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00abc	48 8b cb	 mov	 rcx, rbx
  00abf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00ac5	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, ax ; czy_kontynuowaæ_grê

; 1233 : 		else //W przeciwym wypadku

  00acc	e9 3a 02 00 00	 jmp	 $LN1659@Ustaw_usta
$LN72@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ad1	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00ad5	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00ad8	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00adc	72 06		 jb	 SHORT $LN1133@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00ade	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00ae1	48 8b d9	 mov	 rbx, rcx
$LN1133@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00ae4	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00ae7	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1235 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00aea	48 3b ca	 cmp	 rcx, rdx
  00aed	74 12		 je	 SHORT $LN24@Ustaw_usta
  00aef	90		 npad	 1
$LL25@Ustaw_usta:

; 1236 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00af0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00af3	0f 85 12 02 00
	00		 jne	 $LN1659@Ustaw_usta

; 1235 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00af9	48 ff c1	 inc	 rcx
  00afc	48 3b ca	 cmp	 rcx, rdx
  00aff	75 ef		 jne	 SHORT $LL25@Ustaw_usta
$LN24@Ustaw_usta:

; 1237 : 			czy_kontynuowaæ_grê = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00b01	33 c0		 xor	 eax, eax
  00b03	66 89 05 00 00
	00 00		 mov	 WORD PTR ?czy_kontynuowaæ_grê@@3FA, ax ; czy_kontynuowaæ_grê

; 1240 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00b0a	e9 fc 01 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1579@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00b0f	48 2b f5	 sub	 rsi, rbp
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1240 : 	else if (tekst.find("g³os_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00b12	48 83 fe ff	 cmp	 rsi, -1
  00b16	0f 84 71 f9 ff
	ff		 je	 $LN75@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00b1c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00b1f	b8 14 00 00 00	 mov	 eax, 20
  00b24	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00b27	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00b2a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b2e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00b33	72 03		 jb	 SHORT $LN1197@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b35	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1197@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00b38	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00b3b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00b3f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00b42	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00b45	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b4b	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00b50	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00b53	72 03		 jb	 SHORT $LN1216@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b55	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1216@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 		if (atoi(tekst.c_str())) g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00b58	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b5e	85 c0		 test	 eax, eax
  00b60	74 1f		 je	 SHORT $LN77@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b62	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00b67	72 03		 jb	 SHORT $LN1232@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b69	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1232@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1243 : 		if (atoi(tekst.c_str())) g³os_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00b6c	48 8b cb	 mov	 rcx, rbx
  00b6f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00b75	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, ax ; g³os_odczytu_numeru

; 1244 : 		else //W przeciwym wypadku

  00b7c	e9 8a 01 00 00	 jmp	 $LN1659@Ustaw_usta
$LN77@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b81	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00b85	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00b88	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00b8c	72 06		 jb	 SHORT $LN1264@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00b8e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00b91	48 8b d9	 mov	 rbx, rcx
$LN1264@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00b94	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00b97	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1246 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00b9a	48 3b ca	 cmp	 rcx, rdx
  00b9d	74 12		 je	 SHORT $LN27@Ustaw_usta
  00b9f	90		 npad	 1
$LL28@Ustaw_usta:

; 1247 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00ba0	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00ba3	0f 85 62 01 00
	00		 jne	 $LN1659@Ustaw_usta

; 1246 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00ba9	48 ff c1	 inc	 rcx
  00bac	48 3b ca	 cmp	 rcx, rdx
  00baf	75 ef		 jne	 SHORT $LL28@Ustaw_usta
$LN27@Ustaw_usta:

; 1248 : 			g³os_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00bb1	33 c0		 xor	 eax, eax
  00bb3	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_odczytu_numeru@@3FA, ax ; g³os_odczytu_numeru

; 1251 : 	else if (tekst.find("g³os_szybkoœæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00bba	e9 4c 01 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1582@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00bbf	49 2b f6	 sub	 rsi, r14
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1251 : 	else if (tekst.find("g³os_szybkoœæ_odczytu_numeru") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00bc2	48 83 fe ff	 cmp	 rsi, -1
  00bc6	0f 84 3e f9 ff
	ff		 je	 $LN80@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00bcc	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00bcf	b8 1d 00 00 00	 mov	 eax, 29
  00bd4	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00bd7	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00bda	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bde	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00be3	72 03		 jb	 SHORT $LN1328@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00be5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1328@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00be8	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00beb	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00bef	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00bf2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00bf5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00bfb	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00c00	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00c03	72 03		 jb	 SHORT $LN1347@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c05	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1347@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 		if (atoi(tekst.c_str())) g³os_szybkoœæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00c08	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00c0e	85 c0		 test	 eax, eax
  00c10	74 1f		 je	 SHORT $LN82@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c12	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00c17	72 03		 jb	 SHORT $LN1363@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c19	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1363@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1254 : 		if (atoi(tekst.c_str())) g³os_szybkoœæ_odczytu_numeru = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00c1c	48 8b cb	 mov	 rcx, rbx
  00c1f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00c25	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru

; 1255 : 		else //W przeciwym wypadku

  00c2c	e9 da 00 00 00	 jmp	 $LN1659@Ustaw_usta
$LN82@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c31	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00c35	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c38	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00c3c	72 06		 jb	 SHORT $LN1395@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c3e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00c41	48 8b d9	 mov	 rbx, rcx
$LN1395@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00c44	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00c47	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1257 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00c4a	48 3b ca	 cmp	 rcx, rdx
  00c4d	74 12		 je	 SHORT $LN30@Ustaw_usta
  00c4f	90		 npad	 1
$LL31@Ustaw_usta:

; 1258 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00c50	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00c53	0f 85 b2 00 00
	00		 jne	 $LN1659@Ustaw_usta

; 1257 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00c59	48 ff c1	 inc	 rcx
  00c5c	48 3b ca	 cmp	 rcx, rdx
  00c5f	75 ef		 jne	 SHORT $LL31@Ustaw_usta
$LN30@Ustaw_usta:

; 1259 : 			g³os_szybkoœæ_odczytu_numeru = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00c61	33 c0		 xor	 eax, eax
  00c63	66 89 05 00 00
	00 00		 mov	 WORD PTR ?g³os_szybkoœæ_odczytu_numeru@@3FA, ax ; g³os_szybkoœæ_odczytu_numeru

; 1262 : 	else if (tekst.find("efekty_dŸwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00c6a	e9 9c 00 00 00	 jmp	 $LN1659@Ustaw_usta
$LN1585@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 85   : 			return (_Match_try - _Haystack);

  00c6f	48 2b c6	 sub	 rax, rsi
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1262 : 	else if (tekst.find("efekty_dŸwiêkowe") != string::npos) //Sprawdzenie czy znaleziony jest poszukiwany tekst

  00c72	48 83 f8 ff	 cmp	 rax, -1
  00c76	0f 84 8f 00 00
	00		 je	 $LN1659@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  00c7c	4c 8b 07	 mov	 r8, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00c7f	b8 11 00 00 00	 mov	 eax, 17
  00c84	4c 3b c0	 cmp	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00c87	48 8b cb	 mov	 rcx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00c8a	49 0f 42 c0	 cmovb	 rax, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00c8e	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00c93	72 03		 jb	 SHORT $LN1459@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00c95	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1459@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  00c98	4c 2b c0	 sub	 r8, rax

; 2622 : 		_My_data._Mysize = _New_size;
; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  00c9b	48 8d 14 01	 lea	 rdx, QWORD PTR [rcx+rax]
  00c9f	4c 89 07	 mov	 QWORD PTR [rdi], r8
  00ca2	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00ca5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cab	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00cb0	48 8b cb	 mov	 rcx, rbx

; 1607 : 		if (_Large_string_engaged())

  00cb3	72 03		 jb	 SHORT $LN1478@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00cb5	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
$LN1478@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 		if (atoi(tekst.c_str())) efekty_dŸwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00cb8	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi
  00cbe	85 c0		 test	 eax, eax
  00cc0	74 15		 je	 SHORT $LN86@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cc2	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00cc7	72 03		 jb	 SHORT $LN1494@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00cc9	48 8b 1b	 mov	 rbx, QWORD PTR [rbx]
$LN1494@Ustaw_usta:
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1265 : 		if (atoi(tekst.c_str())) efekty_dŸwiêkowe = atoi(tekst.c_str()); //Sprawdzenie czy po usuniêciu tekstu, to co pozosta³o jest wartoœci¹ ró¿n¹ od zera

  00ccc	48 8b cb	 mov	 rcx, rbx
  00ccf	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_atoi

; 1266 : 		else //W przeciwym wypadku

  00cd5	eb 2d		 jmp	 SHORT $LN1670@Ustaw_usta
$LN86@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cd7	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00cdb	48 8b cb	 mov	 rcx, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00cde	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00ce2	72 06		 jb	 SHORT $LN1526@Ustaw_usta
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00ce4	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00ce7	48 8b d9	 mov	 rbx, rcx
$LN1526@Ustaw_usta:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  00cea	48 8b 17	 mov	 rdx, QWORD PTR [rdi]
  00ced	48 03 d3	 add	 rdx, rbx
; File f:\users\krzysztof\documents\szko³a\2017-2018\informatyka\labolatorium\ruletka\ruletka\main.cpp

; 1268 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00cf0	48 3b ca	 cmp	 rcx, rdx
  00cf3	74 0d		 je	 SHORT $LN33@Ustaw_usta
$LL34@Ustaw_usta:

; 1269 : 				if (i != '0') return; //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji //Je¿eli zmienna i jest ró¿na od znaku 0 to wychodzi z funkcji

  00cf5	80 39 30	 cmp	 BYTE PTR [rcx], 48	; 00000030H
  00cf8	75 11		 jne	 SHORT $LN1659@Ustaw_usta

; 1268 : 			for (const char & i : tekst) //Pêtla id¹ca po ka¿dym elemencie tablicy tekst i przypisuj¹ca wartoœæ na tym polu do zmiennej i

  00cfa	48 ff c1	 inc	 rcx
  00cfd	48 3b ca	 cmp	 rcx, rdx
  00d00	75 f3		 jne	 SHORT $LL34@Ustaw_usta
$LN33@Ustaw_usta:

; 1270 : 			efekty_dŸwiêkowe = 0; //Je¿eli wszystkie pozycje wyrazu tekst s¹ zerami to zaczy, ¿e jego wartoœæ liczbowa to 0

  00d02	33 c0		 xor	 eax, eax
$LN1670@Ustaw_usta:
  00d04	66 89 05 00 00
	00 00		 mov	 WORD PTR ?efekty_dŸwiêkowe@@3FA, ax ; efekty_dŸwiêkowe
$LN1659@Ustaw_usta:
  00d0b	4c 8b 7c 24 58	 mov	 r15, QWORD PTR [rsp+88]
$LN1658@Ustaw_usta:

; 1271 : 		}
; 1272 : 	}
; 1273 : }

  00d10	4c 8b 74 24 50	 mov	 r14, QWORD PTR [rsp+80]
  00d15	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00d1a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00d1e	5f		 pop	 rdi
  00d1f	5d		 pop	 rbp
  00d20	5b		 pop	 rbx
  00d21	c3		 ret	 0
?Ustaw_ustawienia@@YAXAEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@Z ENDP ; Ustaw_ustawienia
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$uniform_int_distribution@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_int_distribution@H@std@@QEAA@HH@Z PROC	; std::uniform_int_distribution<int>::uniform_int_distribution<int>, COMDAT

; 2256 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2445 : 		}

  00002	48 8b c1	 mov	 rax, rcx

; 2257 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2445 : 		}

  00009	c3		 ret	 0
??0?$uniform_int_distribution@H@std@@QEAA@HH@Z ENDP	; std::uniform_int_distribution<int>::uniform_int_distribution<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ
_TEXT	SEGMENT
this$ = 16
??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator(), COMDAT

; 1374 : 		{	// return next value

$LN32:
  00000	48 83 ec 08	 sub	 rsp, 8

; 1375 : 		if (this->_Idx == _Nx)

  00004	8b 01		 mov	 eax, DWORD PTR [rcx]
  00006	41 bb 38 01 00
	00		 mov	 r11d, 312		; 00000138H
  0000c	4c 8b c9	 mov	 r9, rcx
  0000f	41 3b c3	 cmp	 eax, r11d
  00012	75 5b		 jne	 SHORT $LN2@operator

; 1429 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00014	4c 8d 41 10	 lea	 r8, QWORD PTR [rcx+16]
  00018	49 ba e9 19 66
	a9 5a 6f 02 b5	 mov	 r10, -5403634167711393303 ; b5026f5aa96619e9H
  00022	0f 1f 40 00 66
	66 0f 1f 84 00
	00 00 00 00	 npad	 14
$LL9@operator:
  00030	41 8b 50 f8	 mov	 edx, DWORD PTR [r8-8]
  00034	41 33 10	 xor	 edx, DWORD PTR [r8]
  00037	4d 8d 40 08	 lea	 r8, QWORD PTR [r8+8]
  0003b	0f ba f2 1f	 btr	 edx, 31
  0003f	49 33 50 f0	 xor	 rdx, QWORD PTR [r8-16]

; 1430 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00043	0f b6 c2	 movzx	 eax, dl
  00046	24 01		 and	 al, 1
  00048	f6 d8		 neg	 al
  0004a	48 1b c9	 sbb	 rcx, rcx
  0004d	48 d1 ea	 shr	 rdx, 1
  00050	49 23 ca	 and	 rcx, r10
  00053	49 33 88 d0 04
	00 00		 xor	 rcx, QWORD PTR [r8+1232]
  0005a	48 33 ca	 xor	 rcx, rdx
  0005d	49 89 88 b0 09
	00 00		 mov	 QWORD PTR [r8+2480], rcx
  00064	49 83 eb 01	 sub	 r11, 1
  00068	75 c6		 jne	 SHORT $LL9@operator

; 1431 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1432 : 			}
; 1433 : 		}

  0006a	e9 f9 00 00 00	 jmp	 $LN4@operator
$LN2@operator:

; 1376 : 			_Refill_upper();
; 1377 : 		else if (2 * _Nx <= this->_Idx)

  0006f	3d 70 02 00 00	 cmp	 eax, 624		; 00000270H
  00074	0f 82 ee 00 00
	00		 jb	 $LN4@operator

; 1401 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  0007a	48 89 1c 24	 mov	 QWORD PTR [rsp], rbx
  0007e	4c 8d 99 c8 09
	00 00		 lea	 r11, QWORD PTR [rcx+2504]
  00085	bb 9c 00 00 00	 mov	 ebx, 156		; 0000009cH
  0008a	49 ba e9 19 66
	a9 5a 6f 02 b5	 mov	 r10, -5403634167711393303 ; b5026f5aa96619e9H
  00094	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL14@operator:

; 1402 : 			{	// fill in lower region
; 1403 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1404 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000a0	41 8b 13	 mov	 edx, DWORD PTR [r11]
  000a3	41 33 53 08	 xor	 edx, DWORD PTR [r11+8]
  000a7	4d 8d 5b 08	 lea	 r11, QWORD PTR [r11+8]
  000ab	0f ba f2 1f	 btr	 edx, 31
  000af	49 33 53 f8	 xor	 rdx, QWORD PTR [r11-8]

; 1405 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  000b3	0f b6 c2	 movzx	 eax, dl
  000b6	24 01		 and	 al, 1
  000b8	f6 d8		 neg	 al
  000ba	48 1b c9	 sbb	 rcx, rcx
  000bd	48 d1 ea	 shr	 rdx, 1
  000c0	49 23 ca	 and	 rcx, r10
  000c3	49 33 8b d8 04
	00 00		 xor	 rcx, QWORD PTR [r11+1240]
  000ca	48 33 ca	 xor	 rcx, rdx
  000cd	49 89 8b 38 f6
	ff ff		 mov	 QWORD PTR [r11-2504], rcx
  000d4	48 83 eb 01	 sub	 rbx, 1
  000d8	75 c6		 jne	 SHORT $LL14@operator

; 1406 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1407 : 			}
; 1408 : 
; 1409 : 		for (; _Ix < _Nx - 1; ++_Ix)

  000da	4d 8d 99 a8 0e
	00 00		 lea	 r11, QWORD PTR [r9+3752]
  000e1	bb 9b 00 00 00	 mov	 ebx, 155		; 0000009bH
  000e6	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL17@operator:

; 1410 : 			{	// fill in upper region (avoids modulus operation)
; 1411 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1412 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  000f0	41 8b 13	 mov	 edx, DWORD PTR [r11]
  000f3	41 33 53 08	 xor	 edx, DWORD PTR [r11+8]
  000f7	4d 8d 5b 08	 lea	 r11, QWORD PTR [r11+8]
  000fb	0f ba f2 1f	 btr	 edx, 31
  000ff	49 33 53 f8	 xor	 rdx, QWORD PTR [r11-8]

; 1413 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00103	0f b6 c2	 movzx	 eax, dl
  00106	24 01		 and	 al, 1
  00108	f6 d8		 neg	 al
  0010a	48 1b c9	 sbb	 rcx, rcx
  0010d	48 d1 ea	 shr	 rdx, 1
  00110	49 23 ca	 and	 rcx, r10
  00113	49 33 8b 58 f1
	ff ff		 xor	 rcx, QWORD PTR [r11-3752]
  0011a	48 33 ca	 xor	 rcx, rdx
  0011d	49 89 8b 38 f6
	ff ff		 mov	 QWORD PTR [r11-2504], rcx
  00124	48 83 eb 01	 sub	 rbx, 1
  00128	75 c6		 jne	 SHORT $LL17@operator

; 1414 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1415 : 			}
; 1416 : 
; 1417 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  0012a	41 8b 91 80 13
	00 00		 mov	 edx, DWORD PTR [r9+4992]
  00131	41 33 51 08	 xor	 edx, DWORD PTR [r9+8]
  00135	0f ba f2 1f	 btr	 edx, 31
  00139	49 33 91 80 13
	00 00		 xor	 rdx, QWORD PTR [r9+4992]

; 1418 : 		this->_Ax[_Ix] = (_Tmp >> 1)

  00140	0f b6 c2	 movzx	 eax, dl
  00143	24 01		 and	 al, 1
  00145	f6 d8		 neg	 al
  00147	48 1b c9	 sbb	 rcx, rcx
  0014a	48 d1 ea	 shr	 rdx, 1
  0014d	49 23 ca	 and	 rcx, r10
  00150	49 33 89 e0 04
	00 00		 xor	 rcx, QWORD PTR [r9+1248]
  00157	48 33 ca	 xor	 rcx, rdx
  0015a	49 89 89 c0 09
	00 00		 mov	 QWORD PTR [r9+2496], rcx

; 1419 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1420 : 		this->_Idx = 0;

  00161	41 89 19	 mov	 DWORD PTR [r9], ebx
  00164	48 8b 1c 24	 mov	 rbx, QWORD PTR [rsp]
$LN4@operator:

; 1378 : 			_Refill_lower();
; 1379 : 
; 1380 : 		_Ty _Res = this->_Ax[this->_Idx++] & _WMSK;

  00168	41 8b 01	 mov	 eax, DWORD PTR [r9]
  0016b	49 8b 54 c1 08	 mov	 rdx, QWORD PTR [r9+rax*8+8]
  00170	ff c0		 inc	 eax
  00172	41 89 01	 mov	 DWORD PTR [r9], eax

; 1381 : 		_Res ^= (_Res >> _Ux) & _Dxval;

  00175	48 8b ca	 mov	 rcx, rdx
  00178	49 8b 81 88 13
	00 00		 mov	 rax, QWORD PTR [r9+5000]
  0017f	48 c1 e9 1d	 shr	 rcx, 29
  00183	48 23 c1	 and	 rax, rcx

; 1382 : 		_Res ^= (_Res << _Sx) & _Bx;

  00186	48 b9 d3 f6 ff
	3f eb 38 00 00	 mov	 rcx, 62583042209491	; 000038eb3ffff6d3H
  00190	48 33 d0	 xor	 rdx, rax
  00193	48 8b c2	 mov	 rax, rdx
  00196	48 23 c1	 and	 rax, rcx
  00199	48 c1 e0 11	 shl	 rax, 17
  0019d	48 33 d0	 xor	 rdx, rax

; 1383 : 		_Res ^= (_Res << _Tx) & _Cx;

  001a0	48 8b c2	 mov	 rax, rdx
  001a3	48 25 77 bf ff
	ff		 and	 rax, -16521		; ffffffffffffbf77H
  001a9	48 c1 e0 25	 shl	 rax, 37			; 00000025H
  001ad	48 33 d0	 xor	 rdx, rax

; 1384 : 		_Res ^= (_Res & _WMSK) >> _Lx;

  001b0	48 8b c2	 mov	 rax, rdx
  001b3	48 c1 e8 2b	 shr	 rax, 43			; 0000002bH
  001b7	48 33 c2	 xor	 rax, rdx

; 1385 : 		return (_Res);
; 1386 : 		}

  001ba	48 83 c4 08	 add	 rsp, 8
  001be	c3		 ret	 0
??R?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA_KXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z PROC ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>, COMDAT

; 1321 : 		: _Dxval(_Dxarg)

  00000	48 b8 55 55 55
	55 55 55 55 55	 mov	 rax, 6148914691236517205 ; 5555555555555555H
  0000a	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  0000e	48 89 81 88 13
	00 00		 mov	 QWORD PTR [rcx+5000], rax
  00015	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0001b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 1321 : 		: _Dxval(_Dxarg)

  0001f	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00025	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0002f	90		 npad	 1
$LL8@mersenne_t:

; 1339 : 			_Prev = this->_Ax[_Ix] =

  00030	48 8b c2	 mov	 rax, rdx
  00033	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00037	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0003b	48 33 d0	 xor	 rdx, rax
  0003e	49 0f af d3	 imul	 rdx, r11
  00042	49 03 d0	 add	 rdx, r8
  00045	49 ff c0	 inc	 r8
  00048	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0004c	49 83 ea 01	 sub	 r10, 1
  00050	75 de		 jne	 SHORT $LL8@mersenne_t

; 1340 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1341 : 		this->_Idx = _Nx;

  00052	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1546 : 		}

  00058	48 8b c1	 mov	 rax, rcx
  0005b	c3		 ret	 0
??0?$mersenne_twister_engine@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0FFFFFFFFFFFFFFFF@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@$0FIFBPECNEMJFHPCN@@std@@QEAA@_K@Z ENDP ; std::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>::mersenne_twister_engine<unsigned __int64,64,312,156,31,-5403634167711393303,29,6148914691236517205,17,8202884508482404352,37,-2270628950310912,43,6364136223846793005>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z
_TEXT	SEGMENT
this$dead$ = 48
__$ReturnUdt$ = 56
_Off$dead$ = 64
_Count$dead$ = 72
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr, COMDAT

; 3482 : 		{	// return [_Off, _Off + _Count) as new string

$LN85:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3698 : 		_My_data._Mysize = 0;

  00006	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3482 : 		{	// return [_Off, _Off + _Count) as new string

  0000e	48 8b da	 mov	 rbx, rdx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00019	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0001c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00023	48 83 f8 05	 cmp	 rax, 5
  00027	0f 82 8c 00 00
	00		 jb	 $LN83@substr

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0002d	48 83 c0 fb	 add	 rax, -5
  00031	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00036	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00041	48 3b c7	 cmp	 rax, rdi
  00044	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00048	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2435 : 		if (_Count <= _My_data._Myres)

  00050	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]

; 1607 : 		if (_Large_string_engaged())

  00054	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0005c	49 83 c1 05	 add	 r9, 5

; 2435 : 		if (_Count <= _My_data._Myres)

  00060	48 3b f8	 cmp	 rdi, rax
  00063	77 3b		 ja	 SHORT $LN59@substr

; 1595 : 		value_type * _Result = _Bx._Buf;

  00065	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0006a	48 8b f2	 mov	 rsi, rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0006d	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00071	72 03		 jb	 SHORT $LN68@substr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00073	48 8b 32	 mov	 rsi, QWORD PTR [rdx]
$LN68@substr:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00076	48 89 7a 10	 mov	 QWORD PTR [rdx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0007a	4c 8b c7	 mov	 r8, rdi
  0007d	49 8b d1	 mov	 rdx, r9
  00080	48 8b ce	 mov	 rcx, rsi
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00089	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3483 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  0008d	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00090	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3483 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 3484 : 		}

  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN59@substr:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	48 8b cb	 mov	 rcx, rbx
  000a6	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 3483 : 		return (basic_string(*this, _Off, _Count, get_allocator()));

  000ab	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000b0	48 8b c3	 mov	 rax, rbx

; 3484 : 		}

  000b3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b7	5b		 pop	 rbx
  000b8	c3		 ret	 0
$LN83@substr:

; 1624 : 			_Xran();

  000b9	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000be	cc		 int	 3
$LN82@substr:
?substr@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV12@_K0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::substr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Off$dead$ = 64
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find, COMDAT

; 3271 : 		{	// look for [_Ptr, <null>) beginning at or after _Off

$LN46:
  00000	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000f	48 8b f2	 mov	 rsi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00012	48 83 cf ff	 or	 rdi, -1
$LL42@find:
  00016	48 ff c7	 inc	 rdi
  00019	80 3c 3a 00	 cmp	 BYTE PTR [rdx+rdi], 0
  0001d	75 f7		 jne	 SHORT $LL42@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0001f	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00024	48 8b e9	 mov	 rbp, rcx

; 1607 : 		if (_Large_string_engaged())

  00027	72 03		 jb	 SHORT $LN13@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00029	48 8b 29	 mov	 rbp, QWORD PTR [rcx]
$LN13@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3273 : 		return (static_cast<size_type>(

  0002c	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00030	48 3b f8	 cmp	 rdi, rax
  00033	0f 87 9d 00 00
	00		 ja	 $LN24@find

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00039	48 85 ff	 test	 rdi, rdi
  0003c	75 12		 jne	 SHORT $LN25@find

; 3273 : 		return (static_cast<size_type>(

  0003e	33 c0		 xor	 eax, eax

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  00040	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  00045	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5f		 pop	 rdi
  0004f	c3		 ret	 0
$LN25@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00050	0f be 12	 movsx	 edx, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  00053	48 2b c7	 sub	 rax, rdi
  00056	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0005b	48 8b cd	 mov	 rcx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0005e	4c 89 74 24 38	 mov	 QWORD PTR [rsp+56], r14
  00063	4c 8d 34 28	 lea	 r14, QWORD PTR [rax+rbp]

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00067	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  0006b	4c 2b c5	 sub	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0006e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00074	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00077	48 85 c0	 test	 rax, rax
  0007a	74 34		 je	 SHORT $LN37@find
  0007c	0f 1f 40 00	 npad	 4
$LL22@find:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00080	4c 8b c7	 mov	 r8, rdi
  00083	48 8b d6	 mov	 rdx, rsi
  00086	48 8b cb	 mov	 rcx, rbx
  00089	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0008e	85 c0		 test	 eax, eax
  00090	74 3c		 je	 SHORT $LN38@find
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00092	0f be 16	 movsx	 edx, BYTE PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00095	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
  00099	48 ff c3	 inc	 rbx
  0009c	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  000a8	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  000ab	48 85 c0	 test	 rax, rax
  000ae	75 d0		 jne	 SHORT $LL22@find
$LN37@find:

; 3273 : 		return (static_cast<size_type>(

  000b0	48 83 c8 ff	 or	 rax, -1
$LN44@find:
  000b4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000b9	4c 8b 74 24 38	 mov	 r14, QWORD PTR [rsp+56]

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  000be	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000c3	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000c8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000cc	5f		 pop	 rdi
  000cd	c3		 ret	 0
$LN38@find:

; 85   : 			return (_Match_try - _Haystack);

  000ce	48 2b dd	 sub	 rbx, rbp

; 3273 : 		return (static_cast<size_type>(

  000d1	48 8b c3	 mov	 rax, rbx

; 85   : 			return (_Match_try - _Haystack);

  000d4	eb de		 jmp	 SHORT $LN44@find
$LN24@find:

; 3274 : 			_Traits_find<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Off, _Ptr, _Traits::length(_Ptr))));
; 3275 : 		}

  000d6	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  000db	48 83 c8 ff	 or	 rax, -1
  000df	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000e4	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000e8	5f		 pop	 rdi
  000e9	c3		 ret	 0
?find@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KQEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::find
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size, COMDAT

; 3062 : 		return (this->_Get_data()._Mysize);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]

; 3063 : 		}

  00004	c3		 ret	 0
?size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@c_str

; 3040 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 3041 : 		}

  0000a	c3		 ret	 0
$LN16@c_str:

; 3040 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 3041 : 		}

  0000e	c3		 ret	 0
?c_str@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::c_str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00005	72 07		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2977 : 		return (_My_data._Myptr()[_Off]);

  0000a	48 03 c2	 add	 rax, rdx

; 2978 : 		}

  0000d	c3		 ret	 0
$LN16@operator:

; 2977 : 		return (_My_data._Myptr()[_Off]);

  0000e	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]

; 2978 : 		}

  00012	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAAEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[], COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00005	72 07		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2970 : 		return (_My_data._Myptr()[_Off]);

  0000a	48 03 c2	 add	 rax, rdx

; 2971 : 		}

  0000d	c3		 ret	 0
$LN16@operator:

; 2970 : 		return (_My_data._Myptr()[_Off]);

  0000e	48 8d 04 11	 lea	 rax, QWORD PTR [rcx+rdx]

; 2971 : 		}

  00012	c3		 ret	 0
??A?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator[]
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1595 : 		value_type * _Result = _Bx._Buf;

  00005	48 8b d1	 mov	 rdx, rcx

; 1596 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN10@Unchecked_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
$LN10@Unchecked_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2876 : 		return (_My_data._Myptr() + _My_data._Mysize);

  0000d	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00011	48 03 c2	 add	 rax, rdx

; 2877 : 		}

  00014	c3		 ret	 0
?_Unchecked_end@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_end
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@Unchecked_

; 2865 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 2866 : 		}

  0000a	c3		 ret	 0
$LN16@Unchecked_:

; 2865 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 2866 : 		}

  0000e	c3		 ret	 0
?_Unchecked_begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAPEADXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Unchecked_begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
_Count$ = 64
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 2614 : 		{	// erase elements [_Off, _Off + _Count)

$LN32:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	4d 8b c8	 mov	 r9, r8
  00009	48 8b d9	 mov	 rbx, rcx

; 1622 : 		if (_Mysize < _Off)

  0000c	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
  00010	4c 3b c2	 cmp	 r8, rdx
  00013	72 3e		 jb	 SHORT $LN30@erase

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00015	49 8b c0	 mov	 rax, r8
  00018	48 2b c2	 sub	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0001b	49 3b c1	 cmp	 rax, r9
  0001e	4c 0f 42 c8	 cmovb	 r9, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00022	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1595 : 		value_type * _Result = _Bx._Buf;

  00027	48 8b c1	 mov	 rax, rcx

; 1596 : 		if (_Large_string_engaged())

  0002a	72 03		 jb	 SHORT $LN20@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0002c	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$LN20@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  0002f	4d 2b c1	 sub	 r8, r9
  00032	48 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+rax]

; 2622 : 		_My_data._Mysize = _New_size;

  00036	4c 89 43 10	 mov	 QWORD PTR [rbx+16], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  0003a	4c 2b c2	 sub	 r8, rdx
  0003d	49 ff c0	 inc	 r8
  00040	49 8d 14 09	 lea	 rdx, QWORD PTR [r9+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2624 : 		return (*this);

  0004a	48 8b c3	 mov	 rax, rbx

; 2625 : 		}

  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5b		 pop	 rbx
  00052	c3		 ret	 0
$LN30@erase:

; 1624 : 			_Xran();

  00053	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00058	cc		 int	 3
$LN29@erase:
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00000	49 83 c8 ff	 or	 r8, -1
$LL8@append:
  00004	49 ff c0	 inc	 r8
  00007	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0000c	75 f6		 jne	 SHORT $LL8@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0000e	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00005	48 8b c2	 mov	 rax, rdx

; 1607 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN10@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN10@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b d0	 mov	 rdx, rax
  00014	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z
_TEXT	SEGMENT
this$ = 48
_Ch$ = 56
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 2313 : 		{	// append 1 * _Ch

$LN27:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00006	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2313 : 		{	// append 1 * _Ch

  0000a	48 8b d9	 mov	 rbx, rcx

; 2992 : 		if (_Old_size < _My_data._Myres)

  0000d	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00011	4d 3b c1	 cmp	 r8, r9
  00014	73 27		 jae	 SHORT $LN4@operator

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  00016	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]

; 1595 : 		value_type * _Result = _Bx._Buf;

  0001a	48 8b c3	 mov	 rax, rbx

; 2994 : 			_My_data._Mysize = _Old_size + 1;

  0001d	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00021	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00025	72 03		 jb	 SHORT $LN13@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00027	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0002a	42 88 14 00	 mov	 BYTE PTR [rax+r8], dl
  0002e	42 c6 44 00 01
	00		 mov	 BYTE PTR [rax+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2315 : 		return (*this);

  00034	48 8b c3	 mov	 rax, rbx

; 2316 : 		}

  00037	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003b	5b		 pop	 rbx
  0003c	c3		 ret	 0
$LN4@operator:

; 3001 : 		_Reallocate_grow_by(1,

  0003d	44 0f b6 ca	 movzx	 r9d, dl
  00041	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>

; 2315 : 		return (*this);

  00046	48 8b c3	 mov	 rax, rbx

; 2316 : 		}

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$ = 16
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00000	49 83 c8 ff	 or	 r8, -1
$LL10@operator:
  00004	49 ff c0	 inc	 r8
  00007	42 80 3c 02 00	 cmp	 BYTE PTR [rdx+r8], 0
  0000c	75 f6		 jne	 SHORT $LL10@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0000e	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$dead$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2281 : 		{	// assign [_Ptr, <null>)

$LN33:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2435 : 		if (_Count <= _My_data._Myres)

  00004	48 8b 0d 18 00
	00 00		 mov	 rcx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24
  0000b	48 83 f9 05	 cmp	 rcx, 5
  0000f	72 4e		 jb	 SHORT $LN11@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00011	48 83 f9 10	 cmp	 rcx, 16

; 1596 : 		if (_Large_string_engaged())

  00015	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  0001a	48 8d 1d 00 00
	00 00		 lea	 rbx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2438 : 			_My_data._Mysize = _Count;

  00021	48 c7 05 10 00
	00 00 05 00 00
	00		 mov	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16, 5

; 1596 : 		if (_Large_string_engaged())

  0002c	48 0f 43 1d 00
	00 00 00	 cmovae	 rbx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00034	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  0003b	48 8b cb	 mov	 rcx, rbx
  0003e	41 b8 05 00 00
	00		 mov	 r8d, 5
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0004a	c6 43 05 00	 mov	 BYTE PTR [rbx+5], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2282 : 		return (assign(_Ptr));

  0004e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00055	48 8b 5c 24 20	 mov	 rbx, QWORD PTR [rsp+32]

; 2283 : 		}

  0005a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005e	c3		 ret	 0
$LN11@operator:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005f	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  00066	ba 05 00 00 00	 mov	 edx, 5
  0006b	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 2283 : 		}

  00072	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00076	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2252 : 		{	// assign _Right

$LN52:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 2253 : 		if (this != _STD addressof(_Right))

  00009	48 3b ca	 cmp	 rcx, rdx
  0000c	74 70		 je	 SHORT $LN49@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000e	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00013	4c 8b ca	 mov	 r9, rdx
  00016	48 89 7c 24 38	 mov	 QWORD PTR [rsp+56], rdi

; 1607 : 		if (_Large_string_engaged())

  0001b	72 03		 jb	 SHORT $LN21@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0001d	4c 8b 0a	 mov	 r9, QWORD PTR [rdx]
$LN21@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2267 : 			assign(_Right_data._Myptr(), _Right_data._Mysize);

  00020	48 8b 7a 10	 mov	 rdi, QWORD PTR [rdx+16]

; 2435 : 		if (_Count <= _My_data._Myres)

  00024	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00028	48 3b f8	 cmp	 rdi, rax
  0002b	77 3b		 ja	 SHORT $LN28@operator

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00032	48 8b f3	 mov	 rsi, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00035	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00039	72 03		 jb	 SHORT $LN37@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0003b	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN37@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  0003e	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00042	4c 8b c7	 mov	 r8, rdi
  00045	48 8b ce	 mov	 rcx, rsi
  00048	49 8b d1	 mov	 rdx, r9
  0004b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00051	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2270 : 		return (*this);

  00055	48 8b c3	 mov	 rax, rbx
  00058	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  0005d	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2271 : 		}

  00062	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00066	5b		 pop	 rbx
  00067	c3		 ret	 0
$LN28@operator:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00068	48 8b d7	 mov	 rdx, rdi
  0006b	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
  00070	48 8b 7c 24 38	 mov	 rdi, QWORD PTR [rsp+56]

; 2270 : 		return (*this);

  00075	48 8b c3	 mov	 rax, rbx

; 2271 : 		}

  00078	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007c	5b		 pop	 rbx
  0007d	c3		 ret	 0
$LN49@operator:

; 2270 : 		return (*this);

  0007e	48 8b c3	 mov	 rax, rbx

; 2271 : 		}

  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5b		 pop	 rbx
  00086	c3		 ret	 0
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 2245 : 		{	// destroy the string

$LN49:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00006	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 2245 : 		{	// destroy the string

  0000a	48 8b d9	 mov	 rbx, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000d	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  00011	72 31		 jb	 SHORT $LN27@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00016	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00019	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0001f	72 1e		 jb	 SHORT $LN30@basic_stri

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00021	f6 c1 1f	 test	 cl, 31
  00024	75 37		 jne	 SHORT $_Invalid_parameter$50

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00026	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	73 2e		 jae	 SHORT $_Invalid_parameter$50
  0002f	48 2b c8	 sub	 rcx, rax
  00032	48 83 e9 08	 sub	 rcx, 8
  00036	48 83 f9 1f	 cmp	 rcx, 31
  0003a	77 21		 ja	 SHORT $_Invalid_parameter$50

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0003c	48 8b c8	 mov	 rcx, rax
$LN30@basic_stri:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0003f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN27@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00044	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004c	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00054	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2247 : 		}

  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$_Invalid_parameter$50:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00063	cc		 int	 3
$LN48@basic_stri:
??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 48
_Right$ = 56
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=, COMDAT

; 2085 : 		{	// assign by moving _Right

$LN98:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b fa	 mov	 rdi, rdx
  0000d	48 8b d9	 mov	 rbx, rcx

; 2086 : 		if (this != _STD addressof(_Right))

  00010	48 3b ca	 cmp	 rcx, rdx
  00013	74 67		 je	 SHORT $LN93@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00015	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00019	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0001d	72 31		 jb	 SHORT $LN31@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  0001f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00022	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00025	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0002b	72 1e		 jb	 SHORT $LN34@operator

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0002d	f6 c1 1f	 test	 cl, 31
  00030	75 58		 jne	 SHORT $_Invalid_parameter$99

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00032	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00036	48 3b c1	 cmp	 rax, rcx
  00039	73 4f		 jae	 SHORT $_Invalid_parameter$99
  0003b	48 2b c8	 sub	 rcx, rax
  0003e	48 83 e9 08	 sub	 rcx, 8
  00042	48 83 f9 1f	 cmp	 rcx, 31
  00046	77 42		 ja	 SHORT $_Invalid_parameter$99

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00048	48 8b c8	 mov	 rcx, rax
$LN34@operator:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0004b	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN31@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00050	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
  00058	33 c0		 xor	 eax, eax
  0005a	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0005e	88 03		 mov	 BYTE PTR [rbx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00060	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  00063	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00066	0f 10 4f 10	 movups	 xmm1, XMMWORD PTR [rdi+16]
  0006a	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  0006e	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00072	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0007a	88 07		 mov	 BYTE PTR [rdi], al
$LN93@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2097 : 		return (*this);

  0007c	48 8b c3	 mov	 rax, rbx

; 2098 : 		}

  0007f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00084	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00088	5f		 pop	 rdi
  00089	c3		 ret	 0
$_Invalid_parameter$99:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00090	cc		 int	 3
$LN97@operator:
??4?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0000a	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  0000d	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00010	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  00014	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00018	48 89 42 10	 mov	 QWORD PTR [rdx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0001c	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00024	88 02		 mov	 BYTE PTR [rdx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2056 : 		}

  00026	48 8b c1	 mov	 rax, rcx
  00029	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@$$QEAV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z
_TEXT	SEGMENT
this$ = 48
_Count$dead$ = 56
_Ch$dead$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1991 : 		{	// construct from _Count * _Ch

$LN24:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3698 : 		_My_data._Mysize = 0;

  00006	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1991 : 		{	// construct from _Count * _Ch

  0000e	48 8b d9	 mov	 rbx, rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  0001c	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign

; 1994 : 		}

  00021	48 8b c3	 mov	 rax, rbx
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5b		 pop	 rbx
  00029	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1977 : 		{	// construct from [_Ptr, <null>)

$LN55:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3698 : 		_My_data._Mysize = 0;

  0000a	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1977 : 		{	// construct from [_Ptr, <null>)

  00012	48 8b f9	 mov	 rdi, rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00015	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0001d	48 83 cb ff	 or	 rbx, -1

; 517  : 		_Left = _Right;

  00021	c6 01 00	 mov	 BYTE PTR [rcx], 0
$LL52@basic_stri:

; 480  : 		return (_CSTD strlen(_First));

  00024	48 ff c3	 inc	 rbx
  00027	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  0002b	75 f7		 jne	 SHORT $LL52@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2435 : 		if (_Count <= _My_data._Myres)

  0002d	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00031	48 3b d8	 cmp	 rbx, rax
  00034	77 38		 ja	 SHORT $LN31@basic_stri

; 1595 : 		value_type * _Result = _Bx._Buf;

  00036	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0003b	48 8b f7	 mov	 rsi, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0003e	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00042	72 03		 jb	 SHORT $LN40@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00044	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN40@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00047	48 89 59 10	 mov	 QWORD PTR [rcx+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0004b	4c 8b c3	 mov	 r8, rbx
  0004e	48 8b ce	 mov	 rcx, rsi
  00051	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00057	c6 04 1e 00	 mov	 BYTE PTR [rsi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1980 : 		}

  0005b	48 8b c7	 mov	 rax, rdi
  0005e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00063	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00068	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006c	5f		 pop	 rdi
  0006d	c3		 ret	 0
$LN31@basic_stri:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0006e	4c 8b ca	 mov	 r9, rdx
  00071	48 8b d3	 mov	 rdx, rbx
  00074	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1980 : 		}

  00079	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0007e	48 8b c7	 mov	 rax, rdi
  00081	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00085	5f		 pop	 rdi
  00086	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1962 : 		{	// construct from [_Ptr, _Ptr + _Count)

$LN47:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3698 : 		_My_data._Mysize = 0;

  0000a	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1962 : 		{	// construct from [_Ptr, _Ptr + _Count)

  00012	49 8b f8	 mov	 rdi, r8

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00015	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 1962 : 		{	// construct from [_Ptr, _Ptr + _Count)

  0001d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00020	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2435 : 		if (_Count <= _My_data._Myres)

  00023	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  00027	4c 3b c0	 cmp	 r8, rax
  0002a	77 35		 ja	 SHORT $LN24@basic_stri

; 1595 : 		value_type * _Result = _Bx._Buf;

  0002c	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00031	48 8b f1	 mov	 rsi, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00034	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00038	72 03		 jb	 SHORT $LN33@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0003a	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN33@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  0003d	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00041	48 8b ce	 mov	 rcx, rsi
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0004a	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1965 : 		}

  0004e	48 8b c3	 mov	 rax, rbx
  00051	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00056	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0005b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005f	5f		 pop	 rdi
  00060	c3		 ret	 0
$LN24@basic_stri:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00061	4c 8b ca	 mov	 r9, rdx
  00064	48 8b d7	 mov	 rdx, rdi
  00067	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1965 : 		}

  0006c	48 8b c3	 mov	 rax, rbx
  0006f	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00074	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00078	5f		 pop	 rdi
  00079	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3698 : 		_My_data._Mysize = 0;

  00000	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1938 : 		}

  00008	48 8b c1	 mov	 rax, rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0000b	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00013	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1938 : 		}

  00016	c3		 ret	 0
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1924 : 		{	// construct by copying _Right

$LN109:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00008	48 8b d9	 mov	 rbx, rcx
  0000b	48 8b fa	 mov	 rdi, rdx

; 1576 : 		_Mysize(0),

  0000e	33 c9		 xor	 ecx, ecx
  00010	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1577 : 		_Myres(0)

  00014	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00018	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  0001d	48 8b 72 10	 mov	 rsi, QWORD PTR [rdx+16]

; 1607 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN39@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	48 8b 3a	 mov	 rdi, QWORD PTR [rdx]
$LN39@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  00026	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  0002b	48 83 fe 10	 cmp	 rsi, 16
  0002f	73 10		 jae	 SHORT $LN24@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00031	0f 10 07	 movups	 xmm0, XMMWORD PTR [rdi]
  00034	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2192 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  00037	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15

; 2193 : 			return;

  0003f	eb 75		 jmp	 SHORT $LN107@basic_stri
$LN24@basic_stri:

; 2194 : 			}
; 2195 : 
; 2196 : 		auto& _Al = this->_Getal();
; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  00041	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004b	48 8b ee	 mov	 rbp, rsi
  0004e	48 83 cd 0f	 or	 rbp, 15
  00052	48 3b e8	 cmp	 rbp, rax
  00055	48 0f 47 e8	 cmova	 rbp, rax

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  00059	48 8d 45 01	 lea	 rax, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0005d	48 85 c0	 test	 rax, rax
  00060	74 41		 je	 SHORT $LN80@basic_stri

; 53   : 		{
; 54   : 		return (_Ptr);
; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00062	84 c9		 test	 cl, cl
  00064	74 07		 je	 SHORT $LN82@basic_stri

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00066	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0006c	cc		 int	 3
$LN82@basic_stri:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0006d	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00073	72 23		 jb	 SHORT $LN83@basic_stri

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00075	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]

; 72   : 		if (_Block_size <= _User_size)

  00079	48 3b c8	 cmp	 rcx, rax
  0007c	77 07		 ja	 SHORT $LN84@basic_stri

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00084	cc		 int	 3
$LN84@basic_stri:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00085	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0008a	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  0008e	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00092	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00096	eb 0b		 jmp	 SHORT $LN80@basic_stri
$LN83@basic_stri:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  00098	48 8b c8	 mov	 rcx, rax
  0009b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000a0	48 8b c8	 mov	 rcx, rax
$LN80@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000a3	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000a7	48 89 0b	 mov	 QWORD PTR [rbx], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000aa	48 8b d7	 mov	 rdx, rdi
  000ad	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  000b2	48 89 6b 18	 mov	 QWORD PTR [rbx+24], rbp
$LN107@basic_stri:

; 1925 : 		_Construct_lv_contents(_Right);
; 1926 : 		}

  000b6	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000bb	48 8b c3	 mov	 rax, rbx

; 2201 : 		_My_data._Mysize = _Right_size;

  000be	48 89 73 10	 mov	 QWORD PTR [rbx+16], rsi

; 1925 : 		_Construct_lv_contents(_Right);
; 1926 : 		}

  000c2	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c6	5f		 pop	 rdi
  000c7	5e		 pop	 rsi
  000c8	5b		 pop	 rbx
  000c9	c3		 ret	 0
$LN108@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ PROC ; std::basic_fstream<char,std::char_traits<char> >::close, COMDAT

; 1380 : 		{	// close the C stream

$LN5:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1381 : 		if (_Filebuffer.close() == 0)

  00009	48 83 c1 18	 add	 rcx, 24
  0000d	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00012	48 85 c0	 test	 rax, rax
  00015	75 1d		 jne	 SHORT $LN2@close

; 1382 : 			_Myios::setstate(ios_base::failbit);

  00017	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001a	45 33 c0	 xor	 r8d, r8d
  0001d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00021	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]
  00025	48 03 cb	 add	 rcx, rbx

; 1383 : 	}

  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5b		 pop	 rbx

; 1382 : 			_Myios::setstate(ios_base::failbit);

  0002d	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@close:

; 1383 : 	}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
?close@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$dead$ = 56
_Mode$ = 64
_Prot$dead$ = 72
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::open, COMDAT

; 1358 : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1359 : 		if (_Filebuffer.open(_Filename, _Mode, _Prot) == 0)

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BB@KLDNCCFE@log_aktualny?4txt?$AA@
  00010	48 83 c1 18	 add	 rcx, 24
  00014	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1360 : 			_Myios::setstate(ios_base::failbit);

  00019	45 33 c0	 xor	 r8d, r8d
  0001c	48 85 c0	 test	 rax, rax
  0001f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00022	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00026	75 13		 jne	 SHORT $LN2@open
  00028	48 03 cb	 add	 rcx, rbx
  0002b	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]

; 1363 : 		}

  0002f	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00033	5b		 pop	 rbx

; 1360 : 			_Myios::setstate(ios_base::failbit);

  00034	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 1361 : 		else
; 1362 : 			_Myios::clear();	// added with C++11

  0003b	48 03 cb	 add	 rcx, rbx
  0003e	33 d2		 xor	 edx, edx

; 1363 : 		}

  00040	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00044	5b		 pop	 rbx

; 1361 : 		else
; 1362 : 			_Myios::clear();	// added with C++11

  00045	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >, COMDAT

; 1342 : 		{	// destroy the object

$LN15:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 48
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-184], rax
  00031	48 8b 81 48 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-184]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 48 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-184]
  00043	44 89 84 0a 44
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-188], r8d

; 1343 : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_fstr
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_fstr

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_fstr:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_fstr

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_fstr:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 1343 : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::~basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >, COMDAT

; 1196 : 		{	// construct unopened

$LN22:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_fstream@DU?$char_traits@D@std@@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00035	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  00039	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00046	90		 npad	 1
  00047	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 654  : 		}
; 655  : 
; 656  : 	bool _Endwrite()
; 657  : 		{	// put shift to initial conversion state, as needed
; 658  : 		if (_Pcvt == 0 || !_Wrotesome)
; 659  : 			return (true);
; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 665  : 				return (false);
; 666  : 
; 667  : 			string _Str(_STRING_INC, '\0');
; 668  : 			for (; ; )
; 669  : 				switch (_Pcvt->unshift(_State,
; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully
; 674  : 
; 675  : 				case codecvt_base::partial:	// fall through
; 676  : 					{	// put any generated bytes
; 677  : 					size_t _Count = _Dest - &*_Str.begin();
; 678  : 					if (0 < _Count && _Count !=
; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)
; 682  : 						return (true);
; 683  : 					if (_Count == 0)
; 684  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 685  : 					break;
; 686  : 					}
; 687  : 
; 688  : 				case codecvt_base::noconv:
; 689  : 					return (true);	// nothing to do
; 690  : 
; 691  : 				default:
; 692  : 					return (false);	// conversion failed
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 
; 697  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 698  : 		{	// initialize codecvt pointer
; 699  : 		if (_Newpcvt->always_noconv())
; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering
; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : private:
; 709  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 710  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 711  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 712  : 	typename _Traits::state_type _State;	// current conversion state
; 713  : 	bool _Closef;	// true if C stream must be closed
; 714  : 	_Filet *_Myfile;	// pointer to C stream
; 715  : 
; 716  : 	void _Reset_back()
; 717  : 		{	// restore buffer after putback
; 718  : 		if (_Mysb::eback() == &_Mychar)
; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 720  : 		}
; 721  : 
; 722  : 	void _Set_back()
; 723  : 		{	// set up putback area
; 724  : 		if (_Mysb::eback() != &_Mychar)
; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();
; 727  : 			_Set_egptr = _Mysb::egptr();
; 728  : 			}
; 729  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 730  : 		}
; 731  : 
; 732  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 733  : 	_Elem *_Set_egptr;	// saves egptr()
; 734  : 	};
; 735  : 
; 736  : 	// basic_filebuf TEMPLATE OPERATORS
; 737  : template<class _Elem,
; 738  : 	class _Traits> inline
; 739  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 740  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 741  : 	{	// swap _Left and _Right basic_filebufs
; 742  : 	_Left.swap(_Right);
; 743  : 	}
; 744  : 
; 745  : 		// TEMPLATE CLASS basic_ifstream
; 746  : template<class _Elem,
; 747  : 	class _Traits>
; 748  : 	class basic_ifstream
; 749  : 		: public basic_istream<_Elem, _Traits>
; 750  : 	{	// input stream associated with a C stream
; 751  : public:
; 752  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 753  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 754  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 755  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 756  : 
; 757  : 	basic_ifstream()
; 758  : 		: _Mybase(&_Filebuffer)
; 759  : 		{	// construct unopened
; 760  : 		}
; 761  : 
; 762  : 	explicit basic_ifstream(const char *_Filename,
; 763  : 		ios_base::openmode _Mode = ios_base::in,
; 764  : 		int _Prot = (int)ios_base::_Openprot)
; 765  : 		: _Mybase(&_Filebuffer)
; 766  : 		{	// construct with named file and specified mode
; 767  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 768  : 			_Myios::setstate(ios_base::failbit);
; 769  : 		}
; 770  : 
; 771  : 	explicit basic_ifstream(const string& _Str,
; 772  : 		ios_base::openmode _Mode = ios_base::in,
; 773  : 		int _Prot = (int)ios_base::_Openprot)
; 774  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 775  : 		{	// construct with named file and specified mode
; 776  : 		}
; 777  : 
; 778  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 779  : 		ios_base::openmode _Mode = ios_base::in,
; 780  : 		int _Prot = (int)ios_base::_Openprot)
; 781  : 		: _Mybase(&_Filebuffer)
; 782  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 783  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 784  : 			_Myios::setstate(ios_base::failbit);
; 785  : 		}
; 786  : 
; 787  : 	explicit basic_ifstream(const wstring& _Str,
; 788  : 		ios_base::openmode _Mode = ios_base::in,
; 789  : 		int _Prot = (int)ios_base::_Openprot)
; 790  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 791  : 		{	// construct with wide-named file -- EXTENSION
; 792  : 		}
; 793  : 
; 794  : 	template<class _Path_ish = experimental::filesystem::path>
; 795  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 796  : 		ios_base::openmode _Mode = ios_base::in,
; 797  : 		int _Prot = (int)ios_base::_Openprot)
; 798  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 799  : 		{	// construct with path-named file
; 800  : 		}
; 801  : 
; 802  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 803  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 804  : 		ios_base::openmode _Mode = ios_base::in,
; 805  : 		int _Prot = (int)ios_base::_Openprot)
; 806  : 		: _Mybase(&_Filebuffer)
; 807  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 808  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 809  : 			_Myios::setstate(ios_base::failbit);
; 810  : 		}
; 811  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 812  : 
; 813  : 	explicit basic_ifstream(_Filet *_File)
; 814  : 		: _Mybase(&_Filebuffer),
; 815  : 			_Filebuffer(_File)
; 816  : 		{	// construct with specified C stream
; 817  : 		}
; 818  : 
; 819  : 	basic_ifstream(_Myt&& _Right)
; 820  : 		: _Mybase(&_Filebuffer)
; 821  : 		{	// construct by moving _Right
; 822  : 		_Assign_rv(_STD move(_Right));
; 823  : 		}
; 824  : 
; 825  : 	_Myt& operator=(_Myt&& _Right)
; 826  : 		{	// move from _Right
; 827  : 		_Assign_rv(_STD move(_Right));
; 828  : 		return (*this);
; 829  : 		}
; 830  : 
; 831  : 	void _Assign_rv(_Myt&& _Right)
; 832  : 		{	// assign by moving _Right
; 833  : 		if (this != _STD addressof(_Right))
; 834  : 			{	// different, worth moving
; 835  : 			_Filebuffer.close();
; 836  : 			this->swap(_Right);
; 837  : 			}
; 838  : 		}
; 839  : 
; 840  : 	void swap(_Myt& _Right)
; 841  : 		{	// swap with _Right
; 842  : 		if (this != _STD addressof(_Right))
; 843  : 			{	// different, swap base and buffer
; 844  : 			_Mybase::swap(_Right);
; 845  : 			_Filebuffer.swap(_Right._Filebuffer);
; 846  : 			}
; 847  : 		}
; 848  : 
; 849  : 	basic_ifstream(const _Myt&) = delete;
; 850  : 	_Myt& operator=(const _Myt&) = delete;
; 851  : 
; 852  : 	void open(const wchar_t *_Filename,
; 853  : 		ios_base::openmode _Mode = ios_base::in,
; 854  : 		int _Prot = (int)ios_base::_Openprot)
; 855  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 856  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 857  : 			_Myios::setstate(ios_base::failbit);
; 858  : 		else
; 859  : 			_Myios::clear();	// added with C++11
; 860  : 		}
; 861  : 
; 862  : 	void open(const wstring& _Str,
; 863  : 		ios_base::openmode _Mode = ios_base::in,
; 864  : 		int _Prot = (int)ios_base::_Openprot)
; 865  : 		{	// open a wide-named C stream -- EXTENSION
; 866  : 		open(_Str.c_str(), _Mode, _Prot);
; 867  : 		}
; 868  : 
; 869  : 	template<class _Path_ish = experimental::filesystem::path>
; 870  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 871  : 		ios_base::openmode _Mode = ios_base::in,
; 872  : 		int _Prot = (int)ios_base::_Openprot)
; 873  : 		{	// open a path-named C stream
; 874  : 		open(_Path.c_str(), _Mode, _Prot);
; 875  : 		}
; 876  : 
; 877  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 878  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 879  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 880  : 		open(_Filename, (ios_base::openmode)_Mode);
; 881  : 		}
; 882  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 883  : 
; 884  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 885  : 	void open(const unsigned short *_Filename,
; 886  : 		ios_base::openmode _Mode = ios_base::in,
; 887  : 		int _Prot = (int)ios_base::_Openprot)
; 888  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 889  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 890  : 			_Myios::setstate(ios_base::failbit);
; 891  : 		else
; 892  : 			_Myios::clear();	// added with C++11
; 893  : 		}
; 894  : 
; 895  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 896  : 	void open(const unsigned short *_Filename,
; 897  : 		ios_base::open_mode _Mode)
; 898  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 899  : 		open(_Filename, (ios_base::openmode)_Mode);
; 900  : 		}
; 901  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 902  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 903  : 
; 904  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 905  : 		{	// destroy the object
; 906  : 		}
; 907  : 
; 908  : 	_Myfb *rdbuf() const
; 909  : 		{	// return pointer to file buffer
; 910  : 		return ((_Myfb *)&_Filebuffer);
; 911  : 		}
; 912  : 
; 913  : 	bool is_open() const
; 914  : 		{	// test if C stream has been opened
; 915  : 		return (_Filebuffer.is_open());
; 916  : 		}
; 917  : 
; 918  : 	void open(const char *_Filename,
; 919  : 		ios_base::openmode _Mode = ios_base::in,
; 920  : 		int _Prot = (int)ios_base::_Openprot)
; 921  : 		{	// open a C stream with specified mode
; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 923  : 			_Myios::setstate(ios_base::failbit);
; 924  : 		else
; 925  : 			_Myios::clear();	// added with C++11
; 926  : 		}
; 927  : 
; 928  : 	void open(const string& _Str,
; 929  : 		ios_base::openmode _Mode = ios_base::in,
; 930  : 		int _Prot = (int)ios_base::_Openprot)
; 931  : 		{	// open a C stream with specified mode
; 932  : 		open(_Str.c_str(), _Mode, _Prot);
; 933  : 		}
; 934  : 
; 935  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 936  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 937  : 		{	// open named file with specified mode (old style)
; 938  : 		open(_Filename, (ios_base::openmode)_Mode);
; 939  : 		}
; 940  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 941  : 
; 942  : 	void close()
; 943  : 		{	// close the C stream
; 944  : 		if (_Filebuffer.close() == 0)
; 945  : 			_Myios::setstate(ios_base::failbit);
; 946  : 		}
; 947  : 
; 948  : private:
; 949  : 	_Myfb _Filebuffer;	// the file buffer
; 950  : 	};
; 951  : 
; 952  : 	// basic_ifstream TEMPLATE OPERATORS
; 953  : template<class _Elem,
; 954  : 	class _Traits> inline
; 955  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 956  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 957  : 	{	// swap _Left and _Right basic_ifstreams
; 958  : 	_Left.swap(_Right);
; 959  : 	}
; 960  : 
; 961  : 		// TEMPLATE CLASS basic_ofstream
; 962  : template<class _Elem,
; 963  : 	class _Traits>
; 964  : 	class basic_ofstream
; 965  : 		: public basic_ostream<_Elem, _Traits>
; 966  : 	{	// output stream associated with a C stream
; 967  : public:
; 968  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 969  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 970  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 971  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 972  : 
; 973  : 	basic_ofstream()
; 974  : 		: _Mybase(&_Filebuffer)
; 975  : 		{	// construct unopened
; 976  : 		}
; 977  : 
; 978  : 	explicit basic_ofstream(const char *_Filename,
; 979  : 		ios_base::openmode _Mode = ios_base::out,
; 980  : 		int _Prot = (int)ios_base::_Openprot)
; 981  : 		: _Mybase(&_Filebuffer)
; 982  : 		{	// construct with named file and specified mode
; 983  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 984  : 			_Myios::setstate(ios_base::failbit);
; 985  : 		}
; 986  : 
; 987  : 	explicit basic_ofstream(const string& _Str,
; 988  : 		ios_base::openmode _Mode = ios_base::out,
; 989  : 		int _Prot = (int)ios_base::_Openprot)
; 990  : 		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
; 991  : 		{	// construct with named file and specified mode
; 992  : 		}
; 993  : 
; 994  : 	explicit basic_ofstream(const wchar_t *_Filename,
; 995  : 		ios_base::openmode _Mode = ios_base::out,
; 996  : 		int _Prot = (int)ios_base::_Openprot)
; 997  : 		: _Mybase(&_Filebuffer)
; 998  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 999  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1000 : 			_Myios::setstate(ios_base::failbit);
; 1001 : 		}
; 1002 : 
; 1003 : 	explicit basic_ofstream(const wstring& _Str,
; 1004 : 		ios_base::openmode _Mode = ios_base::out,
; 1005 : 		int _Prot = (int)ios_base::_Openprot)
; 1006 : 		: basic_ofstream(_Str.c_str(), _Mode, _Prot)
; 1007 : 		{	// construct with wide-named file -- EXTENSION
; 1008 : 		}
; 1009 : 
; 1010 : 	template<class _Path_ish = experimental::filesystem::path>
; 1011 : 		explicit basic_ofstream(const _Identity_t<_Path_ish>& _Path,
; 1012 : 		ios_base::openmode _Mode = ios_base::out,
; 1013 : 		int _Prot = (int)ios_base::_Openprot)
; 1014 : 		: basic_ofstream(_Path.c_str(), _Mode, _Prot)
; 1015 : 		{	// construct with path-named file
; 1016 : 		}
; 1017 : 
; 1018 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1019 : 	explicit basic_ofstream(const unsigned short *_Filename,
; 1020 : 		ios_base::openmode _Mode = ios_base::out,
; 1021 : 		int _Prot = (int)ios_base::_Openprot)
; 1022 : 		: _Mybase(&_Filebuffer)
; 1023 : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 1024 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1025 : 			_Myios::setstate(ios_base::failbit);
; 1026 : 		}
; 1027 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1028 : 
; 1029 : 	explicit basic_ofstream(_Filet *_File)
; 1030 : 		: _Mybase(&_Filebuffer),
; 1031 : 			_Filebuffer(_File)
; 1032 : 		{	// construct with specified C stream
; 1033 : 		}
; 1034 : 
; 1035 : 	basic_ofstream(_Myt&& _Right)
; 1036 : 		: _Mybase(&_Filebuffer)
; 1037 : 		{	// construct by moving _Right
; 1038 : 		_Assign_rv(_STD move(_Right));
; 1039 : 		}
; 1040 : 
; 1041 : 	_Myt& operator=(_Myt&& _Right)
; 1042 : 		{	// move from _Right
; 1043 : 		_Assign_rv(_STD move(_Right));
; 1044 : 		return (*this);
; 1045 : 		}
; 1046 : 
; 1047 : 	void _Assign_rv(_Myt&& _Right)
; 1048 : 		{	// assign by moving _Right
; 1049 : 		if (this != _STD addressof(_Right))
; 1050 : 			{	// different, worth moving
; 1051 : 			_Filebuffer.close();
; 1052 : 			this->swap(_Right);
; 1053 : 			}
; 1054 : 		}
; 1055 : 
; 1056 : 	void swap(_Myt& _Right)
; 1057 : 		{	// swap with _Right
; 1058 : 		if (this != _STD addressof(_Right))
; 1059 : 			{	// different, swap base and buffer
; 1060 : 			_Mybase::swap(_Right);
; 1061 : 			_Filebuffer.swap(_Right._Filebuffer);
; 1062 : 			}
; 1063 : 		}
; 1064 : 
; 1065 : 	basic_ofstream(const _Myt&) = delete;
; 1066 : 	_Myt& operator=(const _Myt&) = delete;
; 1067 : 
; 1068 : 	void open(const wchar_t *_Filename,
; 1069 : 		ios_base::openmode _Mode = ios_base::out,
; 1070 : 		int _Prot = (int)ios_base::_Openprot)
; 1071 : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 1072 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1073 : 			_Myios::setstate(ios_base::failbit);
; 1074 : 		else
; 1075 : 			_Myios::clear();	// added with C++11
; 1076 : 		}
; 1077 : 
; 1078 : 	void open(const wstring& _Str,
; 1079 : 		ios_base::openmode _Mode = ios_base::out,
; 1080 : 		int _Prot = (int)ios_base::_Openprot)
; 1081 : 		{	// open a wide-named C stream -- EXTENSION
; 1082 : 		open(_Str.c_str(), _Mode, _Prot);
; 1083 : 		}
; 1084 : 
; 1085 : 	template<class _Path_ish = experimental::filesystem::path>
; 1086 : 		void open(const _Identity_t<_Path_ish>& _Path,
; 1087 : 		ios_base::openmode _Mode = ios_base::out,
; 1088 : 		int _Prot = (int)ios_base::_Openprot)
; 1089 : 		{	// open a path-named C stream
; 1090 : 		open(_Path.c_str(), _Mode, _Prot);
; 1091 : 		}
; 1092 : 
; 1093 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1094 : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 1095 : 		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
; 1096 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1097 : 		}
; 1098 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1099 : 
; 1100 :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 1101 : 	void open(const unsigned short *_Filename,
; 1102 : 		ios_base::openmode _Mode = ios_base::out,
; 1103 : 		int _Prot = (int)ios_base::_Openprot)
; 1104 : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 1105 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1106 : 			_Myios::setstate(ios_base::failbit);
; 1107 : 		else
; 1108 : 			_Myios::clear();	// added with C++11
; 1109 : 		}
; 1110 : 
; 1111 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1112 : 	void open(const unsigned short *_Filename,
; 1113 : 		ios_base::open_mode _Mode)
; 1114 : 		{	// open a wide-named C stream (old style) (in standard as const std::filesystem::path::value_type *)
; 1115 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1116 : 		}
; 1117 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1118 :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 1119 : 
; 1120 : 	virtual __CLR_OR_THIS_CALL ~basic_ofstream() _NOEXCEPT
; 1121 : 		{	// destroy the object
; 1122 : 		}
; 1123 : 
; 1124 : 	_Myfb *rdbuf() const
; 1125 : 		{	// return pointer to file buffer
; 1126 : 		return ((_Myfb *)&_Filebuffer);
; 1127 : 		}
; 1128 : 
; 1129 : 	bool is_open() const
; 1130 : 		{	// test if C stream has been opened
; 1131 : 		return (_Filebuffer.is_open());
; 1132 : 		}
; 1133 : 
; 1134 : 	void open(const char *_Filename,
; 1135 : 		ios_base::openmode _Mode = ios_base::out,
; 1136 : 		int _Prot = (int)ios_base::_Openprot)
; 1137 : 		{	// open a C stream with specified mode
; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)
; 1139 : 			_Myios::setstate(ios_base::failbit);
; 1140 : 		else
; 1141 : 			_Myios::clear();	// added with C++11
; 1142 : 		}
; 1143 : 
; 1144 : 	void open(const string& _Str,
; 1145 : 		ios_base::openmode _Mode = ios_base::out,
; 1146 : 		int _Prot = (int)ios_base::_Openprot)
; 1147 : 		{	// open a C stream with specified mode
; 1148 : 		open(_Str.c_str(), _Mode, _Prot);
; 1149 : 		}
; 1150 : 
; 1151 :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 1152 : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 1153 : 		{	// open a C stream with specified mode (old style)
; 1154 : 		open(_Filename, (ios_base::openmode)_Mode);
; 1155 : 		}
; 1156 :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 1157 : 
; 1158 : 	void close()
; 1159 : 		{	// close the C stream
; 1160 : 		if (_Filebuffer.close() == 0)
; 1161 : 			_Myios::setstate(ios_base::failbit);
; 1162 : 		}
; 1163 : 
; 1164 : private:
; 1165 : 	_Myfb _Filebuffer;	// the file buffer
; 1166 : 	};
; 1167 : 
; 1168 : 	// basic_ofstream TEMPLATE OPERATORS
; 1169 : template<class _Elem,
; 1170 : 	class _Traits> inline
; 1171 : 	void swap(basic_ofstream<_Elem, _Traits>& _Left,
; 1172 : 		basic_ofstream<_Elem, _Traits>& _Right)
; 1173 : 	{	// swap _Left and _Right basic_ofstreams
; 1174 : 	_Left.swap(_Right);
; 1175 : 	}
; 1176 : 
; 1177 : 		// TEMPLATE CLASS basic_fstream
; 1178 : template<class _Elem,
; 1179 : 	class _Traits>
; 1180 : 	class basic_fstream
; 1181 : 		: public basic_iostream<_Elem, _Traits>
; 1182 : 	{	// input/output stream associated with a C stream
; 1183 : public:
; 1184 : 	typedef basic_fstream<_Elem, _Traits> _Myt;
; 1185 : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 1186 : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 1187 : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 1188 : 	typedef _Elem char_type;
; 1189 : 	typedef _Traits traits_type;
; 1190 : 	typedef typename _Traits::int_type int_type;
; 1191 : 	typedef typename _Traits::pos_type pos_type;
; 1192 : 	typedef typename _Traits::off_type off_type;
; 1193 : 
; 1194 : 	basic_fstream()
; 1195 : 		: _Mybase(&_Filebuffer)

  0004f	48 8d 5f 18	 lea	 rbx, QWORD PTR [rdi+24]
  00053	45 33 c0	 xor	 r8d, r8d
  00056	48 8b d3	 mov	 rdx, rbx
  00059	48 8b cf	 mov	 rcx, rdi
  0005c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00062	90		 npad	 1

; 1196 : 		{	// construct unopened

  00063	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00066	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0006a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_fstream@DU?$char_traits@D@std@@@std@@6B@
  00071	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00075	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00078	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0007c	8d 91 48 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-184]
  00082	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  00086	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  0008b	48 8b cb	 mov	 rcx, rbx
  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00094	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  00095	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  0009c	48 89 03	 mov	 QWORD PTR [rbx], rax

; 625  : 		_Closef = _Which == _Openfl;

  0009f	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 626  : 		_Wrotesome = false;

  000a3	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  000b0	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 652  : 		_State = _Stinit;

  000bb	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000c2	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000c6	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 1197 : 		}

  000ce	48 8b c7	 mov	 rax, rdi
  000d1	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000d6	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000da	5f		 pop	 rdi
  000db	c3		 ret	 0
??0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b8 00
	00 00		 add	 rcx, 184		; 000000b8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_fstream<char,std::char_traits<char> >::basic_fstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$ = 56
_Mode$ = 64
_Prot$dead$ = 72
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::open, COMDAT

; 1137 : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 1138 : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::out, _Prot) == 0)

  00009	41 83 c8 02	 or	 r8d, 2
  0000d	48 83 c1 08	 add	 rcx, 8
  00011	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 1139 : 			_Myios::setstate(ios_base::failbit);

  00016	45 33 c0	 xor	 r8d, r8d
  00019	48 85 c0	 test	 rax, rax
  0001c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0001f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00023	75 13		 jne	 SHORT $LN2@open
  00025	48 03 cb	 add	 rcx, rbx
  00028	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]

; 1142 : 		}

  0002c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00030	5b		 pop	 rbx

; 1139 : 			_Myios::setstate(ios_base::failbit);

  00031	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 1140 : 		else
; 1141 : 			_Myios::clear();	// added with C++11

  00038	48 03 cb	 add	 rcx, rbx
  0003b	33 d2		 xor	 edx, edx

; 1142 : 		}

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx

; 1140 : 		else
; 1141 : 			_Myios::clear();	// added with C++11

  00042	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >, COMDAT

; 1121 : 		{	// destroy the object

$LN15:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 58 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-168]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 58
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-168], rax
  00031	48 8b 81 58 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-168]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 58 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-168]
  00043	44 89 84 0a 54
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-172], r8d

; 1122 : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_ofst
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_ofst

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_ofst:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_ofst

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_ofst:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 1122 : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::~basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >, COMDAT

; 975  : 		{	// construct unopened

$LN22:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ofstream@DU?$char_traits@D@std@@@std@@7B@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0003b	90		 npad	 1
  0003c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 654  : 		}
; 655  : 
; 656  : 	bool _Endwrite()
; 657  : 		{	// put shift to initial conversion state, as needed
; 658  : 		if (_Pcvt == 0 || !_Wrotesome)
; 659  : 			return (true);
; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 665  : 				return (false);
; 666  : 
; 667  : 			string _Str(_STRING_INC, '\0');
; 668  : 			for (; ; )
; 669  : 				switch (_Pcvt->unshift(_State,
; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully
; 674  : 
; 675  : 				case codecvt_base::partial:	// fall through
; 676  : 					{	// put any generated bytes
; 677  : 					size_t _Count = _Dest - &*_Str.begin();
; 678  : 					if (0 < _Count && _Count !=
; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)
; 682  : 						return (true);
; 683  : 					if (_Count == 0)
; 684  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 685  : 					break;
; 686  : 					}
; 687  : 
; 688  : 				case codecvt_base::noconv:
; 689  : 					return (true);	// nothing to do
; 690  : 
; 691  : 				default:
; 692  : 					return (false);	// conversion failed
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 
; 697  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 698  : 		{	// initialize codecvt pointer
; 699  : 		if (_Newpcvt->always_noconv())
; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering
; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : private:
; 709  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 710  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 711  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 712  : 	typename _Traits::state_type _State;	// current conversion state
; 713  : 	bool _Closef;	// true if C stream must be closed
; 714  : 	_Filet *_Myfile;	// pointer to C stream
; 715  : 
; 716  : 	void _Reset_back()
; 717  : 		{	// restore buffer after putback
; 718  : 		if (_Mysb::eback() == &_Mychar)
; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 720  : 		}
; 721  : 
; 722  : 	void _Set_back()
; 723  : 		{	// set up putback area
; 724  : 		if (_Mysb::eback() != &_Mychar)
; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();
; 727  : 			_Set_egptr = _Mysb::egptr();
; 728  : 			}
; 729  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 730  : 		}
; 731  : 
; 732  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 733  : 	_Elem *_Set_egptr;	// saves egptr()
; 734  : 	};
; 735  : 
; 736  : 	// basic_filebuf TEMPLATE OPERATORS
; 737  : template<class _Elem,
; 738  : 	class _Traits> inline
; 739  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 740  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 741  : 	{	// swap _Left and _Right basic_filebufs
; 742  : 	_Left.swap(_Right);
; 743  : 	}
; 744  : 
; 745  : 		// TEMPLATE CLASS basic_ifstream
; 746  : template<class _Elem,
; 747  : 	class _Traits>
; 748  : 	class basic_ifstream
; 749  : 		: public basic_istream<_Elem, _Traits>
; 750  : 	{	// input stream associated with a C stream
; 751  : public:
; 752  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 753  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 754  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 755  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 756  : 
; 757  : 	basic_ifstream()
; 758  : 		: _Mybase(&_Filebuffer)
; 759  : 		{	// construct unopened
; 760  : 		}
; 761  : 
; 762  : 	explicit basic_ifstream(const char *_Filename,
; 763  : 		ios_base::openmode _Mode = ios_base::in,
; 764  : 		int _Prot = (int)ios_base::_Openprot)
; 765  : 		: _Mybase(&_Filebuffer)
; 766  : 		{	// construct with named file and specified mode
; 767  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 768  : 			_Myios::setstate(ios_base::failbit);
; 769  : 		}
; 770  : 
; 771  : 	explicit basic_ifstream(const string& _Str,
; 772  : 		ios_base::openmode _Mode = ios_base::in,
; 773  : 		int _Prot = (int)ios_base::_Openprot)
; 774  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 775  : 		{	// construct with named file and specified mode
; 776  : 		}
; 777  : 
; 778  : 	explicit basic_ifstream(const wchar_t *_Filename,
; 779  : 		ios_base::openmode _Mode = ios_base::in,
; 780  : 		int _Prot = (int)ios_base::_Openprot)
; 781  : 		: _Mybase(&_Filebuffer)
; 782  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 783  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 784  : 			_Myios::setstate(ios_base::failbit);
; 785  : 		}
; 786  : 
; 787  : 	explicit basic_ifstream(const wstring& _Str,
; 788  : 		ios_base::openmode _Mode = ios_base::in,
; 789  : 		int _Prot = (int)ios_base::_Openprot)
; 790  : 		: basic_ifstream(_Str.c_str(), _Mode, _Prot)
; 791  : 		{	// construct with wide-named file -- EXTENSION
; 792  : 		}
; 793  : 
; 794  : 	template<class _Path_ish = experimental::filesystem::path>
; 795  : 		explicit basic_ifstream(const _Identity_t<_Path_ish>& _Path,
; 796  : 		ios_base::openmode _Mode = ios_base::in,
; 797  : 		int _Prot = (int)ios_base::_Openprot)
; 798  : 		: basic_ifstream(_Path.c_str(), _Mode, _Prot)
; 799  : 		{	// construct with path-named file
; 800  : 		}
; 801  : 
; 802  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 803  : 	explicit basic_ifstream(const unsigned short *_Filename,
; 804  : 		ios_base::openmode _Mode = ios_base::in,
; 805  : 		int _Prot = (int)ios_base::_Openprot)
; 806  : 		: _Mybase(&_Filebuffer)
; 807  : 		{	// construct with wide-named file (in standard as const std::filesystem::path::value_type *)
; 808  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 809  : 			_Myios::setstate(ios_base::failbit);
; 810  : 		}
; 811  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 812  : 
; 813  : 	explicit basic_ifstream(_Filet *_File)
; 814  : 		: _Mybase(&_Filebuffer),
; 815  : 			_Filebuffer(_File)
; 816  : 		{	// construct with specified C stream
; 817  : 		}
; 818  : 
; 819  : 	basic_ifstream(_Myt&& _Right)
; 820  : 		: _Mybase(&_Filebuffer)
; 821  : 		{	// construct by moving _Right
; 822  : 		_Assign_rv(_STD move(_Right));
; 823  : 		}
; 824  : 
; 825  : 	_Myt& operator=(_Myt&& _Right)
; 826  : 		{	// move from _Right
; 827  : 		_Assign_rv(_STD move(_Right));
; 828  : 		return (*this);
; 829  : 		}
; 830  : 
; 831  : 	void _Assign_rv(_Myt&& _Right)
; 832  : 		{	// assign by moving _Right
; 833  : 		if (this != _STD addressof(_Right))
; 834  : 			{	// different, worth moving
; 835  : 			_Filebuffer.close();
; 836  : 			this->swap(_Right);
; 837  : 			}
; 838  : 		}
; 839  : 
; 840  : 	void swap(_Myt& _Right)
; 841  : 		{	// swap with _Right
; 842  : 		if (this != _STD addressof(_Right))
; 843  : 			{	// different, swap base and buffer
; 844  : 			_Mybase::swap(_Right);
; 845  : 			_Filebuffer.swap(_Right._Filebuffer);
; 846  : 			}
; 847  : 		}
; 848  : 
; 849  : 	basic_ifstream(const _Myt&) = delete;
; 850  : 	_Myt& operator=(const _Myt&) = delete;
; 851  : 
; 852  : 	void open(const wchar_t *_Filename,
; 853  : 		ios_base::openmode _Mode = ios_base::in,
; 854  : 		int _Prot = (int)ios_base::_Openprot)
; 855  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 856  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 857  : 			_Myios::setstate(ios_base::failbit);
; 858  : 		else
; 859  : 			_Myios::clear();	// added with C++11
; 860  : 		}
; 861  : 
; 862  : 	void open(const wstring& _Str,
; 863  : 		ios_base::openmode _Mode = ios_base::in,
; 864  : 		int _Prot = (int)ios_base::_Openprot)
; 865  : 		{	// open a wide-named C stream -- EXTENSION
; 866  : 		open(_Str.c_str(), _Mode, _Prot);
; 867  : 		}
; 868  : 
; 869  : 	template<class _Path_ish = experimental::filesystem::path>
; 870  : 		void open(const _Identity_t<_Path_ish>& _Path,
; 871  : 		ios_base::openmode _Mode = ios_base::in,
; 872  : 		int _Prot = (int)ios_base::_Openprot)
; 873  : 		{	// open a path-named C stream
; 874  : 		open(_Path.c_str(), _Mode, _Prot);
; 875  : 		}
; 876  : 
; 877  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 878  : 	void open(const wchar_t *_Filename, ios_base::open_mode _Mode)
; 879  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 880  : 		open(_Filename, (ios_base::openmode)_Mode);
; 881  : 		}
; 882  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 883  : 
; 884  :  #ifdef _NATIVE_WCHAR_T_DEFINED
; 885  : 	void open(const unsigned short *_Filename,
; 886  : 		ios_base::openmode _Mode = ios_base::in,
; 887  : 		int _Prot = (int)ios_base::_Openprot)
; 888  : 		{	// open a wide-named C stream (in standard as const std::filesystem::path::value_type *)
; 889  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 890  : 			_Myios::setstate(ios_base::failbit);
; 891  : 		else
; 892  : 			_Myios::clear();	// added with C++11
; 893  : 		}
; 894  : 
; 895  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 896  : 	void open(const unsigned short *_Filename,
; 897  : 		ios_base::open_mode _Mode)
; 898  : 		{	// open wide-named file (old style) (in standard as const std::filesystem::path::value_type *)
; 899  : 		open(_Filename, (ios_base::openmode)_Mode);
; 900  : 		}
; 901  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 902  :  #endif /* _NATIVE_WCHAR_T_DEFINED */
; 903  : 
; 904  : 	virtual __CLR_OR_THIS_CALL ~basic_ifstream() _NOEXCEPT
; 905  : 		{	// destroy the object
; 906  : 		}
; 907  : 
; 908  : 	_Myfb *rdbuf() const
; 909  : 		{	// return pointer to file buffer
; 910  : 		return ((_Myfb *)&_Filebuffer);
; 911  : 		}
; 912  : 
; 913  : 	bool is_open() const
; 914  : 		{	// test if C stream has been opened
; 915  : 		return (_Filebuffer.is_open());
; 916  : 		}
; 917  : 
; 918  : 	void open(const char *_Filename,
; 919  : 		ios_base::openmode _Mode = ios_base::in,
; 920  : 		int _Prot = (int)ios_base::_Openprot)
; 921  : 		{	// open a C stream with specified mode
; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)
; 923  : 			_Myios::setstate(ios_base::failbit);
; 924  : 		else
; 925  : 			_Myios::clear();	// added with C++11
; 926  : 		}
; 927  : 
; 928  : 	void open(const string& _Str,
; 929  : 		ios_base::openmode _Mode = ios_base::in,
; 930  : 		int _Prot = (int)ios_base::_Openprot)
; 931  : 		{	// open a C stream with specified mode
; 932  : 		open(_Str.c_str(), _Mode, _Prot);
; 933  : 		}
; 934  : 
; 935  :  #if _HAS_OLD_IOSTREAMS_MEMBERS
; 936  : 	void open(const char *_Filename, ios_base::open_mode _Mode)
; 937  : 		{	// open named file with specified mode (old style)
; 938  : 		open(_Filename, (ios_base::openmode)_Mode);
; 939  : 		}
; 940  :  #endif /* _HAS_OLD_IOSTREAMS_MEMBERS */
; 941  : 
; 942  : 	void close()
; 943  : 		{	// close the C stream
; 944  : 		if (_Filebuffer.close() == 0)
; 945  : 			_Myios::setstate(ios_base::failbit);
; 946  : 		}
; 947  : 
; 948  : private:
; 949  : 	_Myfb _Filebuffer;	// the file buffer
; 950  : 	};
; 951  : 
; 952  : 	// basic_ifstream TEMPLATE OPERATORS
; 953  : template<class _Elem,
; 954  : 	class _Traits> inline
; 955  : 	void swap(basic_ifstream<_Elem, _Traits>& _Left,
; 956  : 		basic_ifstream<_Elem, _Traits>& _Right)
; 957  : 	{	// swap _Left and _Right basic_ifstreams
; 958  : 	_Left.swap(_Right);
; 959  : 	}
; 960  : 
; 961  : 		// TEMPLATE CLASS basic_ofstream
; 962  : template<class _Elem,
; 963  : 	class _Traits>
; 964  : 	class basic_ofstream
; 965  : 		: public basic_ostream<_Elem, _Traits>
; 966  : 	{	// output stream associated with a C stream
; 967  : public:
; 968  : 	typedef basic_ofstream<_Elem, _Traits> _Myt;
; 969  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 970  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 971  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 972  : 
; 973  : 	basic_ofstream()
; 974  : 		: _Mybase(&_Filebuffer)

  00044	48 8d 5f 08	 lea	 rbx, QWORD PTR [rdi+8]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b d3	 mov	 rdx, rbx
  00051	48 8b cf	 mov	 rcx, rdi
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0005a	90		 npad	 1

; 975  : 		{	// construct unopened

  0005b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0005e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ofstream@DU?$char_traits@D@std@@@std@@6B@
  00069	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  0006d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00070	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00074	8d 91 58 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-168]
  0007a	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  0007e	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  00083	48 8b cb	 mov	 rcx, rbx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0008c	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00094	48 89 03	 mov	 QWORD PTR [rbx], rax

; 625  : 		_Closef = _Which == _Openfl;

  00097	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 626  : 		_Wrotesome = false;

  0009b	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  000a8	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 652  : 		_State = _Stinit;

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000ba	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000be	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 976  : 		}

  000c6	48 8b c7	 mov	 rax, rdi
  000c9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
??0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 10	 add	 rcx, 16
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 a8 00
	00 00		 add	 rcx, 168		; 000000a8H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 10	 add	 rcx, 16
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_ostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ofstream<char,std::char_traits<char> >::basic_ofstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z
_TEXT	SEGMENT
this$ = 48
_Filename$dead$ = 56
_Mode$dead$ = 64
_Prot$dead$ = 72
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::open, COMDAT

; 921  : 		{	// open a C stream with specified mode

$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx

; 922  : 		if (_Filebuffer.open(_Filename, _Mode | ios_base::in, _Prot) == 0)

  00009	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0M@COFBHHKL@setting?4txt?$AA@
  00010	48 83 c1 10	 add	 rcx, 16
  00014	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001a	e8 00 00 00 00	 call	 ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ; std::basic_filebuf<char,std::char_traits<char> >::open

; 923  : 			_Myios::setstate(ios_base::failbit);

  0001f	45 33 c0	 xor	 r8d, r8d
  00022	48 85 c0	 test	 rax, rax
  00025	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00028	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0002c	75 13		 jne	 SHORT $LN2@open
  0002e	48 03 cb	 add	 rcx, rbx
  00031	41 8d 50 02	 lea	 edx, QWORD PTR [r8+2]

; 926  : 		}

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx

; 923  : 			_Myios::setstate(ios_base::failbit);

  0003a	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
$LN2@open:

; 924  : 		else
; 925  : 			_Myios::clear();	// added with C++11

  00041	48 03 cb	 add	 rcx, rbx
  00044	33 d2		 xor	 edx, edx

; 926  : 		}

  00046	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004a	5b		 pop	 rbx

; 924  : 		else
; 925  : 			_Myios::clear();	// added with C++11

  0004b	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?clear@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
?open@?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXPEBDHH@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::open
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >, COMDAT

; 905  : 		{	// destroy the object

$LN15:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  0001e	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00022	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00029	48 89 84 0a 50
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-176], rax
  00031	48 8b 81 50 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-176]
  00038	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0003c	44 8d 82 50 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-176]
  00043	44 89 84 0a 4c
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-180], r8d

; 906  : 		}

  0004b	48 8d 99 60 ff
	ff ff		 lea	 rbx, QWORD PTR [rcx-160]

; 161  : 		{	// destroy the object

  00052	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00059	48 89 03	 mov	 QWORD PTR [rbx], rax

; 162  : 		if (_Myfile != 0)

  0005c	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00064	74 2f		 je	 SHORT $LN9@basic_ifst
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00066	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0006a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0006e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00071	75 22		 jne	 SHORT $LN9@basic_ifst

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00073	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0007a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00081	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00084	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00088	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0008b	44 2b c2	 sub	 r8d, edx
  0008e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00092	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN9@basic_ifst:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00095	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00099	74 09		 je	 SHORT $LN5@basic_ifst

; 165  : 			close();

  0009b	48 8b cb	 mov	 rcx, rbx
  0009e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  000a3	90		 npad	 1
$LN5@basic_ifst:

; 166  : 		}

  000a4	48 8b cb	 mov	 rcx, rbx
  000a7	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  000ad	90		 npad	 1

; 906  : 		}

  000ae	48 8d 8f 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rdi-152]
  000b5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::~basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >, COMDAT

; 759  : 		{	// construct unopened

$LN22:
  00000	40 57		 push	 rdi
  00002	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00006	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  00014	48 8b f9	 mov	 rdi, rcx
  00017	48 89 4c 24 30	 mov	 QWORD PTR this$GSCopy$[rsp], rcx
  0001c	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00024	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_ifstream@DU?$char_traits@D@std@@@std@@7B@
  0002b	48 89 01	 mov	 QWORD PTR [rcx], rax
  0002e	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00035	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0003b	90		 npad	 1
  0003c	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 654  : 		}
; 655  : 
; 656  : 	bool _Endwrite()
; 657  : 		{	// put shift to initial conversion state, as needed
; 658  : 		if (_Pcvt == 0 || !_Wrotesome)
; 659  : 			return (true);
; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))
; 665  : 				return (false);
; 666  : 
; 667  : 			string _Str(_STRING_INC, '\0');
; 668  : 			for (; ; )
; 669  : 				switch (_Pcvt->unshift(_State,
; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully
; 674  : 
; 675  : 				case codecvt_base::partial:	// fall through
; 676  : 					{	// put any generated bytes
; 677  : 					size_t _Count = _Dest - &*_Str.begin();
; 678  : 					if (0 < _Count && _Count !=
; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)
; 682  : 						return (true);
; 683  : 					if (_Count == 0)
; 684  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 685  : 					break;
; 686  : 					}
; 687  : 
; 688  : 				case codecvt_base::noconv:
; 689  : 					return (true);	// nothing to do
; 690  : 
; 691  : 				default:
; 692  : 					return (false);	// conversion failed
; 693  : 				}
; 694  : 			}
; 695  : 		}
; 696  : 
; 697  : 	void _Initcvt(const _Cvt *_Newpcvt)
; 698  : 		{	// initialize codecvt pointer
; 699  : 		if (_Newpcvt->always_noconv())
; 700  : 			_Pcvt = 0;	// nothing to do
; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering
; 705  : 			}
; 706  : 		}
; 707  : 
; 708  : private:
; 709  : 	const _Cvt *_Pcvt;	// pointer to codecvt facet (may be null)
; 710  : 	_Elem _Mychar;	// putback character, when _Ungetc fails
; 711  : 	bool _Wrotesome;	// true if homing sequence may be needed
; 712  : 	typename _Traits::state_type _State;	// current conversion state
; 713  : 	bool _Closef;	// true if C stream must be closed
; 714  : 	_Filet *_Myfile;	// pointer to C stream
; 715  : 
; 716  : 	void _Reset_back()
; 717  : 		{	// restore buffer after putback
; 718  : 		if (_Mysb::eback() == &_Mychar)
; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);
; 720  : 		}
; 721  : 
; 722  : 	void _Set_back()
; 723  : 		{	// set up putback area
; 724  : 		if (_Mysb::eback() != &_Mychar)
; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();
; 727  : 			_Set_egptr = _Mysb::egptr();
; 728  : 			}
; 729  : 		_Mysb::setg(&_Mychar, &_Mychar, &_Mychar + 1);
; 730  : 		}
; 731  : 
; 732  : 	_Elem *_Set_eback;	// saves eback() during one-element putback
; 733  : 	_Elem *_Set_egptr;	// saves egptr()
; 734  : 	};
; 735  : 
; 736  : 	// basic_filebuf TEMPLATE OPERATORS
; 737  : template<class _Elem,
; 738  : 	class _Traits> inline
; 739  : 	void swap(basic_filebuf<_Elem, _Traits>& _Left,
; 740  : 		basic_filebuf<_Elem, _Traits>& _Right)
; 741  : 	{	// swap _Left and _Right basic_filebufs
; 742  : 	_Left.swap(_Right);
; 743  : 	}
; 744  : 
; 745  : 		// TEMPLATE CLASS basic_ifstream
; 746  : template<class _Elem,
; 747  : 	class _Traits>
; 748  : 	class basic_ifstream
; 749  : 		: public basic_istream<_Elem, _Traits>
; 750  : 	{	// input stream associated with a C stream
; 751  : public:
; 752  : 	typedef basic_ifstream<_Elem, _Traits> _Myt;
; 753  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 754  : 	typedef basic_filebuf<_Elem, _Traits> _Myfb;
; 755  : 	typedef basic_ios<_Elem, _Traits> _Myios;
; 756  : 
; 757  : 	basic_ifstream()
; 758  : 		: _Mybase(&_Filebuffer)

  00044	48 8d 5f 10	 lea	 rbx, QWORD PTR [rdi+16]
  00048	45 33 c9	 xor	 r9d, r9d
  0004b	45 33 c0	 xor	 r8d, r8d
  0004e	48 8b d3	 mov	 rdx, rbx
  00051	48 8b cf	 mov	 rcx, rdi
  00054	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@_N@Z
  0005a	90		 npad	 1

; 759  : 		{	// construct unopened

  0005b	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0005e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00062	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_ifstream@DU?$char_traits@D@std@@@std@@6B@
  00069	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  0006d	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00070	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00074	8d 91 50 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-176]
  0007a	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx
  0007e	48 89 5c 24 40	 mov	 QWORD PTR this$[rsp], rbx

; 155  : 		: _Mysb()

  00083	48 8b cb	 mov	 rcx, rbx
  00086	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0008c	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0008d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00094	48 89 03	 mov	 QWORD PTR [rbx], rax

; 625  : 		_Closef = _Which == _Openfl;

  00097	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 626  : 		_Wrotesome = false;

  0009b	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  0009f	48 8b cb	 mov	 rcx, rbx
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  000a8	48 c7 83 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rbx+128], 0

; 652  : 		_State = _Stinit;

  000b3	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  000ba	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  000be	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 760  : 		}

  000c6	48 8b c7	 mov	 rax, rdi
  000c9	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000ce	48 83 c4 50	 add	 rsp, 80			; 00000050H
  000d2	5f		 pop	 rdi
  000d3	c3		 ret	 0
??0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 30	 mov	 rcx, QWORD PTR this$GSCopy$[rbp]
  0001b	48 81 c1 b0 00
	00 00		 add	 rcx, 176		; 000000b0H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
  0002e	48 8b 8a 30 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00035	48 83 c1 18	 add	 rcx, 24
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_istream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T2 = 40
this$GSCopy$ = 48
this$ = 64
this$ = 96
$initVBases$dead$ = 104
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA PROC ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
  00040	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAA@XZ@4HA ENDP ; `std::basic_ifstream<char,std::char_traits<char> >::basic_ifstream<char,std::char_traits<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z
_TEXT	SEGMENT
this$ = 48
_Loc$ = 56
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::imbue, COMDAT

; 617  : 		{	// set locale to argument (capture nontrivial codecvt facet)

$LN14:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx

; 618  : 		_Initcvt(&_USE(_Loc, _Cvt));

  0000d	48 8b ca	 mov	 rcx, rdx
  00010	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >

; 699  : 		if (_Newpcvt->always_noconv())

  00015	48 8b c8	 mov	 rcx, rax

; 618  : 		_Initcvt(&_USE(_Loc, _Cvt));

  00018	48 8b f8	 mov	 rdi, rax

; 699  : 		if (_Newpcvt->always_noconv())

  0001b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00021	84 c0		 test	 al, al
  00023	74 13		 je	 SHORT $LN4@imbue

; 700  : 			_Pcvt = 0;	// nothing to do

  00025	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 619  : 		}

  0002d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00032	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00036	5f		 pop	 rdi
  00037	c3		 ret	 0
$LN4@imbue:

; 704  : 			_Mysb::_Init();	// reset any buffering

  00038	48 8b cb	 mov	 rcx, rbx
  0003b	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 619  : 		}

  0003f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5f		 pop	 rdi

; 704  : 			_Mysb::_Init();	// reset any buffering

  00049	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?imbue@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAXAEBVlocale@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::imbue
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::sync, COMDAT

; 610  : 		{	// synchronize C stream with external file

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 611  : 		return (_Myfile == 0

  00006	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0000e	48 8b d9	 mov	 rbx, rcx
  00011	74 28		 je	 SHORT $LN3@sync
  00013	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00016	83 ca ff	 or	 edx, -1
  00019	ff 50 18	 call	 QWORD PTR [rax+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0001c	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 611  : 		return (_Myfile == 0

  0001f	74 1a		 je	 SHORT $LN3@sync
  00021	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush
  0002e	85 c0		 test	 eax, eax
  00030	79 09		 jns	 SHORT $LN3@sync
  00032	83 c8 ff	 or	 eax, -1

; 612  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 613  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 614  : 		}

  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5b		 pop	 rbx
  0003a	c3		 ret	 0
$LN3@sync:

; 611  : 		return (_Myfile == 0

  0003b	33 c0		 xor	 eax, eax

; 612  : 			|| _Traits::eq_int_type(_Traits::eof(), overflow())
; 613  : 			|| 0 <= fflush(_Myfile) ? 0 : -1);
; 614  : 		}

  0003d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00041	5b		 pop	 rbx
  00042	c3		 ret	 0
?sync@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::sync
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z
_TEXT	SEGMENT
this$ = 48
_Buffer$ = 56
_Count$ = 64
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::setbuf, COMDAT

; 597  : 		{	// offer _Buffer to C stream

$LN9:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	4d 8b c8	 mov	 r9, r8

; 598  : 		if (_Myfile == 0 || setvbuf(_Myfile, (char *)_Buffer,

  0000c	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00013	48 85 c9	 test	 rcx, rcx
  00016	74 39		 je	 SHORT $LN4@setbuf
  00018	48 85 d2	 test	 rdx, rdx
  0001b	75 0b		 jne	 SHORT $LN6@setbuf
  0001d	4d 85 c0	 test	 r8, r8
  00020	75 06		 jne	 SHORT $LN6@setbuf
  00022	45 8d 41 04	 lea	 r8d, QWORD PTR [r9+4]
  00026	eb 03		 jmp	 SHORT $LN7@setbuf
$LN6@setbuf:
  00028	45 33 c0	 xor	 r8d, r8d
$LN7@setbuf:
  0002b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_setvbuf
  00031	85 c0		 test	 eax, eax
  00033	75 1c		 jne	 SHORT $LN4@setbuf

; 602  : 		else
; 603  : 			{	// new buffer, reinitialize pointers
; 604  : 			_Init(_Myfile, _Openfl);

  00035	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0003c	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 605  : 			return (this);

  00048	48 8b c3	 mov	 rax, rbx

; 606  : 			}
; 607  : 		}

  0004b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004f	5b		 pop	 rbx
  00050	c3		 ret	 0
$LN4@setbuf:

; 599  : 			_Buffer == 0 && _Count == 0 ? _IONBF : _IOFBF,
; 600  : 			(size_t)_Count * sizeof (_Elem)) != 0)
; 601  : 			return (0);	// failed

  00051	33 c0		 xor	 eax, eax

; 606  : 			}
; 607  : 		}

  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5b		 pop	 rbx
  00058	c3		 ret	 0
?setbuf@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAPEAV?$basic_streambuf@DU?$char_traits@D@std@@@2@PEAD_J@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::setbuf
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 80
__$ReturnUdt$ = 88
_Pos$ = 96
__formal$ = 104
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekpos, COMDAT

; 579  : 		{	// change position to _Pos

$LN18:
  00000	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00014	48 33 c4	 xor	 rax, rsp
  00017	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 580  : 		fpos_t _Fileposition = _POS_TYPE_TO_FPOS_T(_Pos);
; 581  : 		off_type _Off = static_cast<off_type>(_Pos) - static_cast<off_type>(_Fileposition);
; 582  : 
; 583  : 		if (_Myfile == 0 || !_Endwrite()
; 584  : 			|| fsetpos(_Myfile, &_Fileposition) != 0
; 585  : 			|| (_Off != 0 && _fseeki64(_Myfile, _Off, SEEK_CUR) != 0)
; 586  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  0001c	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00024	4d 8b f0	 mov	 r14, r8
  00027	49 8b 40 08	 mov	 rax, QWORD PTR [r8+8]
  0002b	48 8b da	 mov	 rbx, rdx
  0002e	49 8b 30	 mov	 rsi, QWORD PTR [r8]
  00031	48 8b f9	 mov	 rdi, rcx
  00034	48 89 44 24 20	 mov	 QWORD PTR _Fileposition$[rsp], rax
  00039	74 7c		 je	 SHORT $LN3@seekpos
  0003b	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00040	84 c0		 test	 al, al
  00042	74 73		 je	 SHORT $LN3@seekpos
  00044	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0004b	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fsetpos
  00056	85 c0		 test	 eax, eax
  00058	75 5d		 jne	 SHORT $LN3@seekpos
  0005a	48 85 f6	 test	 rsi, rsi
  0005d	74 18		 je	 SHORT $LN4@seekpos
  0005f	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  00066	44 8d 40 01	 lea	 r8d, QWORD PTR [rax+1]
  0006a	48 8b d6	 mov	 rdx, rsi
  0006d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00073	85 c0		 test	 eax, eax
  00075	75 40		 jne	 SHORT $LN3@seekpos
$LN4@seekpos:
  00077	48 8b 8f 80 00
	00 00		 mov	 rcx, QWORD PTR [rdi+128]
  0007e	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  00089	85 c0		 test	 eax, eax
  0008b	75 2a		 jne	 SHORT $LN3@seekpos

; 588  : 
; 589  : 		_State = _POS_TYPE_TO_STATE(_Pos);

  0008d	49 8b 4e 10	 mov	 rcx, QWORD PTR [r14+16]
  00091	48 89 4f 74	 mov	 QWORD PTR [rdi+116], rcx

; 590  : 
; 591  : 		_Reset_back();	// revert from _Mychar buffer, discarding any putback

  00095	48 8b cf	 mov	 rcx, rdi
  00098	e8 00 00 00 00	 call	 ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back

; 592  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  0009d	48 8b 4f 74	 mov	 rcx, QWORD PTR [rdi+116]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000a1	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Fileposition$[rsp]
  000a6	48 89 53 08	 mov	 QWORD PTR [rbx+8], rdx
  000aa	48 c7 03 00 00
	00 00		 mov	 QWORD PTR [rbx], 0
  000b1	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 592  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000b5	eb 1b		 jmp	 SHORT $LN16@seekpos
$LN3@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000b7	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000be	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000c1	33 c0		 xor	 eax, eax
  000c3	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  000c6	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  000ce	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
$LN16@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 587  : 			return (pos_type(_BADOFF));	// report failure

  000d2	48 8b c3	 mov	 rax, rbx

; 593  : 			_Fileposition));	// return new position
; 594  : 		}

  000d5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000da	48 33 cc	 xor	 rcx, rsp
  000dd	e8 00 00 00 00	 call	 __security_check_cookie
  000e2	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  000e7	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000eb	41 5e		 pop	 r14
  000ed	5f		 pop	 rdi
  000ee	5e		 pop	 rsi
  000ef	c3		 ret	 0
?seekpos@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
_Fileposition$ = 32
__$ArrayPad$ = 40
this$ = 96
__$ReturnUdt$ = 104
_Off$ = 112
_Way$ = 120
__formal$ = 128
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::seekoff, COMDAT

; 557  : 		{	// change position by _Off

$LN23:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000b	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00012	48 33 c4	 xor	 rax, rsp
  00015	48 89 44 24 28	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0001a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 562  : 			&& _Pcvt == 0)	// not converting

  0001e	4c 8d 71 70	 lea	 r14, QWORD PTR [rcx+112]
  00022	41 8b e9	 mov	 ebp, r9d
  00025	49 8b f0	 mov	 rsi, r8
  00028	48 8b fa	 mov	 rdi, rdx
  0002b	48 8b d9	 mov	 rbx, rcx
  0002e	4c 39 30	 cmp	 QWORD PTR [rax], r14
  00031	75 10		 jne	 SHORT $LN2@seekoff
  00033	41 83 f9 01	 cmp	 r9d, 1
  00037	75 0a		 jne	 SHORT $LN2@seekoff
  00039	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  0003e	75 03		 jne	 SHORT $LN2@seekoff

; 563  : 			_Off -= (off_type)sizeof (_Elem);	// back up over _Elem bytes

  00040	48 ff ce	 dec	 rsi
$LN2@seekoff:

; 564  : 
; 565  : 		if (_Myfile == 0 || !_Endwrite()
; 566  : 			|| ((_Off != 0 || _Way != ios_base::cur)
; 567  : 				&& _fseeki64(_Myfile, _Off, _Way) != 0)
; 568  : 			|| fgetpos(_Myfile, &_Fileposition) != 0)

  00043	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0004b	0f 84 85 00 00
	00		 je	 $LN4@seekoff
  00051	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
  00056	84 c0		 test	 al, al
  00058	74 7c		 je	 SHORT $LN4@seekoff
  0005a	48 85 f6	 test	 rsi, rsi
  0005d	75 05		 jne	 SHORT $LN6@seekoff
  0005f	83 fd 01	 cmp	 ebp, 1
  00062	74 17		 je	 SHORT $LN5@seekoff
$LN6@seekoff:
  00064	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0006b	44 8b c5	 mov	 r8d, ebp
  0006e	48 8b d6	 mov	 rdx, rsi
  00071	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fseeki64
  00077	85 c0		 test	 eax, eax
  00079	75 5b		 jne	 SHORT $LN4@seekoff
$LN5@seekoff:
  0007b	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  00082	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Fileposition$[rsp]
  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetpos
  0008d	85 c0		 test	 eax, eax
  0008f	75 45		 jne	 SHORT $LN4@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00091	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00095	4c 39 30	 cmp	 QWORD PTR [rax], r14
  00098	75 22		 jne	 SHORT $LN13@seekoff

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0009a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
  000a1	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  000a8	48 89 10	 mov	 QWORD PTR [rax], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  000ab	44 2b c2	 sub	 r8d, edx
  000ae	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  000b2	48 89 11	 mov	 QWORD PTR [rcx], rdx
  000b5	48 8b 4b 50	 mov	 rcx, QWORD PTR [rbx+80]
  000b9	44 89 01	 mov	 DWORD PTR [rcx], r8d
$LN13@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 572  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000bc	48 8b 4b 74	 mov	 rcx, QWORD PTR [rbx+116]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  000c0	48 8b 54 24 20	 mov	 rdx, QWORD PTR _Fileposition$[rsp]
  000c5	48 89 57 08	 mov	 QWORD PTR [rdi+8], rdx
  000c9	48 89 4f 10	 mov	 QWORD PTR [rdi+16], rcx
  000cd	48 c7 07 00 00
	00 00		 mov	 QWORD PTR [rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 572  : 		return (_POS_TYPE_FROM_STATE(pos_type, _State,

  000d4	eb 1b		 jmp	 SHORT $LN21@seekoff
$LN4@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000d6	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  000dd	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  000e0	33 c0		 xor	 eax, eax
  000e2	48 89 0f	 mov	 QWORD PTR [rdi], rcx
  000e5	48 c7 47 08 00
	00 00 00	 mov	 QWORD PTR [rdi+8], 0
  000ed	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax
$LN21@seekoff:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 569  : 			return (pos_type(_BADOFF));	// report failure

  000f1	48 8b c7	 mov	 rax, rdi

; 573  : 			_Fileposition));	// return new position
; 574  : 		}

  000f4	48 8b 4c 24 28	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f9	48 33 cc	 xor	 rcx, rsp
  000fc	e8 00 00 00 00	 call	 __security_check_cookie
  00101	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00105	41 5e		 pop	 r14
  00107	5f		 pop	 rdi
  00108	5e		 pop	 rsi
  00109	5d		 pop	 rbp
  0010a	5b		 pop	 rbx
  0010b	c3		 ret	 0
?seekoff@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
$T77 = 64
_Src$78 = 72
_Dest$79 = 80
_Ch$80 = 88
_Str$81 = 96
__$ArrayPad$ = 128
this$ = 160
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::uflow, COMDAT

; 490  : 		{	// get an element from stream, point past it

$LN591:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  00008	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  0000f	48 c7 45 07 fe
	ff ff ff	 mov	 QWORD PTR $T77[rbp-57], -2
  00017	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  0001b	48 89 78 18	 mov	 QWORD PTR [rax+24], rdi
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 45 47	 mov	 QWORD PTR __$ArrayPad$[rbp-57], rax
  0002d	48 8b d9	 mov	 rbx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00030	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00034	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 492  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00037	48 85 c9	 test	 rcx, rcx
  0003a	74 2c		 je	 SHORT $LN10@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0003c	48 8b 53 50	 mov	 rdx, QWORD PTR [rbx+80]
  00040	4c 63 02	 movsxd	 r8, DWORD PTR [rdx]
  00043	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 492  : 			&& _Mysb::gptr() < _Mysb::egptr())

  00047	48 3b c8	 cmp	 rcx, rax
  0004a	73 1c		 jae	 SHORT $LN10@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 270  : 		--*_IGcount;

  0004c	41 8d 40 ff	 lea	 eax, DWORD PTR [r8-1]
  00050	89 02		 mov	 DWORD PTR [rdx], eax

; 271  : 		return ((*_IGnext)++);

  00052	48 8b 4b 38	 mov	 rcx, QWORD PTR [rbx+56]
  00056	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00059	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  0005d	48 89 01	 mov	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00060	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 493  : 			return (_Traits::to_int_type(

  00063	e9 7c 02 00 00	 jmp	 $LN526@uflow
$LN10@uflow:

; 494  : 				*_Mysb::_Gninc()));	// return buffered
; 495  : 		else if (_Myfile == 0)

  00068	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00070	75 08		 jne	 SHORT $LN12@uflow

; 496  : 			return (_Traits::eof());	// no open C stream, fail

  00072	83 c8 ff	 or	 eax, -1
  00075	e9 6a 02 00 00	 jmp	 $LN526@uflow
$LN12@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0007a	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0007e	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00082	49 39 00	 cmp	 QWORD PTR [r8], rax
  00085	75 20		 jne	 SHORT $LN44@uflow

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00087	48 8b 93 90 00
	00 00		 mov	 rdx, QWORD PTR [rbx+144]
  0008e	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00095	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  00098	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0009c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0009f	2b d1		 sub	 edx, ecx
  000a1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000a5	89 10		 mov	 DWORD PTR [rax], edx
$LN44@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 498  : 		if (_Pcvt == 0)

  000a7	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  000ac	75 22		 jne	 SHORT $LN13@uflow

; 49   : 	if ((_Meta = fgetc(_File)) == EOF)

  000ae	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000b5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc
  000bb	83 f8 ff	 cmp	 eax, -1
  000be	74 08		 je	 SHORT $LN23@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  000c0	0f b6 d8	 movzx	 ebx, al

; 538  : 		}

  000c3	e9 1a 02 00 00	 jmp	 $LN506@uflow
$LN23@uflow:

; 552  : 		return (EOF);

  000c8	83 cb ff	 or	 ebx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 501  : 			return (_Fgetc(_Ch, _Myfile) ? _Traits::to_int_type(_Ch)

  000cb	e9 12 02 00 00	 jmp	 $LN506@uflow
$LN13@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000d0	48 c7 45 37 00
	00 00 00	 mov	 QWORD PTR _Str$81[rbp-41], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000d8	48 c7 45 3f 0f
	00 00 00	 mov	 QWORD PTR _Str$81[rbp-33], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000e0	c6 45 27 00	 mov	 BYTE PTR _Str$81[rbp-57], 0
$LN376@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 513  : 				int _Meta = fgetc(_Myfile);

  000e4	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  000eb	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fgetc

; 515  : 				if (_Meta == EOF)

  000f1	83 f8 ff	 cmp	 eax, -1
  000f4	0f 84 9f 01 00
	00		 je	 $LN573@uflow
$_Invalid_parameter$592:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  000fa	48 8b 55 37	 mov	 rdx, QWORD PTR _Str$81[rbp-41]
  000fe	4c 8b ca	 mov	 r9, rdx

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00101	4c 8b 45 3f	 mov	 r8, QWORD PTR _Str$81[rbp-33]
  00105	49 8b c8	 mov	 rcx, r8
  00108	48 2b ca	 sub	 rcx, rdx
  0010b	48 83 f9 01	 cmp	 rcx, 1

; 1595 : 		value_type * _Result = _Bx._Buf;

  0010f	48 8d 4d 27	 lea	 rcx, QWORD PTR _Str$81[rbp-57]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00113	72 1f		 jb	 SHORT $LN134@uflow

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00115	48 ff c2	 inc	 rdx
  00118	48 89 55 37	 mov	 QWORD PTR _Str$81[rbp-41], rdx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0011c	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00120	48 0f 43 4d 27	 cmovae	 rcx, QWORD PTR _Str$81[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00125	0f b6 c0	 movzx	 al, al
  00128	42 88 04 09	 mov	 BYTE PTR [rcx+r9], al

; 517  : 		_Left = _Right;

  0012c	42 c6 44 09 01
	00		 mov	 BYTE PTR [rcx+r9+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00132	eb 11		 jmp	 SHORT $LN133@uflow
$LN134@uflow:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00134	88 44 24 20	 mov	 BYTE PTR [rsp+32], al
  00138	ba 01 00 00 00	 mov	 edx, 1
  0013d	44 8b ca	 mov	 r9d, edx
  00140	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN133@uflow:

; 1595 : 		value_type * _Result = _Bx._Buf;

  00145	48 8d 55 27	 lea	 rdx, QWORD PTR _Str$81[rbp-57]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00149	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$81[rbp-33], 16

; 1596 : 		if (_Large_string_engaged())

  0014e	48 0f 43 55 27	 cmovae	 rdx, QWORD PTR _Str$81[rbp-57]

; 1595 : 		value_type * _Result = _Bx._Buf;

  00153	4c 8d 45 27	 lea	 r8, QWORD PTR _Str$81[rbp-57]

; 1596 : 		if (_Large_string_engaged())

  00157	4c 0f 43 45 27	 cmovae	 r8, QWORD PTR _Str$81[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 519  : 				switch (_Pcvt->in(_State,

  0015c	4c 8b 4d 37	 mov	 r9, QWORD PTR _Str$81[rbp-41]
  00160	4c 03 ca	 add	 r9, rdx
  00163	48 8d 45 17	 lea	 rax, QWORD PTR _Dest$79[rbp-57]
  00167	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  0016c	48 8d 45 20	 lea	 rax, QWORD PTR _Ch$80[rbp-56]
  00170	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00175	48 8d 45 1f	 lea	 rax, QWORD PTR _Ch$80[rbp-57]
  00179	48 89 44 24 28	 mov	 QWORD PTR [rsp+40], rax
  0017e	48 8d 45 0f	 lea	 rax, QWORD PTR _Src$78[rbp-57]
  00182	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00187	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  0018b	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  0018f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?in@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  00195	85 c0		 test	 eax, eax
  00197	0f 88 fc 00 00
	00		 js	 $LN573@uflow
  0019d	83 f8 01	 cmp	 eax, 1
  001a0	7e 15		 jle	 SHORT $LN16@uflow
  001a2	83 f8 03	 cmp	 eax, 3
  001a5	0f 85 ee 00 00
	00		 jne	 $LN573@uflow

; 534  : 							(size_t)(_Src - &*_Str.begin()));
; 535  : 					break;
; 536  : 
; 537  : 				case codecvt_base::noconv:
; 538  : 					if (_Str.size() < sizeof (_Elem))

  001ab	48 83 7d 37 01	 cmp	 QWORD PTR _Str$81[rbp-41], 1
  001b0	73 5a		 jae	 SHORT $LN20@uflow

; 539  : 						break;	// no conversion, but need more chars

  001b2	e9 2d ff ff ff	 jmp	 $LN376@uflow
$LN16@uflow:

; 525  : 					if (_Dest != &_Ch)

  001b7	48 8d 45 1f	 lea	 rax, QWORD PTR _Ch$80[rbp-57]
  001bb	48 39 45 17	 cmp	 QWORD PTR _Dest$79[rbp-57], rax
$_Invalid_parameter$593:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  001bf	48 8d 45 27	 lea	 rax, QWORD PTR _Str$81[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 525  : 					if (_Dest != &_Ch)

  001c3	0f 85 84 00 00
	00		 jne	 $LN575@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001c9	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$81[rbp-33], 16

; 1596 : 		if (_Large_string_engaged())

  001ce	48 0f 43 45 27	 cmovae	 rax, QWORD PTR _Str$81[rbp-57]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 533  : 						_Str.erase((size_t)0,	// partial, discard used input

  001d3	4c 8b 55 0f	 mov	 r10, QWORD PTR _Src$78[rbp-57]
  001d7	4c 2b d0	 sub	 r10, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  001da	4c 8b 45 37	 mov	 r8, QWORD PTR _Str$81[rbp-41]
  001de	4d 3b c2	 cmp	 r8, r10
  001e1	4d 0f 42 d0	 cmovb	 r10, r8

; 1595 : 		value_type * _Result = _Bx._Buf;

  001e5	48 8d 4d 27	 lea	 rcx, QWORD PTR _Str$81[rbp-57]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  001e9	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$81[rbp-33], 16

; 1596 : 		if (_Large_string_engaged())

  001ee	48 0f 43 4d 27	 cmovae	 rcx, QWORD PTR _Str$81[rbp-57]

; 2621 : 		const size_type _New_size = _Old_size - _Count;

  001f3	4d 2b c2	 sub	 r8, r10

; 2622 : 		_My_data._Mysize = _New_size;

  001f6	4c 89 45 37	 mov	 QWORD PTR _Str$81[rbp-41], r8

; 2623 : 		_Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1); // move suffix + null up

  001fa	49 ff c0	 inc	 r8
  001fd	4a 8d 14 11	 lea	 rdx, QWORD PTR [rcx+r10]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00201	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 515  : 				if (_Meta == EOF)

  00207	e9 d8 fe ff ff	 jmp	 $LN376@uflow
$LN20@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0020c	48 8d 45 27	 lea	 rax, QWORD PTR _Str$81[rbp-57]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00210	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$81[rbp-57]
  00214	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$81[rbp-33], 16

; 1596 : 		if (_Large_string_engaged())

  00219	72 27		 jb	 SHORT $LN582@uflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0021b	48 8b c1	 mov	 rax, rcx
; File c:\program files (x86)\windows kits\10\include\10.0.16299.0\ucrt\corecrt_memcpy_s.h

; 48   :         if (_Source == NULL || _DestinationSize < _SourceSize)

  0021e	48 85 c9	 test	 rcx, rcx
  00221	75 1f		 jne	 SHORT $LN582@uflow

; 49   :         {
; 50   :             memset(_Destination, 0, _DestinationSize);

  00223	88 45 1f	 mov	 BYTE PTR _Ch$80[rbp-57], al

; 51   : 
; 52   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_Source != NULL,                 EINVAL);

  00226	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0022c	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
  00232	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo
  00238	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$81[rbp-57]
  0023c	0f b6 45 1f	 movzx	 eax, BYTE PTR _Ch$80[rbp-57]
  00240	eb 06		 jmp	 SHORT $LN425@uflow
$LN582@uflow:

; 53   :             _CRT_MEMCPY_S_VALIDATE_RETURN_ERRCODE(_DestinationSize >= _SourceSize, ERANGE);
; 54   : 
; 55   :             // Unreachable, but required to suppress /analyze warnings:
; 56   :             return EINVAL;
; 57   :         }
; 58   : 
; 59   :         memcpy(_Destination, _Source, _SourceSize);

  00242	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00245	88 45 1f	 mov	 BYTE PTR _Ch$80[rbp-57], al
$LN425@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00248	0f b6 d8	 movzx	 ebx, al
  0024b	eb 53		 jmp	 SHORT $LN428@uflow
$LN575@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1596 : 		if (_Large_string_engaged())

  0024d	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$81[rbp-57]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00251	48 83 7d 3f 10	 cmp	 QWORD PTR _Str$81[rbp-33], 16

; 1596 : 		if (_Large_string_engaged())

  00256	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 527  : 						_Nleft = (int)(&*_Str.begin() + _Str.size() - _Src);

  0025a	48 8b 55 0f	 mov	 rdx, QWORD PTR _Src$78[rbp-57]
  0025e	2b c2		 sub	 eax, edx
  00260	03 45 37	 add	 eax, DWORD PTR _Str$81[rbp-41]
  00263	48 63 f8	 movsxd	 rdi, eax

; 528  : 						for (; 0 < _Nleft; )

  00266	85 c0		 test	 eax, eax
  00268	7e 29		 jle	 SHORT $LN8@uflow
  0026a	66 0f 1f 44 00
	00		 npad	 6
$LL7@uflow:

; 529  : 							ungetc(_Src[--_Nleft], _Myfile);

  00270	48 ff cf	 dec	 rdi
  00273	0f be 0c 17	 movsx	 ecx, BYTE PTR [rdi+rdx]
  00277	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0027e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc

; 528  : 						for (; 0 < _Nleft; )

  00284	48 85 ff	 test	 rdi, rdi
  00287	7e 06		 jle	 SHORT $LN588@uflow
  00289	48 8b 55 0f	 mov	 rdx, QWORD PTR _Src$78[rbp-57]
  0028d	eb e1		 jmp	 SHORT $LL7@uflow
$LN588@uflow:
  0028f	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$81[rbp-57]
$LN8@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00293	0f b6 5d 1f	 movzx	 ebx, BYTE PTR _Ch$80[rbp-57]
  00297	eb 07		 jmp	 SHORT $LN428@uflow
$LN573@uflow:

; 552  : 		return (EOF);

  00299	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$81[rbp-57]
$_Invalid_parameter$594:
  0029d	83 cb ff	 or	 ebx, -1
$LN428@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  002a0	48 8b 45 3f	 mov	 rax, QWORD PTR _Str$81[rbp-33]
  002a4	48 83 f8 10	 cmp	 rax, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  002a8	72 38		 jb	 SHORT $LN506@uflow

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  002aa	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  002ad	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  002b3	72 28		 jb	 SHORT $LN509@uflow

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  002b5	f6 45 27 1f	 test	 BYTE PTR _Str$81[rbp-57], 31
  002b9	75 1b		 jne	 SHORT $_Invalid_parameter$595

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  002bb	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  002bf	48 3b c1	 cmp	 rax, rcx
  002c2	73 12		 jae	 SHORT $_Invalid_parameter$595
  002c4	48 2b c8	 sub	 rcx, rax
  002c7	48 83 e9 08	 sub	 rcx, 8
  002cb	48 83 f9 1f	 cmp	 rcx, 31
  002cf	77 05		 ja	 SHORT $_Invalid_parameter$595

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  002d1	48 8b c8	 mov	 rcx, rax
  002d4	eb 07		 jmp	 SHORT $LN509@uflow
$_Invalid_parameter$595:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  002d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002dc	cc		 int	 3
$LN509@uflow:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  002dd	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN506@uflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 547  : 					return (_Traits::eof());	// conversion failed

  002e2	8b c3		 mov	 eax, ebx
$LN526@uflow:

; 548  : 					}
; 549  : 				}
; 550  : 			}
; 551  : 		}

  002e4	48 8b 4d 47	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-57]
  002e8	48 33 cc	 xor	 rcx, rsp
  002eb	e8 00 00 00 00	 call	 __security_check_cookie
  002f0	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  002f8	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  002fc	49 8b 7b 20	 mov	 rdi, QWORD PTR [r11+32]
  00300	49 8b e3	 mov	 rsp, r11
  00303	5d		 pop	 rbp
  00304	c3		 ret	 0
$LN589@uflow:
?uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::uflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T77 = 64
_Src$78 = 72
_Dest$79 = 80
_Ch$80 = 88
_Str$81 = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$81[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T77 = 64
_Src$78 = 72
_Dest$79 = 80
_Ch$80 = 88
_Str$81 = 96
__$ArrayPad$ = 128
this$ = 160
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$81[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??uflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::uflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 48
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::underflow, COMDAT

; 475  : 		{	// get an element from stream, but don't point past it

$LN26:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00006	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 475  : 		{	// get an element from stream, but don't point past it

  0000a	48 8b d9	 mov	 rbx, rcx

; 478  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0000d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00010	48 85 c9	 test	 rcx, rcx
  00013	74 18		 je	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00015	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00019	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0001c	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 478  : 			&& _Mysb::gptr() < _Mysb::egptr())

  0001f	48 3b ca	 cmp	 rcx, rdx
  00022	73 09		 jae	 SHORT $LN2@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00024	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 487  : 		}

  00027	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002b	5b		 pop	 rbx
  0002c	c3		 ret	 0
$LN2@underflow:

; 480  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  0002d	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7c 24 30	 mov	 QWORD PTR [rsp+48], rdi
  00038	ff 50 38	 call	 QWORD PTR [rax+56]
  0003b	8b f8		 mov	 edi, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0003d	83 f8 ff	 cmp	 eax, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 480  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta = uflow()))

  00040	75 0d		 jne	 SHORT $LN4@underflow

; 481  : 			return (_Meta);	// uflow failed, return EOF

  00042	0b c0		 or	 eax, eax
  00044	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 487  : 		}

  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5b		 pop	 rbx
  0004e	c3		 ret	 0
$LN4@underflow:

; 482  : 		else
; 483  : 			{	// get a char, don't point past it
; 484  : 			pbackfail(_Meta);

  0004f	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  00052	8b d7		 mov	 edx, edi
  00054	48 8b cb	 mov	 rcx, rbx
  00057	ff 50 20	 call	 QWORD PTR [rax+32]

; 485  : 			return (_Meta);

  0005a	8b c7		 mov	 eax, edi
  0005c	48 8b 7c 24 30	 mov	 rdi, QWORD PTR [rsp+48]

; 487  : 		}

  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5b		 pop	 rbx
  00066	c3		 ret	 0
?underflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 48
_Meta$ = 56
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail, COMDAT

; 450  : 		{	// put an element back to stream

$LN81:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0000a	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 450  : 		{	// put an element back to stream

  0000e	48 8b d9	 mov	 rbx, rcx
  00011	8b fa		 mov	 edi, edx

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 38		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0001b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001f	48 39 08	 cmp	 QWORD PTR [rax], rcx
  00022	73 2f		 jae	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00024	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  00027	74 08		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00029	0f b6 41 ff	 movzx	 eax, BYTE PTR [rcx-1]

; 542  : 		return (_Left == _Right);

  0002d	3b c2		 cmp	 eax, edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 453  : 			&& (_Traits::eq_int_type(_Traits::eof(), _Meta)

  0002f	75 22		 jne	 SHORT $LN2@pbackfail
$LN4@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 264  : 		++*_IGcount;

  00031	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00035	ff 00		 inc	 DWORD PTR [rax]

; 265  : 		return (--*_IGnext);

  00037	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003b	48 ff 08	 dec	 QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  0003e	33 c0		 xor	 eax, eax
  00040	83 ff ff	 cmp	 edi, -1
  00043	0f 44 f8	 cmove	 edi, eax
$LN79@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 458  : 			return (_Traits::not_eof(_Meta));

  00046	8b c7		 mov	 eax, edi

; 469  : 			}
; 470  : 		else
; 471  : 			return (_Traits::eof());	// nowhere to put back
; 472  : 	}

  00048	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0004d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00051	5f		 pop	 rdi
  00052	c3		 ret	 0
$LN2@pbackfail:

; 460  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00053	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  0005a	48 85 d2	 test	 rdx, rdx
  0005d	74 73		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0005f	83 ff ff	 cmp	 edi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 460  : 		else if (_Myfile == 0 || _Traits::eq_int_type(_Traits::eof(), _Meta))

  00062	74 6e		 je	 SHORT $LN7@pbackfail

; 462  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00064	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  00069	75 0f		 jne	 SHORT $LN8@pbackfail

; 117  : 	return (ungetc((unsigned char)_Byte, _File) != EOF);

  0006b	40 0f b6 cf	 movzx	 ecx, dil
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ungetc
  00075	83 f8 ff	 cmp	 eax, -1

; 462  : 		else if (_Pcvt == 0 && _Ungetc(_Traits::to_char_type(_Meta), _Myfile))

  00078	75 cc		 jne	 SHORT $LN79@pbackfail
$LN8@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  0007a	4c 8b 43 38	 mov	 r8, QWORD PTR [rbx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 464  : 		else if (_Mysb::gptr() != &_Mychar)

  0007e	48 8d 53 70	 lea	 rdx, QWORD PTR [rbx+112]
  00082	49 39 10	 cmp	 QWORD PTR [r8], rdx
  00085	74 4b		 je	 SHORT $LN7@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00087	4c 8b 4b 18	 mov	 r9, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 466  : 			_Mychar = _Traits::to_char_type(_Meta);

  0008b	40 88 3a	 mov	 BYTE PTR [rdx], dil

; 724  : 		if (_Mysb::eback() != &_Mychar)

  0008e	49 8b 01	 mov	 rax, QWORD PTR [r9]
  00091	48 3b c2	 cmp	 rax, rdx
  00094	74 18		 je	 SHORT $LN66@pbackfail

; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();

  00096	48 89 83 88 00
	00 00		 mov	 QWORD PTR [rbx+136], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0009d	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000a1	48 63 08	 movsxd	 rcx, DWORD PTR [rax]
  000a4	49 03 08	 add	 rcx, QWORD PTR [r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 727  : 			_Set_egptr = _Mysb::egptr();

  000a7	48 89 8b 90 00
	00 00		 mov	 QWORD PTR [rbx+144], rcx
$LN66@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  000ae	49 89 11	 mov	 QWORD PTR [r9], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  000b1	8b cb		 mov	 ecx, ebx
  000b3	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000b7	2b ca		 sub	 ecx, edx
  000b9	83 c1 71	 add	 ecx, 113		; 00000071H
  000bc	48 89 10	 mov	 QWORD PTR [rax], rdx
  000bf	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000c3	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 468  : 			return (_Meta);

  000c5	8b c7		 mov	 eax, edi

; 469  : 			}
; 470  : 		else
; 471  : 			return (_Traits::eof());	// nowhere to put back
; 472  : 	}

  000c7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000cc	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d0	5f		 pop	 rdi
  000d1	c3		 ret	 0
$LN7@pbackfail:

; 461  : 			return (_Traits::eof());	// no open C stream or EOF, fail

  000d2	83 c8 ff	 or	 eax, -1

; 469  : 			}
; 470  : 		else
; 471  : 			return (_Traits::eof());	// nowhere to put back
; 472  : 	}

  000d5	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  000da	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000de	5f		 pop	 rdi
  000df	c3		 ret	 0
?pbackfail@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z
_TEXT	SEGMENT
$T74 = 64
_Dest$75 = 72
_Src$76 = 80
_Ch$77 = 88
_Str$78 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::overflow, COMDAT

; 389  : 		{	// put an element to stream

$LN573:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	57		 push	 rdi
  00005	41 56		 push	 r14
  00007	48 8d 68 a1	 lea	 rbp, QWORD PTR [rax-95]
  0000b	48 81 ec 90 00
	00 00		 sub	 rsp, 144		; 00000090H
  00012	48 c7 45 f7 fe
	ff ff ff	 mov	 QWORD PTR $T74[rbp-73], -2
  0001a	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001e	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00022	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00029	48 33 c4	 xor	 rax, rsp
  0002c	48 89 45 37	 mov	 QWORD PTR __$ArrayPad$[rbp-73], rax
  00030	8b f2		 mov	 esi, edx
  00032	48 8b d9	 mov	 rbx, rcx

; 390  : 		if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00035	83 fa ff	 cmp	 edx, -1
  00038	75 07		 jne	 SHORT $LN7@overflow

; 391  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  0003a	33 c0		 xor	 eax, eax
  0003c	e9 6a 02 00 00	 jmp	 $LN518@overflow
$LN7@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00041	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
  00045	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 393  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00048	48 85 d2	 test	 rdx, rdx
  0004b	74 2e		 je	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0004d	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  00051	4c 63 00	 movsxd	 r8, DWORD PTR [rax]
  00054	4a 8d 0c 02	 lea	 rcx, QWORD PTR [rdx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 393  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00058	48 3b d1	 cmp	 rdx, rcx
  0005b	73 1e		 jae	 SHORT $LN9@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  0005d	41 8d 48 ff	 lea	 ecx, DWORD PTR [r8-1]
  00061	89 08		 mov	 DWORD PTR [rax], ecx

; 308  : 		return ((*_IPnext)++);

  00063	48 8b 53 40	 mov	 rdx, QWORD PTR [rbx+64]
  00067	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  0006a	49 8d 48 01	 lea	 rcx, QWORD PTR [r8+1]
  0006e	48 89 0a	 mov	 QWORD PTR [rdx], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 395  : 			*_Mysb::_Pninc() = _Traits::to_char_type(_Meta);

  00071	41 88 30	 mov	 BYTE PTR [r8], sil

; 396  : 			return (_Meta);

  00074	8b c6		 mov	 eax, esi
  00076	e9 30 02 00 00	 jmp	 $LN518@overflow
$LN9@overflow:

; 397  : 			}
; 398  : 		else if (_Myfile == 0)

  0007b	48 83 bb 80 00
	00 00 00	 cmp	 QWORD PTR [rbx+128], 0
  00083	75 08		 jne	 SHORT $LN11@overflow

; 399  : 			return (_Traits::eof());	// no open C stream, fail

  00085	83 c8 ff	 or	 eax, -1
  00088	e9 1e 02 00 00	 jmp	 $LN518@overflow
$LN11@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0008d	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00091	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  00095	49 39 00	 cmp	 QWORD PTR [r8], rax
  00098	75 20		 jne	 SHORT $LN65@overflow

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0009a	48 8b 93 90 00
	00 00		 mov	 rdx, QWORD PTR [rbx+144]
  000a1	48 8b 8b 88 00
	00 00		 mov	 rcx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  000a8	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  000ab	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  000af	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  000b2	2b d1		 sub	 edx, ecx
  000b4	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  000b8	89 10		 mov	 DWORD PTR [rax], edx
$LN65@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 401  : 		if (_Pcvt == 0)

  000ba	48 83 7b 68 00	 cmp	 QWORD PTR [rbx+104], 0
  000bf	75 1e		 jne	 SHORT $LN12@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000c1	40 0f be ce	 movsx	 ecx, sil
  000c5	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  000cc	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 402  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000d2	83 cb ff	 or	 ebx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  000d5	3b c3		 cmp	 eax, ebx

; 402  : 			return (_Fputc(_Traits::to_char_type(_Meta), _Myfile)

  000d7	0f 45 de	 cmovne	 ebx, esi
  000da	e9 ca 01 00 00	 jmp	 $LN498@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 532  : 		return ((_Elem)_Meta);

  000df	40 88 75 0f	 mov	 BYTE PTR _Ch$77[rbp-73], sil
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000e3	48 c7 45 27 00
	00 00 00	 mov	 QWORD PTR _Str$78[rbp-57], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000eb	48 c7 45 2f 0f
	00 00 00	 mov	 QWORD PTR _Str$78[rbp-49], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000f3	c6 45 17 00	 mov	 BYTE PTR _Str$78[rbp-73], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  000f7	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$78[rbp-73]
  000fb	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00100	90		 npad	 1
$LN571@overflow:
$_Invalid_parameter$574:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 411  : 			string _Str(_STRING_INC, '\0');

  00101	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$78[rbp-49]
  00105	48 8b 4d 17	 mov	 rcx, QWORD PTR _Str$78[rbp-73]
  00109	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00110	4c 8d 45 17	 lea	 r8, QWORD PTR _Str$78[rbp-73]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00114	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00118	4c 0f 43 c1	 cmovae	 r8, rcx

; 1595 : 		value_type * _Result = _Bx._Buf;

  0011c	48 8d 55 17	 lea	 rdx, QWORD PTR _Str$78[rbp-73]

; 1596 : 		if (_Large_string_engaged())

  00120	48 0f 43 d1	 cmovae	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 413  : 				switch (_Pcvt->out(_State,

  00124	48 8b 4d 27	 mov	 rcx, QWORD PTR _Str$78[rbp-57]
  00128	49 03 c8	 add	 rcx, r8
  0012b	48 8d 45 ff	 lea	 rax, QWORD PTR _Dest$75[rbp-73]
  0012f	48 89 44 24 38	 mov	 QWORD PTR [rsp+56], rax
  00134	48 89 4c 24 30	 mov	 QWORD PTR [rsp+48], rcx
  00139	48 89 54 24 28	 mov	 QWORD PTR [rsp+40], rdx
  0013e	48 8d 45 07	 lea	 rax, QWORD PTR _Src$76[rbp-73]
  00142	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00147	4c 8d 4d 10	 lea	 r9, QWORD PTR _Ch$77[rbp-72]
  0014b	4c 8d 45 0f	 lea	 r8, QWORD PTR _Ch$77[rbp-73]
  0014f	48 8d 53 74	 lea	 rdx, QWORD PTR [rbx+116]
  00153	48 8b 4b 68	 mov	 rcx, QWORD PTR [rbx+104]
  00157	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?out@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEBD1AEAPEBDPEAD3AEAPEAD@Z
  0015d	85 c0		 test	 eax, eax
  0015f	0f 88 fa 00 00
	00		 js	 $LN22@overflow
  00165	83 f8 01	 cmp	 eax, 1
  00168	0f 8f c9 00 00
	00		 jg	 $LN564@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0016e	48 8d 45 17	 lea	 rax, QWORD PTR _Str$78[rbp-73]

; 1596 : 		if (_Large_string_engaged())

  00172	48 8b 4d 17	 mov	 rcx, QWORD PTR _Str$78[rbp-73]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00176	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$78[rbp-49]
  0017a	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  0017e	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 420  : 					size_t _Count = _Dest - &*_Str.begin();

  00182	48 8b 7d ff	 mov	 rdi, QWORD PTR _Dest$75[rbp-73]
  00186	48 2b f8	 sub	 rdi, rax

; 421  : 					if (0 < _Count && _Count !=

  00189	74 35		 je	 SHORT $LN15@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  0018b	48 8d 45 17	 lea	 rax, QWORD PTR _Str$78[rbp-73]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0018f	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00193	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 421  : 					if (0 < _Count && _Count !=

  00197	4c 8b 8b 80 00
	00 00		 mov	 r9, QWORD PTR [rbx+128]
  0019e	4c 8b c7	 mov	 r8, rdi
  001a1	ba 01 00 00 00	 mov	 edx, 1
  001a6	48 8b c8	 mov	 rcx, rax
  001a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  001af	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$78[rbp-49]
  001b3	48 8b 4d 17	 mov	 rcx, QWORD PTR _Str$78[rbp-73]
  001b7	48 3b f8	 cmp	 rdi, rax
  001ba	0f 85 a7 00 00
	00		 jne	 $LN19@overflow
$LN15@overflow:
$_Invalid_parameter$575:

; 422  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 423  : 						return (_Traits::eof());	// write failed
; 424  : 
; 425  : 					_Wrotesome = true;	// write succeeded

  001c0	c6 43 71 01	 mov	 BYTE PTR [rbx+113], 1

; 426  : 					if (_Src != &_Ch)

  001c4	48 8d 45 0f	 lea	 rax, QWORD PTR _Ch$77[rbp-73]
  001c8	48 39 45 07	 cmp	 QWORD PTR _Src$76[rbp-73], rax
  001cc	75 65		 jne	 SHORT $LN566@overflow
$_Invalid_parameter$576:

; 428  : 
; 429  : 					if (0 < _Count)

  001ce	48 85 ff	 test	 rdi, rdi
  001d1	0f 85 39 ff ff
	ff		 jne	 $LL2@overflow

; 430  : 						;
; 431  : 					else if (_Str.size() < 4 * _STRING_INC)

  001d7	48 8b 55 27	 mov	 rdx, QWORD PTR _Str$78[rbp-57]
  001db	48 83 fa 20	 cmp	 rdx, 32			; 00000020H
  001df	0f 83 82 00 00
	00		 jae	 $LN19@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  001e5	4c 8b c2	 mov	 r8, rdx

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  001e8	49 8b c1	 mov	 rax, r9
  001eb	48 2b c2	 sub	 rax, rdx
  001ee	48 83 f8 08	 cmp	 rax, 8
  001f2	72 24		 jb	 SHORT $LN347@overflow

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  001f4	48 83 c2 08	 add	 rdx, 8
  001f8	48 89 55 27	 mov	 QWORD PTR _Str$78[rbp-57], rdx

; 1595 : 		value_type * _Result = _Bx._Buf;

  001fc	48 8d 45 17	 lea	 rax, QWORD PTR _Str$78[rbp-73]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00200	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00204	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00208	33 c9		 xor	 ecx, ecx
  0020a	4a 89 0c 00	 mov	 QWORD PTR [rax+r8], rcx

; 517  : 		_Left = _Right;

  0020e	42 88 4c 00 08	 mov	 BYTE PTR [rax+r8+8], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00213	e9 e9 fe ff ff	 jmp	 $LN571@overflow
$LN347@overflow:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00218	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0021d	ba 08 00 00 00	 mov	 edx, 8
  00222	44 8b ca	 mov	 r9d, edx
  00225	48 8d 4d 17	 lea	 rcx, QWORD PTR _Str$78[rbp-73]
  00229	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 444  : 				}

  0022e	e9 ce fe ff ff	 jmp	 $LN571@overflow
$LN566@overflow:

; 427  : 						return (_Meta);	// converted whole element

  00233	8b de		 mov	 ebx, esi
  00235	eb 33		 jmp	 SHORT $LN469@overflow
$LN564@overflow:

; 413  : 				switch (_Pcvt->out(_State,

  00237	83 f8 03	 cmp	 eax, 3
  0023a	75 23		 jne	 SHORT $LN22@overflow

; 93   : 	return (fputc(_Byte, _File) != EOF);

  0023c	0f be 4d 0f	 movsx	 ecx, BYTE PTR _Ch$77[rbp-73]
  00240	48 8b 93 80 00
	00 00		 mov	 rdx, QWORD PTR [rbx+128]
  00247	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 432  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 433  : 					else
; 434  : 						return (_Traits::eof());	// conversion failed
; 435  : 					break;
; 436  : 					}
; 437  : 
; 438  : 				case codecvt_base::noconv:
; 439  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  0024d	83 cb ff	 or	 ebx, -1

; 93   : 	return (fputc(_Byte, _File) != EOF);

  00250	3b c3		 cmp	 eax, ebx

; 432  : 						_Str.append(_STRING_INC, '\0');	// try with more space
; 433  : 					else
; 434  : 						return (_Traits::eof());	// conversion failed
; 435  : 					break;
; 436  : 					}
; 437  : 
; 438  : 				case codecvt_base::noconv:
; 439  : 					return (_Fputc(_Ch, _Myfile) ? _Meta

  00252	0f 45 de	 cmovne	 ebx, esi
  00255	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$78[rbp-49]
  00259	48 8b 4d 17	 mov	 rcx, QWORD PTR _Str$78[rbp-73]
  0025d	eb 0b		 jmp	 SHORT $LN469@overflow
$LN22@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 552  : 		return (EOF);

  0025f	4c 8b 4d 2f	 mov	 r9, QWORD PTR _Str$78[rbp-49]
  00263	48 8b 4d 17	 mov	 rcx, QWORD PTR _Str$78[rbp-73]
$LN19@overflow:
$_Invalid_parameter$577:
  00267	83 cb ff	 or	 ebx, -1
$LN469@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0026a	49 83 f9 10	 cmp	 r9, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0026e	72 39		 jb	 SHORT $LN498@overflow

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00270	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00274	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0027a	72 28		 jb	 SHORT $LN501@overflow

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0027c	f6 45 17 1f	 test	 BYTE PTR _Str$78[rbp-73], 31
  00280	75 1b		 jne	 SHORT $_Invalid_parameter$578

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00282	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00286	48 3b c1	 cmp	 rax, rcx
  00289	73 12		 jae	 SHORT $_Invalid_parameter$578
  0028b	48 2b c8	 sub	 rcx, rax
  0028e	48 83 e9 08	 sub	 rcx, 8
  00292	48 83 f9 1f	 cmp	 rcx, 31
  00296	77 05		 ja	 SHORT $_Invalid_parameter$578

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00298	48 8b c8	 mov	 rcx, rax
  0029b	eb 07		 jmp	 SHORT $LN501@overflow
$_Invalid_parameter$578:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0029d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  002a3	cc		 int	 3
$LN501@overflow:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  002a4	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN498@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 443  : 					return (_Traits::eof());	// conversion failed

  002a9	8b c3		 mov	 eax, ebx
$LN518@overflow:

; 445  : 			}
; 446  : 	}

  002ab	48 8b 4d 37	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-73]
  002af	48 33 cc	 xor	 rcx, rsp
  002b2	e8 00 00 00 00	 call	 __security_check_cookie
  002b7	4c 8d 9c 24 90
	00 00 00	 lea	 r11, QWORD PTR [rsp+144]
  002bf	49 8b 5b 30	 mov	 rbx, QWORD PTR [r11+48]
  002c3	49 8b 73 38	 mov	 rsi, QWORD PTR [r11+56]
  002c7	49 8b e3	 mov	 rsp, r11
  002ca	41 5e		 pop	 r14
  002cc	5f		 pop	 rdi
  002cd	5d		 pop	 rbp
  002ce	c3		 ret	 0
$LN570@overflow:
?overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::overflow
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T74 = 64
_Dest$75 = 72
_Src$76 = 80
_Ch$77 = 88
_Str$78 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$78[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T74 = 64
_Dest$75 = 72
_Src$76 = 80
_Ch$77 = 88
_Str$78 = 96
__$ArrayPad$ = 128
this$ = 176
_Meta$ = 184
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
  00000	48 8d 8a 60 00
	00 00		 lea	 rcx, QWORD PTR _Str$78[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??overflow@?$basic_filebuf@DU?$char_traits@D@std@@@std@@MEAAHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::overflow'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock, COMDAT

; 382  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Unlock

; 383  : 			_CSTD _unlock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__unlock_file
$LN2@Unlock:

; 384  : 		}

  00013	c3		 ret	 0
?_Unlock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Unlock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Lock, COMDAT

; 376  : 		if (_Myfile)

  00000	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00007	48 85 c9	 test	 rcx, rcx
  0000a	74 07		 je	 SHORT $LN2@Lock

; 377  : 			_CSTD _lock_file(_Myfile);

  0000c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp__lock_file
$LN2@Lock:

; 378  : 		}

  00013	c3		 ret	 0
?_Lock@?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Lock
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
_TEXT	SEGMENT
$T2 = 32
this$ = 64
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >, COMDAT

; 161  : 		{	// destroy the object

$LN12:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00019	48 89 01	 mov	 QWORD PTR [rcx], rax

; 162  : 		if (_Myfile != 0)

  0001c	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00024	74 2f		 je	 SHORT $LN6@basic_file
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00026	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  0002a	48 8d 43 70	 lea	 rax, QWORD PTR [rbx+112]
  0002e	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00031	75 22		 jne	 SHORT $LN6@basic_file

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  00033	4c 8b 83 90 00
	00 00		 mov	 r8, QWORD PTR [rbx+144]
  0003a	48 8b 93 88 00
	00 00		 mov	 rdx, QWORD PTR [rbx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00041	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 253  : 		*_IGnext = _Next;

  00044	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00048	48 89 10	 mov	 QWORD PTR [rax], rdx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0004b	44 2b c2	 sub	 r8d, edx
  0004e	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00052	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN6@basic_file:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  00055	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  00059	74 09		 je	 SHORT $LN3@basic_file

; 165  : 			close();

  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00063	90		 npad	 1
$LN3@basic_file:

; 166  : 		}

  00064	48 8b cb	 mov	 rcx, rbx
  00067	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0006b	5b		 pop	 rbx
  0006c	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAA@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::~basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_Nul$69 = 32
_Str$70 = 32
_Str$71 = 64
__$ArrayPad$ = 96
this$ = 128
__$ReturnUdt$ = 136
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 646  : 		{	// return string copy of character array

$LN464:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 60	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00019	44 8b 81 88 00
	00 00		 mov	 r8d, DWORD PTR [rcx+136]

; 646  : 		{	// return string copy of character array

  00020	48 8b da	 mov	 rbx, rdx

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00023	41 f6 c0 02	 test	 r8b, 2
  00027	75 7e		 jne	 SHORT $LN6@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00029	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0002d	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  00030	48 85 d2	 test	 rdx, rdx
  00033	74 72		 je	 SHORT $LN6@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00035	48 8b b9 80 00
	00 00		 mov	 rdi, QWORD PTR [rcx+128]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  0003c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00040	48 3b fa	 cmp	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00043	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0004b	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Str$71[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00050	48 0f 42 fa	 cmovb	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  00054	4c 8b 08	 mov	 r9, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00057	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0005a	c6 44 24 40 00	 mov	 BYTE PTR _Str$71[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0005f	f3 0f 7f 44 24
	50		 movdqu	 XMMWORD PTR _Str$71[rsp+16], xmm0

; 2435 : 		if (_Count <= _My_data._Myres)

  00065	48 83 ff 0f	 cmp	 rdi, 15
  00069	77 25		 ja	 SHORT $LN51@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0006b	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  0006e	48 89 7c 24 50	 mov	 QWORD PTR _Str$71[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00073	49 8b d1	 mov	 rdx, r9
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0007c	c6 44 3c 40 00	 mov	 BYTE PTR _Str$71[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00081	0f 10 44 24 40	 movups	 xmm0, XMMWORD PTR _Str$71[rsp]
  00086	0f 10 4c 24 50	 movups	 xmm1, XMMWORD PTR _Str$71[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  0008b	e9 98 00 00 00	 jmp	 $LN461@str
$LN51@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00090	48 8b d7	 mov	 rdx, rdi
  00093	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00098	0f 10 44 24 40	 movups	 xmm0, XMMWORD PTR _Str$71[rsp]
  0009d	0f 10 4c 24 50	 movups	 xmm1, XMMWORD PTR _Str$71[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  000a2	e9 81 00 00 00	 jmp	 $LN461@str
$LN6@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000a7	41 f6 c0 04	 test	 r8b, 4
  000ab	75 6a		 jne	 SHORT $LN8@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  000ad	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  000b1	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  000b4	48 85 d2	 test	 rdx, rdx
  000b7	74 5e		 je	 SHORT $LN8@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000b9	48 8b 41 30	 mov	 rax, QWORD PTR [rcx+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000bd	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000c5	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000c8	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000cc	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$70[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000d1	48 63 38	 movsxd	 rdi, DWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000d4	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000d7	c6 44 24 20 00	 mov	 BYTE PTR _Str$70[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000dc	48 03 fa	 add	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000df	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$70[rsp+16], xmm0

; 2435 : 		if (_Count <= _My_data._Myres)

  000e5	48 83 ff 0f	 cmp	 rdi, 15
  000e9	77 1d		 ja	 SHORT $LN208@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000eb	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  000ee	48 89 7c 24 30	 mov	 QWORD PTR _Str$70[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000f3	49 8b d1	 mov	 rdx, r9
  000f6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  000fc	c6 44 3c 20 00	 mov	 BYTE PTR _Str$70[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00101	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$70[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 103  : 			return (_Str);

  00106	eb 1b		 jmp	 SHORT $LN462@str
$LN208@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00108	48 8b d7	 mov	 rdx, rdi
  0010b	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00110	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$70[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 103  : 			return (_Str);

  00115	eb 0c		 jmp	 SHORT $LN462@str
$LN8@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00117	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0011e	c6 44 24 20 00	 mov	 BYTE PTR _Nul$69[rsp], 0
$LN462@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00123	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR _Nul$69[rsp]
$LN461@str:
  00128	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 647  : 		return (_Stringbuffer.str());

  0012b	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0012e	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 648  : 		}

  00132	48 8b 4c 24 60	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00137	48 33 cc	 xor	 rcx, rsp
  0013a	e8 00 00 00 00	 call	 __security_check_cookie
  0013f	48 8b 9c 24 90
	00 00 00	 mov	 rbx, QWORD PTR [rsp+144]
  00147	48 83 c4 70	 add	 rsp, 112		; 00000070H
  0014b	5f		 pop	 rdi
  0014c	c3		 ret	 0
?str@?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 637  : 		{	// destroy the object

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  0000d	48 8b d9	 mov	 rbx, rcx
  00010	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  00014	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  0001b	48 89 84 0a 68
	ff ff ff	 mov	 QWORD PTR [rdx+rcx-152], rax
  00023	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  0002a	48 63 50 04	 movsxd	 rdx, DWORD PTR [rax+4]
  0002e	44 8d 82 68 ff
	ff ff		 lea	 r8d, DWORD PTR [rdx-152]
  00035	44 89 84 0a 64
	ff ff ff	 mov	 DWORD PTR [rdx+rcx-156], r8d

; 638  : 		}

  0003d	48 83 c1 80	 add	 rcx, -128		; ffffffffffffff80H
  00041	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00046	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  0004a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004e	5b		 pop	 rbx
  0004f	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
??1?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::~basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 593  : 		{	// construct empty character buffer

$LN55:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	57		 push	 rdi
  0000b	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000f	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T6[rsp], -2
  00018	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  0001d	48 8b f9	 mov	 rdi, rcx
  00020	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR $T1[rsp], 0
  00028	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_istream@DU?$char_traits@D@std@@@1@@
  0002f	48 89 01	 mov	 QWORD PTR [rcx], rax
  00032	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_8?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@7B?$basic_ostream@DU?$char_traits@D@std@@@1@@
  00039	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  0003d	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00044	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_ios@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0004a	90		 npad	 1
  0004b	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}
; 335  : 
; 336  : 	void _Tidy()
; 337  : 		{	// discard any allocated buffer and clear pointers
; 338  : 		if (_Mystate & _Allocated)
; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),
; 340  : 				(_Mysb::pptr() != 0 ? _Mysb::epptr()
; 341  : 					: _Mysb::egptr()) - _Mysb::eback());
; 342  : 		_Mysb::setg(0, 0, 0);
; 343  : 		_Mysb::setp(0, 0);
; 344  : 		_Seekhigh = 0;
; 345  : 		_Mystate &= ~_Allocated;
; 346  : 		}
; 347  : 
; 348  : private:
; 349  : 	typedef typename allocator_traits<allocator_type>::pointer _Ptrty;
; 350  : 
; 351  : 	enum
; 352  : 		{	// constant for minimum buffer size
; 353  : 		_MINSIZE = 32};
; 354  : 
; 355  : 	_Strstate _Getstate(ios_base::openmode _Mode)
; 356  : 		{	// convert open mode to stream state bits
; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);
; 367  : 		}
; 368  : 
; 369  : 	_Elem *_Seekhigh;	// the high-water pointer in character array
; 370  : 	_Strstate _Mystate;	// the stream state
; 371  : 	allocator_type _Al;	// the allocator object
; 372  : 	};
; 373  : 
; 374  : 	// basic_stringbuf TEMPLATE OPERATORS
; 375  : template<class _Elem,
; 376  : 	class _Traits,
; 377  : 	class _Alloc> inline
; 378  : 	void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left,
; 379  : 		basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
; 380  : 	{	// swap _Left and _Right basic_stringbufs
; 381  : 	_Left.swap(_Right);
; 382  : 	}
; 383  : 
; 384  : 		// TEMPLATE CLASS basic_istringstream
; 385  : template<class _Elem,
; 386  : 	class _Traits,
; 387  : 	class _Alloc>
; 388  : 	class basic_istringstream
; 389  : 		: public basic_istream<_Elem, _Traits>
; 390  : 	{	// input stream associated with a character array
; 391  : public:
; 392  : 	typedef basic_istringstream<_Elem, _Traits, _Alloc> _Myt;
; 393  : 	typedef basic_istream<_Elem, _Traits> _Mybase;
; 394  : 	typedef _Alloc allocator_type;
; 395  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 396  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 397  : 
; 398  : 	explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
; 399  : 		: _Mybase(&_Stringbuffer),
; 400  : 			_Stringbuffer(_Mode | ios_base::in)
; 401  : 		{	// construct empty readable character buffer
; 402  : 		}
; 403  : 
; 404  : 	explicit basic_istringstream(const _Mystr& _Str,
; 405  : 		ios_base::openmode _Mode = ios_base::in)
; 406  : 		: _Mybase(&_Stringbuffer),
; 407  : 			_Stringbuffer(_Str, _Mode | ios_base::in)
; 408  : 		{	// construct readable character buffer from NTCS
; 409  : 		}
; 410  : 
; 411  : 	basic_istringstream(_Myt&& _Right)
; 412  : 		: _Mybase(&_Stringbuffer)
; 413  : 		{	// construct by moving _Right
; 414  : 		_Assign_rv(_STD move(_Right));
; 415  : 		}
; 416  : 
; 417  : 	_Myt& operator=(_Myt&& _Right)
; 418  : 		{	// move from _Right
; 419  : 		_Assign_rv(_STD move(_Right));
; 420  : 		return (*this);
; 421  : 		}
; 422  : 
; 423  : 	void _Assign_rv(_Myt&& _Right)
; 424  : 		{	// assign by moving _Right
; 425  : 		if (this != _STD addressof(_Right))
; 426  : 			{	// different, worth moving
; 427  : 			_Stringbuffer.str(_Mystr());
; 428  : 			this->swap(_Right);
; 429  : 			}
; 430  : 		}
; 431  : 
; 432  : 	void swap(_Myt& _Right)
; 433  : 		{	// swap with _Right
; 434  : 		if (this != _STD addressof(_Right))
; 435  : 			{	// different, swap base and buffer
; 436  : 			_Mybase::swap(_Right);
; 437  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 438  : 			}
; 439  : 		}
; 440  : 
; 441  : 	basic_istringstream(const _Myt&) = delete;
; 442  : 	_Myt& operator=(const _Myt&) = delete;
; 443  : 
; 444  : 	virtual ~basic_istringstream() _NOEXCEPT
; 445  : 		{	// destroy the object
; 446  : 		}
; 447  : 
; 448  : 	_Mysb *rdbuf() const
; 449  : 		{	// return pointer to file buffer
; 450  : 		return ((_Mysb *)&_Stringbuffer);
; 451  : 		}
; 452  : 
; 453  : 	_Mystr str() const
; 454  : 		{	// return string copy of character array
; 455  : 		return (_Stringbuffer.str());
; 456  : 		}
; 457  : 
; 458  : 	void str(const _Mystr& _Newstr)
; 459  : 		{	// replace character array from string
; 460  : 		_Stringbuffer.str(_Newstr);
; 461  : 		}
; 462  : 
; 463  : private:
; 464  : 	_Mysb _Stringbuffer;	// the string buffer
; 465  : 	};
; 466  : 
; 467  : 	// basic_istringstream TEMPLATE OPERATORS
; 468  : template<class _Elem,
; 469  : 	class _Traits,
; 470  : 	class _Alloc> inline
; 471  : 	void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left,
; 472  : 		basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
; 473  : 	{	// swap _Left and _Right basic_istringstreams
; 474  : 	_Left.swap(_Right);
; 475  : 	}
; 476  : 
; 477  : 		// TEMPLATE CLASS basic_ostringstream
; 478  : template<class _Elem,
; 479  : 	class _Traits,
; 480  : 	class _Alloc>
; 481  : 	class basic_ostringstream
; 482  : 		: public basic_ostream<_Elem, _Traits>
; 483  : 	{	// output stream associated with a character array
; 484  : public:
; 485  : 	typedef basic_ostringstream<_Elem, _Traits, _Alloc> _Myt;
; 486  : 	typedef basic_ostream<_Elem, _Traits> _Mybase;
; 487  : 	typedef _Alloc allocator_type;
; 488  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 489  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 490  : 
; 491  : 	explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
; 492  : 		: _Mybase(&_Stringbuffer),
; 493  : 			_Stringbuffer(_Mode | ios_base::out)
; 494  : 		{	// construct empty writable character buffer
; 495  : 		}
; 496  : 
; 497  : 	explicit basic_ostringstream(const _Mystr& _Str,
; 498  : 		ios_base::openmode _Mode = ios_base::out)
; 499  : 		: _Mybase(&_Stringbuffer),
; 500  : 			_Stringbuffer(_Str, _Mode | ios_base::out)
; 501  : 		{	// construct writable character buffer from NTCS
; 502  : 		}
; 503  : 
; 504  : 	basic_ostringstream(_Myt&& _Right)
; 505  : 		: _Mybase(&_Stringbuffer)
; 506  : 		{	// construct by moving _Right
; 507  : 		_Assign_rv(_STD move(_Right));
; 508  : 		}
; 509  : 
; 510  : 	_Myt& operator=(_Myt&& _Right)
; 511  : 		{	// move from _Right
; 512  : 		_Assign_rv(_STD move(_Right));
; 513  : 		return (*this);
; 514  : 		}
; 515  : 
; 516  : 	void _Assign_rv(_Myt&& _Right)
; 517  : 		{	// assign by moving _Right
; 518  : 		if (this != _STD addressof(_Right))
; 519  : 			{	// different, worth moving
; 520  : 			_Stringbuffer.str(_Mystr());
; 521  : 			this->swap(_Right);
; 522  : 			}
; 523  : 		}
; 524  : 
; 525  : 	void swap(_Myt& _Right)
; 526  : 		{	// swap with _Right
; 527  : 		if (this != _STD addressof(_Right))
; 528  : 			{	// different, swap base and buffer
; 529  : 			_Mybase::swap(_Right);
; 530  : 			_Stringbuffer.swap(_Right._Stringbuffer);
; 531  : 			}
; 532  : 		}
; 533  : 
; 534  : 	basic_ostringstream(const _Myt&) = delete;
; 535  : 	_Myt& operator=(const _Myt&) = delete;
; 536  : 
; 537  : 	virtual ~basic_ostringstream() _NOEXCEPT
; 538  : 		{	// destroy the object
; 539  : 		}
; 540  : 
; 541  : 	_Mysb *rdbuf() const
; 542  : 		{	// return pointer to buffer
; 543  : 		return ((_Mysb *)&_Stringbuffer);
; 544  : 		}
; 545  : 
; 546  : 	_Mystr str() const
; 547  : 		{	// return string copy of character array
; 548  : 		return (_Stringbuffer.str());
; 549  : 		}
; 550  : 
; 551  : 	void str(const _Mystr& _Newstr)
; 552  : 		{	// replace character array from string
; 553  : 		_Stringbuffer.str(_Newstr);
; 554  : 		}
; 555  : 
; 556  : private:
; 557  : 	_Mysb _Stringbuffer;	// the string buffer
; 558  : 	};
; 559  : 
; 560  : 	// basic_ostringstream TEMPLATE OPERATORS
; 561  : template<class _Elem,
; 562  : 	class _Traits,
; 563  : 	class _Alloc> inline
; 564  : 	void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left,
; 565  : 		basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
; 566  : 	{	// swap _Left and _Right basic_ostringstreams
; 567  : 	_Left.swap(_Right);
; 568  : 	}
; 569  : 
; 570  : 		// TEMPLATE CLASS basic_stringstream
; 571  : template<class _Elem,
; 572  : 	class _Traits,
; 573  : 	class _Alloc>
; 574  : 	class basic_stringstream
; 575  : 		: public basic_iostream<_Elem, _Traits>
; 576  : 	{	// input/output stream associated with a character array
; 577  : public:
; 578  : 	typedef basic_stringstream<_Elem, _Traits, _Alloc> _Myt;
; 579  : 	typedef basic_iostream<_Elem, _Traits> _Mybase;
; 580  : 	typedef _Elem char_type;
; 581  : 	typedef _Traits traits_type;
; 582  : 	typedef _Alloc allocator_type;
; 583  : 	typedef typename _Traits::int_type int_type;
; 584  : 	typedef typename _Traits::pos_type pos_type;
; 585  : 	typedef typename _Traits::off_type off_type;
; 586  : 	typedef basic_stringbuf<_Elem, _Traits, _Alloc> _Mysb;
; 587  : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 588  : 
; 589  : 	explicit basic_stringstream(ios_base::openmode _Mode =
; 590  : 		ios_base::in | ios_base::out)
; 591  : 		: _Mybase(&_Stringbuffer),

  00053	48 8d 5f 18	 lea	 rbx, QWORD PTR [rdi+24]
  00057	45 33 c0	 xor	 r8d, r8d
  0005a	48 8b d3	 mov	 rdx, rbx
  0005d	48 8b cf	 mov	 rcx, rdi
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_iostream@DU?$char_traits@D@std@@@std@@QEAA@PEAV?$basic_streambuf@DU?$char_traits@D@std@@@1@@Z
  00066	90		 npad	 1

; 593  : 		{	// construct empty character buffer

  00067	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0006a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0006e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00075	48 89 04 39	 mov	 QWORD PTR [rcx+rdi], rax
  00079	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  0007c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00080	8d 91 68 ff ff
	ff		 lea	 edx, DWORD PTR [rcx-152]
  00086	89 54 39 fc	 mov	 DWORD PTR [rcx+rdi-4], edx

; 592  : 			_Stringbuffer(_Mode)

  0008a	48 89 5c 24 58	 mov	 QWORD PTR this$[rsp], rbx

; 30   : 		{	// construct empty character buffer from mode

  0008f	48 8b cb	 mov	 rcx, rbx
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00098	90		 npad	 1
  00099	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  000a0	48 89 03	 mov	 QWORD PTR [rbx], rax

; 311  : 		_Seekhigh = 0;

  000a3	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 312  : 		_Mystate = _State;

  000ab	c7 43 70 00 00
	00 00		 mov	 DWORD PTR [rbx+112], 0

; 594  : 		}

  000b2	48 8b c7	 mov	 rax, rdi
  000b5	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  000ba	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
??0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 50	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 50 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
  00040	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 50	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 15		 je	 SHORT $LN5@dtor$0
  00013	83 65 50 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 40	 mov	 rcx, QWORD PTR this$[rbp]
  0001b	48 81 c1 98 00
	00 00		 add	 rcx, 152		; 00000098H
  00022	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
$LN5@dtor$0:
  00028	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002c	5d		 pop	 rbp
  0002d	c3		 ret	 0
?dtor$0@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  0002e	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00035	48 83 c1 20	 add	 rcx, 32			; 00000020H
  00039	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$1@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T6 = 32
this$ = 64
_Mode$dead$ = 72
$initVBases$dead$ = 80
$T1 = 80
this$ = 88
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
  00040	48 8b 8a 58 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00047	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$3@?0???0?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$3
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z
_TEXT	SEGMENT
this$ = 16
__$ReturnUdt$ = 24
_Ptr$ = 32
_Mode$ = 40
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos, COMDAT

; 276  : 		{	// change position to _Pos, according to _Mode

$LN58:
  00000	40 53		 push	 rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 66   : 		return (_Myoff + _Fpos);

  00002	4d 8b 50 08	 mov	 r10, QWORD PTR [r8+8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  00006	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 66   : 		return (_Myoff + _Fpos);

  00009	4d 03 10	 add	 r10, QWORD PTR [r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 276  : 		{	// change position to _Pos, according to _Mode

  0000c	4c 8b d9	 mov	 r11, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0000f	4c 8b 41 40	 mov	 r8, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 278  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00013	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00016	48 85 c0	 test	 rax, rax
  00019	74 0a		 je	 SHORT $LN2@seekpos
  0001b	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  0001f	73 04		 jae	 SHORT $LN2@seekpos

; 279  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  00021	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN2@seekpos:

; 280  : 
; 281  : 		if (_Off == _BADOFF)

  00025	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  0002c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  0002f	4c 3b d1	 cmp	 r10, rcx
  00032	0f 84 bc 00 00
	00		 je	 $LN11@seekpos

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  00038	48 89 7c 24 10	 mov	 QWORD PTR [rsp+16], rdi
  0003d	41 f6 c1 01	 test	 r9b, 1
  00041	74 6e		 je	 SHORT $LN5@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00043	49 8b 7b 38	 mov	 rdi, QWORD PTR [r11+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 283  : 		else if (_Mode & ios_base::in && _Mysb::gptr() != 0)

  00047	48 83 3f 00	 cmp	 QWORD PTR [rdi], 0
  0004b	74 64		 je	 SHORT $LN5@seekpos

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0004d	4d 85 d2	 test	 r10, r10
  00050	0f 88 96 00 00
	00		 js	 $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00056	49 8b 53 18	 mov	 rdx, QWORD PTR [r11+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 285  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0005a	49 8b 43 68	 mov	 rax, QWORD PTR [r11+104]
  0005e	48 2b 02	 sub	 rax, QWORD PTR [rdx]
  00061	4c 3b d0	 cmp	 r10, rax
  00064	0f 8f 82 00 00
	00		 jg	 $LN10@seekpos

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  0006a	8b 12		 mov	 edx, DWORD PTR [rdx]
  0006c	2b 17		 sub	 edx, DWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  0006e	49 8b 43 50	 mov	 rax, QWORD PTR [r11+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 287  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  00072	41 03 d2	 add	 edx, r10d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00075	29 10		 sub	 DWORD PTR [rax], edx

; 247  : 		*_IGnext += _Off;

  00077	49 8b 4b 38	 mov	 rcx, QWORD PTR [r11+56]
  0007b	48 63 c2	 movsxd	 rax, edx
  0007e	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  00081	41 f6 c1 02	 test	 r9b, 2
  00085	74 68		 je	 SHORT $LN55@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00087	4d 8b 43 40	 mov	 r8, QWORD PTR [r11+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 288  : 				if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  0008b	49 8b 08	 mov	 rcx, QWORD PTR [r8]
  0008e	48 85 c9	 test	 rcx, rcx
  00091	74 5c		 je	 SHORT $LN55@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00093	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  00097	48 63 10	 movsxd	 rdx, DWORD PTR [rax]

; 226  : 		return (*_IGnext);

  0009a	49 8b 43 38	 mov	 rax, QWORD PTR [r11+56]

; 259  : 		return (*_IPnext + *_IPcount);

  0009e	48 03 d1	 add	 rdx, rcx

; 226  : 		return (*_IGnext);

  000a1	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  000a4	49 89 08	 mov	 QWORD PTR [r8], rcx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000a7	2b d1		 sub	 edx, ecx
  000a9	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
  000ad	89 10		 mov	 DWORD PTR [rax], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 293  : 				_Off = _BADOFF;

  000af	eb 3e		 jmp	 SHORT $LN55@seekpos
$LN5@seekpos:

; 294  : 			}
; 295  : 		else if (_Mode & ios_base::out && _Mysb::pptr() != 0)

  000b1	41 f6 c1 02	 test	 r9b, 2
  000b5	74 35		 je	 SHORT $LN10@seekpos
  000b7	49 83 38 00	 cmp	 QWORD PTR [r8], 0
  000bb	74 2f		 je	 SHORT $LN10@seekpos

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000bd	4d 85 d2	 test	 r10, r10
  000c0	78 2a		 js	 SHORT $LN10@seekpos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000c2	49 8b 53 18	 mov	 rdx, QWORD PTR [r11+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 297  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  000c6	49 8b 43 68	 mov	 rax, QWORD PTR [r11+104]
  000ca	48 2b 02	 sub	 rax, QWORD PTR [rdx]
  000cd	4c 3b d0	 cmp	 r10, rax
  000d0	7f 1a		 jg	 SHORT $LN10@seekpos

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000d2	8b 12		 mov	 edx, DWORD PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000d4	49 8b 43 58	 mov	 rax, QWORD PTR [r11+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 298  : 				_Mysb::pbump((int)(_Mysb::eback()

  000d8	41 2b 10	 sub	 edx, DWORD PTR [r8]
  000db	41 03 d2	 add	 edx, r10d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  000de	29 10		 sub	 DWORD PTR [rax], edx

; 288  : 		*_IPnext += _Off;

  000e0	49 8b 4b 40	 mov	 rcx, QWORD PTR [r11+64]
  000e4	48 63 c2	 movsxd	 rax, edx
  000e7	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 300  : 			else

  000ea	eb 03		 jmp	 SHORT $LN55@seekpos
$LN10@seekpos:

; 301  : 				_Off = _BADOFF;
; 302  : 			}
; 303  : 		else
; 304  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  000ec	4c 8b d1	 mov	 r10, rcx
$LN55@seekpos:
  000ef	48 8b 7c 24 10	 mov	 rdi, QWORD PTR [rsp+16]
$LN11@seekpos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  000f4	33 c0		 xor	 eax, eax
  000f6	4c 89 13	 mov	 QWORD PTR [rbx], r10
  000f9	48 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [rbx+8], 0
  00101	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 305  : 		return (streampos(_Off));

  00105	48 8b c3	 mov	 rax, rbx

; 306  : 		}

  00108	5b		 pop	 rbx
  00109	c3		 ret	 0
?seekpos@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@V32@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z
_TEXT	SEGMENT
this$ = 16
__$ReturnUdt$ = 24
_Off$ = 32
_Way$ = 40
_Which$ = 48
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff, COMDAT

; 227  : 		{	// change position by _Off, according to _Way, _Mode

$LN76:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00006	48 8b 79 40	 mov	 rdi, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 227  : 		{	// change position by _Off, according to _Way, _Mode

  0000a	4c 8b da	 mov	 r11, rdx
  0000d	4c 8b d1	 mov	 r10, rcx

; 228  : 		if (_Mysb::pptr() != 0 && _Seekhigh < _Mysb::pptr())

  00010	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00013	48 85 c0	 test	 rax, rax
  00016	74 0a		 je	 SHORT $LN2@seekoff
  00018	48 39 41 68	 cmp	 QWORD PTR [rcx+104], rax
  0001c	73 04		 jae	 SHORT $LN2@seekoff

; 229  : 			_Seekhigh = _Mysb::pptr();	// update high-water pointer

  0001e	48 89 41 68	 mov	 QWORD PTR [rcx+104], rax
$LN2@seekoff:

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  00022	8b 5c 24 30	 mov	 ebx, DWORD PTR _Which$[rsp]
  00026	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0002b	f6 c3 01	 test	 bl, 1
  0002e	0f 84 ba 00 00
	00		 je	 $LN3@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00034	48 8b 71 38	 mov	 rsi, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 231  : 		if (_Which & ios_base::in && _Mysb::gptr() != 0)

  00038	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
  0003b	48 85 c9	 test	 rcx, rcx
  0003e	0f 84 aa 00 00
	00		 je	 $LN3@seekoff

; 232  : 			{	// position within read buffer
; 233  : 			if (_Way == ios_base::end)

  00044	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_?_BADOFF@std@@3_JB
  0004b	41 83 f9 02	 cmp	 r9d, 2
  0004f	75 10		 jne	 SHORT $LN5@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00051	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 234  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  00055	49 8b 4a 68	 mov	 rcx, QWORD PTR [r10+104]
  00059	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  0005c	4c 03 c1	 add	 r8, rcx

; 235  : 			else if (_Way == ios_base::cur

  0005f	eb 1f		 jmp	 SHORT $LN9@seekoff
$LN5@seekoff:

; 236  : 				&& (_Which & ios_base::out) == 0)

  00061	41 83 f9 01	 cmp	 r9d, 1
  00065	75 11		 jne	 SHORT $LN7@seekoff
  00067	f6 c3 02	 test	 bl, 2
  0006a	75 11		 jne	 SHORT $LN74@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0006c	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 237  : 				_Off += (off_type)(_Mysb::gptr() - _Mysb::eback());

  00070	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00073	4c 03 c1	 add	 r8, rcx
  00076	eb 08		 jmp	 SHORT $LN9@seekoff
$LN7@seekoff:

; 238  : 			else if (_Way != ios_base::beg)

  00078	45 85 c9	 test	 r9d, r9d
  0007b	74 03		 je	 SHORT $LN9@seekoff
$LN74@seekoff:

; 239  : 				_Off = _BADOFF;

  0007d	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
$LN9@seekoff:

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00080	4d 85 c0	 test	 r8, r8
  00083	0f 88 d7 00 00
	00		 js	 $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00089	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 241  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0008d	49 8b 42 68	 mov	 rax, QWORD PTR [r10+104]
  00091	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00094	4c 3b c0	 cmp	 r8, rax
  00097	0f 8f c3 00 00
	00		 jg	 $LN20@seekoff

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  0009d	8b 11		 mov	 edx, DWORD PTR [rcx]
  0009f	2b 16		 sub	 edx, DWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000a1	49 8b 42 50	 mov	 rax, QWORD PTR [r10+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 243  : 				_Mysb::gbump((int)(_Mysb::eback() - _Mysb::gptr() + _Off));

  000a5	41 03 d0	 add	 edx, r8d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  000a8	29 10		 sub	 DWORD PTR [rax], edx

; 247  : 		*_IGnext += _Off;

  000aa	49 8b 4a 38	 mov	 rcx, QWORD PTR [r10+56]
  000ae	48 63 c2	 movsxd	 rax, edx
  000b1	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000b4	f6 c3 02	 test	 bl, 2
  000b7	0f 84 b7 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  000bd	4d 8b 4a 40	 mov	 r9, QWORD PTR [r10+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 244  : 				if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000c1	49 8b 09	 mov	 rcx, QWORD PTR [r9]
  000c4	48 85 c9	 test	 rcx, rcx
  000c7	0f 84 a7 00 00
	00		 je	 $LN22@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  000cd	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
  000d1	48 63 10	 movsxd	 rdx, DWORD PTR [rax]

; 226  : 		return (*_IGnext);

  000d4	49 8b 42 38	 mov	 rax, QWORD PTR [r10+56]

; 259  : 		return (*_IPnext + *_IPcount);

  000d8	48 03 d1	 add	 rdx, rcx

; 226  : 		return (*_IGnext);

  000db	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  000de	49 89 09	 mov	 QWORD PTR [r9], rcx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  000e1	2b d1		 sub	 edx, ecx
  000e3	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
  000e7	89 10		 mov	 DWORD PTR [rax], edx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 248  : 			else

  000e9	e9 86 00 00 00	 jmp	 $LN22@seekoff
$LN3@seekoff:

; 249  : 				_Off = _BADOFF;
; 250  : 			}
; 251  : 		else if (_Which & ios_base::out && _Mysb::pptr() != 0)

  000ee	f6 c3 02	 test	 bl, 2
  000f1	74 72		 je	 SHORT $LN13@seekoff
  000f3	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
  000f6	48 85 c9	 test	 rcx, rcx
  000f9	74 6a		 je	 SHORT $LN13@seekoff

; 252  : 			{	// position within write buffer
; 253  : 			if (_Way == ios_base::end)

  000fb	48 8b 15 00 00
	00 00		 mov	 rdx, QWORD PTR __imp_?_BADOFF@std@@3_JB
  00102	41 83 f9 02	 cmp	 r9d, 2
  00106	75 10		 jne	 SHORT $LN15@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00108	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 254  : 				_Off += (off_type)(_Seekhigh - _Mysb::eback());

  0010c	49 8b 4a 68	 mov	 rcx, QWORD PTR [r10+104]
  00110	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00113	4c 03 c1	 add	 r8, rcx
  00116	eb 1a		 jmp	 SHORT $LN19@seekoff
$LN15@seekoff:

; 255  : 			else if (_Way == ios_base::cur)

  00118	41 83 f9 01	 cmp	 r9d, 1
  0011c	75 0c		 jne	 SHORT $LN17@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0011e	49 8b 42 18	 mov	 rax, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 256  : 				_Off += (off_type)(_Mysb::pptr() - _Mysb::eback());

  00122	48 2b 08	 sub	 rcx, QWORD PTR [rax]
  00125	4c 03 c1	 add	 r8, rcx
  00128	eb 08		 jmp	 SHORT $LN19@seekoff
$LN17@seekoff:

; 257  : 			else if (_Way != ios_base::beg)

  0012a	45 85 c9	 test	 r9d, r9d
  0012d	74 03		 je	 SHORT $LN19@seekoff

; 258  : 				_Off = _BADOFF;

  0012f	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
$LN19@seekoff:

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  00132	4d 85 c0	 test	 r8, r8
  00135	78 29		 js	 SHORT $LN20@seekoff
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00137	49 8b 4a 18	 mov	 rcx, QWORD PTR [r10+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 260  : 			if (0 <= _Off && _Off <= _Seekhigh - _Mysb::eback())

  0013b	49 8b 42 68	 mov	 rax, QWORD PTR [r10+104]
  0013f	48 2b 01	 sub	 rax, QWORD PTR [rcx]
  00142	4c 3b c0	 cmp	 r8, rax
  00145	7f 19		 jg	 SHORT $LN20@seekoff

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  00147	8b 11		 mov	 edx, DWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  00149	49 8b 42 58	 mov	 rax, QWORD PTR [r10+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 261  : 				_Mysb::pbump((int)(_Mysb::eback()

  0014d	2b 17		 sub	 edx, DWORD PTR [rdi]
  0014f	41 03 d0	 add	 edx, r8d
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 287  : 		*_IPcount -= _Off;

  00152	29 10		 sub	 DWORD PTR [rax], edx

; 288  : 		*_IPnext += _Off;

  00154	49 8b 4a 40	 mov	 rcx, QWORD PTR [r10+64]
  00158	48 63 c2	 movsxd	 rax, edx
  0015b	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 263  : 			else

  0015e	eb 14		 jmp	 SHORT $LN22@seekoff
$LN20@seekoff:

; 264  : 				_Off = _BADOFF;

  00160	4c 8b 02	 mov	 r8, QWORD PTR [rdx]
  00163	eb 0f		 jmp	 SHORT $LN22@seekoff
$LN13@seekoff:

; 265  : 			}
; 266  : 
; 267  : 		else if (_Off != 0)

  00165	4d 85 c0	 test	 r8, r8
  00168	74 0a		 je	 SHORT $LN22@seekoff

; 268  : 
; 269  : 
; 270  : 			_Off = _BADOFF;	// neither read nor write buffer selected, fail

  0016a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __imp_?_BADOFF@std@@3_JB
  00171	4c 8b 00	 mov	 r8, QWORD PTR [rax]
$LN22@seekoff:

; 271  : 		return (pos_type(_Off));

  00174	48 8b 74 24 10	 mov	 rsi, QWORD PTR [rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00179	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 272  : 		}

  0017b	48 8b 5c 24 18	 mov	 rbx, QWORD PTR [rsp+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00180	4d 89 03	 mov	 QWORD PTR [r11], r8
  00183	49 c7 43 08 00
	00 00 00	 mov	 QWORD PTR [r11+8], 0
  0018b	49 89 43 10	 mov	 QWORD PTR [r11+16], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 271  : 		return (pos_type(_Off));

  0018f	49 8b c3	 mov	 rax, r11

; 272  : 		}

  00192	5f		 pop	 rdi
  00193	c3		 ret	 0
?seekoff@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAA?AV?$fpos@U_Mbstatet@@@2@_JHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::seekoff
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ
_TEXT	SEGMENT
this$ = 8
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00000	4c 8b 49 38	 mov	 r9, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 208  : 		if (_Mysb::gptr() == 0)

  00004	49 8b 11	 mov	 rdx, QWORD PTR [r9]
  00007	48 85 d2	 test	 rdx, rdx
  0000a	74 4f		 je	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0000c	4c 8b 51 50	 mov	 r10, QWORD PTR [rcx+80]
  00010	49 63 02	 movsxd	 rax, DWORD PTR [r10]
  00013	48 03 c2	 add	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 210  : 		else if (_Mysb::gptr() < _Mysb::egptr())

  00016	48 3b d0	 cmp	 rdx, rax
  00019	73 04		 jae	 SHORT $LN4@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  0001b	0f b6 02	 movzx	 eax, BYTE PTR [rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 222  : 		}

  0001e	c3		 ret	 0
$LN4@underflow:

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  0001f	f6 41 70 04	 test	 BYTE PTR [rcx+112], 4
  00023	75 36		 jne	 SHORT $LN8@underflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00025	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 213  : 			|| (_Mysb::pptr() <= _Mysb::gptr() && _Seekhigh <= _Mysb::gptr()))

  00029	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  0002c	4d 85 c0	 test	 r8, r8
  0002f	74 2a		 je	 SHORT $LN8@underflow
  00031	4c 3b c2	 cmp	 r8, rdx
  00034	77 06		 ja	 SHORT $LN6@underflow
  00036	48 39 51 68	 cmp	 QWORD PTR [rcx+104], rdx
  0003a	76 1f		 jbe	 SHORT $LN8@underflow
$LN6@underflow:

; 215  : 		else
; 216  : 			{	// extend read buffer into written area, then return buffered
; 217  : 			if (_Seekhigh < _Mysb::pptr())

  0003c	4c 39 41 68	 cmp	 QWORD PTR [rcx+104], r8
  00040	73 04		 jae	 SHORT $LN9@underflow

; 218  : 				_Seekhigh = _Mysb::pptr();

  00042	4c 89 41 68	 mov	 QWORD PTR [rcx+104], r8
$LN9@underflow:

; 219  : 			_Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Seekhigh);

  00046	48 8b 41 68	 mov	 rax, QWORD PTR [rcx+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0004a	41 2b 01	 sub	 eax, DWORD PTR [r9]
  0004d	41 89 02	 mov	 DWORD PTR [r10], eax

; 226  : 		return (*_IGnext);

  00050	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00054	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 537  : 		return ((unsigned char)_Ch);

  00057	0f b6 01	 movzx	 eax, BYTE PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 222  : 		}

  0005a	c3		 ret	 0
$LN8@underflow:

; 214  : 			return (_Traits::eof());	// can't read, fail

  0005b	83 c8 ff	 or	 eax, -1

; 222  : 		}

  0005e	c3		 ret	 0
?underflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::underflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 8
_Meta$ = 16
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00000	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00004	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  00007	4d 85 c0	 test	 r8, r8
  0000a	74 40		 je	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0000c	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00010	4c 3b 00	 cmp	 r8, QWORD PTR [rax]
  00013	76 37		 jbe	 SHORT $LN4@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00015	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  00018	74 0c		 je	 SHORT $LN2@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 522  : 		return (_Left == _Right);

  0001a	41 3a 50 ff	 cmp	 dl, BYTE PTR [r8-1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 193  : 			|| (!_Traits::eq_int_type(_Traits::eof(), _Meta)

  0001e	74 06		 je	 SHORT $LN2@pbackfail
  00020	f6 41 70 02	 test	 BYTE PTR [rcx+112], 2
  00024	75 26		 jne	 SHORT $LN4@pbackfail
$LN2@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 246  : 		*_IGcount -= _Off;

  00026	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002a	ff 00		 inc	 DWORD PTR [rax]

; 247  : 		*_IGnext += _Off;

  0002c	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00030	48 ff 08	 dec	 QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  00033	83 fa ff	 cmp	 edx, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 200  : 			if (!_Traits::eq_int_type(_Traits::eof(), _Meta))

  00036	74 09		 je	 SHORT $LN5@pbackfail
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00038	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  0003c	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 201  : 				*_Mysb::gptr() = _Traits::to_char_type(_Meta);

  0003f	88 11		 mov	 BYTE PTR [rcx], dl
$LN5@pbackfail:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 547  : 		return (_Meta != eof() ? _Meta : !eof());

  00041	33 c0		 xor	 eax, eax
  00043	83 fa ff	 cmp	 edx, -1
  00046	0f 44 d0	 cmove	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 202  : 			return (_Traits::not_eof(_Meta));

  00049	8b c2		 mov	 eax, edx

; 203  : 			}
; 204  : 		}

  0004b	c3		 ret	 0
$LN4@pbackfail:

; 194  : 			&& !_Traits::eq(_Traits::to_char_type(_Meta), _Mysb::gptr()[-1])
; 195  : 			&& _Mystate & _Constant))
; 196  : 			return (_Traits::eof());	// can't put back, fail

  0004c	83 c8 ff	 or	 eax, -1

; 203  : 			}
; 204  : 		}

  0004f	c3		 ret	 0
?pbackfail@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::pbackfail
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z
_TEXT	SEGMENT
this$ = 64
_Meta$ = 72
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow, COMDAT

; 120  : 		{	// put an element to stream

$LN131:
  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 121  : 		if (_Mystate & _Constant)

  00007	8b 41 70	 mov	 eax, DWORD PTR [rcx+112]
  0000a	8b ea		 mov	 ebp, edx
  0000c	48 8b d9	 mov	 rbx, rcx
  0000f	a8 02		 test	 al, 2
  00011	74 0a		 je	 SHORT $LN4@overflow

; 122  : 			return (_Traits::eof());	// array nonmutable, fail

  00013	83 c8 ff	 or	 eax, -1

; 186  : 			}
; 187  : 		}

  00016	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001a	5d		 pop	 rbp
  0001b	5b		 pop	 rbx
  0001c	c3		 ret	 0
$LN4@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 542  : 		return (_Left == _Right);

  0001d	83 fd ff	 cmp	 ebp, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 123  : 		else if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00020	75 09		 jne	 SHORT $LN6@overflow

; 124  : 			return (_Traits::not_eof(_Meta));	// EOF, return success code

  00022	33 c0		 xor	 eax, eax

; 186  : 			}
; 187  : 		}

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	5d		 pop	 rbp
  00029	5b		 pop	 rbx
  0002a	c3		 ret	 0
$LN6@overflow:

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  0002b	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  00030	a8 08		 test	 al, 8
  00032	74 2b		 je	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00034	4c 8b 49 40	 mov	 r9, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 127  : 			&& _Mysb::pptr() != 0 && _Mysb::pptr() < _Seekhigh)

  00038	49 8b 11	 mov	 rdx, QWORD PTR [r9]
  0003b	48 85 d2	 test	 rdx, rdx
  0003e	74 1f		 je	 SHORT $LN7@overflow
  00040	4c 8b 41 68	 mov	 r8, QWORD PTR [rcx+104]
  00044	49 3b d0	 cmp	 rdx, r8
  00047	73 16		 jae	 SHORT $LN7@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00049	48 8b 41 58	 mov	 rax, QWORD PTR [rcx+88]
  0004d	48 63 08	 movsxd	 rcx, DWORD PTR [rax]

; 301  : 		*_IPnext = _Next;

  00050	4d 89 01	 mov	 QWORD PTR [r9], r8

; 259  : 		return (*_IPnext + *_IPcount);

  00053	48 03 ca	 add	 rcx, rdx

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00056	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0005a	41 2b c8	 sub	 ecx, r8d
  0005d	89 08		 mov	 DWORD PTR [rax], ecx
$LN7@overflow:

; 236  : 		return (*_IPnext);

  0005f	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00063	48 8b 38	 mov	 rdi, QWORD PTR [rax]
  00066	48 85 ff	 test	 rdi, rdi
  00069	74 24		 je	 SHORT $LN21@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0006b	48 8b 4b 58	 mov	 rcx, QWORD PTR [rbx+88]
  0006f	48 63 11	 movsxd	 rdx, DWORD PTR [rcx]
  00072	48 8d 04 17	 lea	 rax, QWORD PTR [rdi+rdx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 131  : 			&& _Mysb::pptr() < _Mysb::epptr())

  00076	48 3b f8	 cmp	 rdi, rax
  00079	73 0a		 jae	 SHORT $LN20@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  0007b	8d 42 ff	 lea	 eax, DWORD PTR [rdx-1]
  0007e	89 01		 mov	 DWORD PTR [rcx], eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 134  : 			return (_Meta);

  00080	e9 8d 01 00 00	 jmp	 $LN125@overflow
$LN20@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00085	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00089	48 2b 38	 sub	 rdi, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 138  : 			size_t _Oldsize = _Mysb::pptr() == 0

  0008c	48 03 fa	 add	 rdi, rdx
$LN21@overflow:

; 139  : 				? 0 : _Mysb::epptr() - _Mysb::eback();
; 140  : 			size_t _Newsize = _Oldsize;
; 141  : 			size_t _Inc = _Newsize / 2 < _MINSIZE

  0008f	48 8b cf	 mov	 rcx, rdi
  00092	48 d1 e9	 shr	 rcx, 1
  00095	48 83 f9 20	 cmp	 rcx, 32			; 00000020H
  00099	73 07		 jae	 SHORT $LN22@overflow
  0009b	b9 20 00 00 00	 mov	 ecx, 32			; 00000020H
  000a0	eb 0e		 jmp	 SHORT $LL2@overflow
$LN22@overflow:

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000a2	48 85 c9	 test	 rcx, rcx
  000a5	74 20		 je	 SHORT $LN127@overflow
  000a7	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL2@overflow:
  000b0	b8 ff ff ff 7f	 mov	 eax, 2147483647		; 7fffffffH
  000b5	48 2b c1	 sub	 rax, rcx
  000b8	48 3b c7	 cmp	 rax, rdi
  000bb	73 05		 jae	 SHORT $LN122@overflow

; 145  : 				_Inc /= 2;	// increment causes overflow, halve it

  000bd	48 d1 e9	 shr	 rcx, 1

; 142  : 				? _MINSIZE : _Newsize / 2;	// grow by 50 per cent
; 143  : 
; 144  : 			while (0 < _Inc && INT_MAX - _Inc < _Newsize)

  000c0	75 ee		 jne	 SHORT $LL2@overflow
$LN122@overflow:

; 146  : 			if (_Inc == 0)

  000c2	48 85 c9	 test	 rcx, rcx
  000c5	75 0f		 jne	 SHORT $LN10@overflow
$LN127@overflow:

; 147  : 				return (_Traits::eof());	// buffer can't grow, fail

  000c7	83 c8 ff	 or	 eax, -1
  000ca	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]

; 186  : 			}
; 187  : 		}

  000cf	48 83 c4 28	 add	 rsp, 40			; 00000028H
  000d3	5d		 pop	 rbp
  000d4	5b		 pop	 rbx
  000d5	c3		 ret	 0
$LN10@overflow:

; 148  : 
; 149  : 			_Newsize += _Inc;

  000d6	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi
  000db	4c 89 74 24 58	 mov	 QWORD PTR [rsp+88], r14
  000e0	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15
  000e5	4c 8d 3c 39	 lea	 r15, QWORD PTR [rcx+rdi]

; 151  : 			_Elem *_Newptr = _Unfancy(_Al.allocate(_Newsize));

  000e9	49 8b d7	 mov	 rdx, r15
  000ec	e8 00 00 00 00	 call	 ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ; std::allocator<char>::allocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000f1	48 8b 4b 18	 mov	 rcx, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 151  : 			_Elem *_Newptr = _Unfancy(_Al.allocate(_Newsize));

  000f5	48 8b f0	 mov	 rsi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000f8	4c 8b 31	 mov	 r14, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 154  : 			if (0 < _Oldsize)

  000fb	48 85 ff	 test	 rdi, rdi
  000fe	74 13		 je	 SHORT $LN129@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00100	4c 8b c7	 mov	 r8, rdi
  00103	49 8b d6	 mov	 rdx, r14
  00106	48 8b c8	 mov	 rcx, rax
  00109	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 157  : 			if (_Oldsize == 0)

  0010e	48 85 ff	 test	 rdi, rdi
  00111	75 4e		 jne	 SHORT $LN12@overflow
$LN129@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 293  : 		*_IPfirst = _First;

  00113	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 159  : 				_Seekhigh = _Newptr;

  00117	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 293  : 		*_IPfirst = _First;

  0011b	48 89 30	 mov	 QWORD PTR [rax], rsi

; 294  : 		*_IPnext = _First;

  0011e	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00122	48 89 30	 mov	 QWORD PTR [rax], rsi

; 295  : 		*_IPcount = (int)(_Last - _First);

  00125	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00129	44 89 38	 mov	 DWORD PTR [rax], r15d

; 252  : 		*_IGfirst = _First;

  0012c	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 161  : 				if (_Mystate & _Noread)

  00130	f6 43 70 04	 test	 BYTE PTR [rbx+112], 4
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00134	48 89 30	 mov	 QWORD PTR [rax], rsi

; 253  : 		*_IGnext = _Next;

  00137	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 161  : 				if (_Mystate & _Noread)

  0013b	74 12		 je	 SHORT $LN14@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 253  : 		*_IGnext = _Next;

  0013d	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00144	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00148	89 30		 mov	 DWORD PTR [rax], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 163  : 				else

  0014a	e9 99 00 00 00	 jmp	 $LN17@overflow
$LN14@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 253  : 		*_IGnext = _Next;

  0014f	48 89 30	 mov	 QWORD PTR [rax], rsi

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00152	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00156	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 166  : 			else

  0015c	e9 87 00 00 00	 jmp	 $LN17@overflow
$LN12@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  00161	48 8b 4b 20	 mov	 rcx, QWORD PTR [rbx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 168  : 				_Seekhigh = _Newptr + (_Seekhigh - _Oldptr);

  00165	48 8b c6	 mov	 rax, rsi
  00168	49 2b c6	 sub	 rax, r14
  0016b	48 01 43 68	 add	 QWORD PTR [rbx+104], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0016f	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00173	48 8b 10	 mov	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00176	48 8b c6	 mov	 rax, rsi
  00179	49 2b c6	 sub	 rax, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0017c	49 2b d6	 sub	 rdx, r14

; 300  : 		*_IPfirst = _First;

  0017f	48 01 01	 add	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 169  : 				_Mysb::setp(_Newptr + (_Mysb::pbase() - _Oldptr),

  00182	48 03 d6	 add	 rdx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 301  : 		*_IPnext = _Next;

  00185	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]

; 302  : 		*_IPcount = (int)(_Last - _Next);

  00189	8b ce		 mov	 ecx, esi
  0018b	2b ca		 sub	 ecx, edx
  0018d	41 03 cf	 add	 ecx, r15d
  00190	48 89 10	 mov	 QWORD PTR [rax], rdx
  00193	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00197	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 172  : 				if (_Mystate & _Noread)

  00199	f6 43 70 04	 test	 BYTE PTR [rbx+112], 4
  0019d	74 1a		 je	 SHORT $LN16@overflow
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0019f	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  001a3	48 89 30	 mov	 QWORD PTR [rax], rsi

; 253  : 		*_IGnext = _Next;

  001a6	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001aa	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001b1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001b5	89 30		 mov	 DWORD PTR [rax], esi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 174  : 				else

  001b7	eb 2f		 jmp	 SHORT $LN17@overflow
$LN16@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  001b9	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  001bd	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 226  : 		return (*_IGnext);

  001c0	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001c4	48 8b 08	 mov	 rcx, QWORD PTR [rax]

; 252  : 		*_IGfirst = _First;

  001c7	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]

; 226  : 		return (*_IGnext);

  001cb	49 2b ce	 sub	 rcx, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 175  : 					_Mysb::setg(_Newptr,

  001ce	48 03 ce	 add	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 254  : 		*_IGcount = (int)(_Last - _Next);

  001d1	44 2b c9	 sub	 r9d, ecx
  001d4	41 ff c1	 inc	 r9d
  001d7	48 89 30	 mov	 QWORD PTR [rax], rsi
  001da	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  001de	48 89 08	 mov	 QWORD PTR [rax], rcx
  001e1	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  001e5	44 89 08	 mov	 DWORD PTR [rax], r9d
$LN17@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 180  : 			if (_Mystate & _Allocated)

  001e8	f6 43 70 01	 test	 BYTE PTR [rbx+112], 1
  001ec	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
  001f1	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  001f6	74 0b		 je	 SHORT $LN18@overflow

; 181  : 				_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Oldptr), _Oldsize);

  001f8	4c 8b c7	 mov	 r8, rdi
  001fb	49 8b d6	 mov	 rdx, r14
  001fe	e8 00 00 00 00	 call	 ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ; std::allocator<char>::deallocate
$LN18@overflow:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  00203	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 182  : 			_Mystate |= _Allocated;

  00207	83 4b 70 01	 or	 DWORD PTR [rbx+112], 1

; 185  : 			return (_Meta);

  0020b	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 307  : 		--*_IPcount;

  00210	ff 08		 dec	 DWORD PTR [rax]
$LN125@overflow:

; 308  : 		return ((*_IPnext)++);

  00212	48 8b 4b 40	 mov	 rcx, QWORD PTR [rbx+64]
  00216	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  0021b	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0021e	48 8d 42 01	 lea	 rax, QWORD PTR [rdx+1]
  00222	48 89 01	 mov	 QWORD PTR [rcx], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 185  : 			return (_Meta);

  00225	8b c5		 mov	 eax, ebp
  00227	40 88 2a	 mov	 BYTE PTR [rdx], bpl

; 186  : 			}
; 187  : 		}

  0022a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0022e	5d		 pop	 rbp
  0022f	5b		 pop	 rbx
  00230	c3		 ret	 0
?overflow@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@MEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::overflow
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ
_TEXT	SEGMENT
this$ = 48
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 75   : 		{	// destroy the object

$LN48:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 338  : 		if (_Mystate & _Allocated)

  00006	f6 41 70 01	 test	 BYTE PTR [rcx+112], 1

; 75   : 		{	// destroy the object

  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00011	48 89 01	 mov	 QWORD PTR [rcx], rax
  00014	48 8b d9	 mov	 rbx, rcx

; 338  : 		if (_Mystate & _Allocated)

  00017	74 5c		 je	 SHORT $LN25@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00019	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0001d	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00020	48 85 c9	 test	 rcx, rcx
  00023	74 0c		 je	 SHORT $LN6@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  00025	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00029	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0002c	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0002f	eb 0e		 jmp	 SHORT $LN7@basic_stri
$LN6@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00031	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00035	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00038	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0003c	48 03 10	 add	 rdx, QWORD PTR [rax]
$LN7@basic_stri:

; 221  : 		return (*_IGfirst);

  0003f	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00043	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00046	48 2b d1	 sub	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00049	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00050	72 1e		 jb	 SHORT $LN28@basic_stri

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00052	f6 c1 1f	 test	 cl, 31
  00055	75 5f		 jne	 SHORT $_Invalid_parameter$49

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00057	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0005b	48 3b c1	 cmp	 rax, rcx
  0005e	73 56		 jae	 SHORT $_Invalid_parameter$49
  00060	48 2b c8	 sub	 rcx, rax
  00063	48 83 e9 08	 sub	 rcx, 8
  00067	48 83 f9 1f	 cmp	 rcx, 31
  0006b	77 49		 ja	 SHORT $_Invalid_parameter$49

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0006d	48 8b c8	 mov	 rcx, rax
$LN28@basic_stri:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00070	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00075	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  00079	33 c9		 xor	 ecx, ecx
  0007b	48 89 08	 mov	 QWORD PTR [rax], rcx

; 253  : 		*_IGnext = _Next;

  0007e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00082	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00085	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00089	89 08		 mov	 DWORD PTR [rax], ecx

; 293  : 		*_IPfirst = _First;

  0008b	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  0008f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 294  : 		*_IPnext = _First;

  00092	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  00096	48 89 08	 mov	 QWORD PTR [rax], rcx

; 295  : 		*_IPcount = (int)(_Last - _First);

  00099	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0009d	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  0009f	83 63 70 fe	 and	 DWORD PTR [rbx+112], -2
  000a3	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 77   : 		}

  000a7	48 8b cb	 mov	 rcx, rbx
  000aa	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000ae	5b		 pop	 rbx
  000af	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
$_Invalid_parameter$49:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000bc	cc		 int	 3
$LN47@basic_stri:
??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::~_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 48 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-184]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_fstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 18 01 00 00	 mov	 edx, 280		; 00000118H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 58 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-168]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_ofstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 08 01 00 00	 mov	 edx, 264		; 00000108H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8d b9 50 ff
	ff ff		 lea	 rdi, QWORD PTR [rcx-176]
  00011	8b da		 mov	 ebx, edx
  00013	48 8b cf	 mov	 rcx, rdi
  00016	e8 00 00 00 00	 call	 ??_D?$basic_ifstream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0001b	f6 c3 01	 test	 bl, 1
  0001e	74 0d		 je	 SHORT $LN4@scalar
  00020	ba 10 01 00 00	 mov	 edx, 272		; 00000110H
  00025	48 8b cf	 mov	 rcx, rdi
  00028	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  0002d	48 8b c7	 mov	 rax, rdi
  00030	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	5f		 pop	 rdi
  0003a	c3		 ret	 0
??_G?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
$T2 = 32
this$ = 64
__flags$ = 72
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor', COMDAT
$LN17:
  00000	40 57		 push	 rdi
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T2[rsp], -2
  0000f	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00014	8b fa		 mov	 edi, edx
  00016	48 8b d9	 mov	 rbx, rcx

; 161  : 		{	// destroy the object

  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00020	48 89 01	 mov	 QWORD PTR [rcx], rax

; 162  : 		if (_Myfile != 0)

  00023	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  0002b	74 2d		 je	 SHORT $LN10@scalar
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  0002d	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00031	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00035	49 39 00	 cmp	 QWORD PTR [r8], rax
  00038	75 20		 jne	 SHORT $LN10@scalar

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0003a	48 8b 91 90 00
	00 00		 mov	 rdx, QWORD PTR [rcx+144]
  00041	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  00048	49 89 08	 mov	 QWORD PTR [r8], rcx

; 253  : 		*_IGnext = _Next;

  0004b	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  0004f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  00052	2b d1		 sub	 edx, ecx
  00054	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  00058	89 10		 mov	 DWORD PTR [rax], edx
$LN10@scalar:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 164  : 		if (_Closef)

  0005a	80 7b 7c 00	 cmp	 BYTE PTR [rbx+124], 0
  0005e	74 09		 je	 SHORT $LN6@scalar

; 165  : 			close();

  00060	48 8b cb	 mov	 rcx, rbx
  00063	e8 00 00 00 00	 call	 ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ; std::basic_filebuf<char,std::char_traits<char> >::close
  00068	90		 npad	 1
$LN6@scalar:

; 166  : 		}

  00069	48 8b cb	 mov	 rcx, rbx
  0006c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00072	90		 npad	 1
  00073	40 f6 c7 01	 test	 dil, 1
  00077	74 0e		 je	 SHORT $LN16@scalar
  00079	ba 98 00 00 00	 mov	 edx, 152		; 00000098H
  0007e	48 8b cb	 mov	 rcx, rbx
  00081	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
  00086	90		 npad	 1
$LN16@scalar:
  00087	48 8b c3	 mov	 rax, rbx
  0008a	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  0008f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00093	5f		 pop	 rdi
  00094	c3		 ret	 0
??_G?$basic_filebuf@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 637  : 		{	// destroy the object

  0000f	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  00016	48 8b d9	 mov	 rbx, rcx
  00019	8b fa		 mov	 edi, edx
  0001b	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  0001f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00026	49 89 84 08 68
	ff ff ff	 mov	 QWORD PTR [r8+rcx-152], rax
  0002e	48 8b 81 68 ff
	ff ff		 mov	 rax, QWORD PTR [rcx-152]
  00035	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00039	45 8d 88 68 ff
	ff ff		 lea	 r9d, DWORD PTR [r8-152]
  00040	45 89 8c 08 64
	ff ff ff	 mov	 DWORD PTR [r8+rcx-156], r9d

; 638  : 		}

  00048	48 83 c1 80	 add	 rcx, -128		; ffffffffffffff80H
  0004c	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00051	48 8d 4b 88	 lea	 rcx, QWORD PTR [rbx-120]
  00055	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_iostream@DU?$char_traits@D@std@@@std@@UEAA@XZ
  0005b	48 8b cb	 mov	 rcx, rbx
  0005e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1?$basic_ios@DU?$char_traits@D@std@@@std@@UEAA@XZ
  00064	40 f6 c7 01	 test	 dil, 1
  00068	74 11		 je	 SHORT $LN10@scalar
  0006a	ba f8 00 00 00	 mov	 edx, 248		; 000000f8H
  0006f	48 8d 8b 68 ff
	ff ff		 lea	 rcx, QWORD PTR [rbx-152]
  00076	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN10@scalar:
  0007b	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00080	48 8d 83 68 ff
	ff ff		 lea	 rax, QWORD PTR [rbx-152]
  00087	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00090	5f		 pop	 rdi
  00091	c3		 ret	 0
??_G?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
_TEXT	SEGMENT
this$ = 48
__flags$ = 56
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor', COMDAT
$LN6:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	8b da		 mov	 ebx, edx
  0000c	48 8b f9	 mov	 rdi, rcx
  0000f	e8 00 00 00 00	 call	 ??1?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAA@XZ ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::~basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
  00014	f6 c3 01	 test	 bl, 1
  00017	74 0d		 je	 SHORT $LN4@scalar
  00019	ba 78 00 00 00	 mov	 edx, 120		; 00000078H
  0001e	48 8b cf	 mov	 rcx, rdi
  00021	e8 00 00 00 00	 call	 ??3@YAXPEAX_K@Z		; operator delete
$LN4@scalar:
  00026	48 8b c7	 mov	 rax, rdi
  00029	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00032	5f		 pop	 rdi
  00033	c3		 ret	 0
??_G?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::`scalar deleting destructor'
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::~_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>
_TEXT	ENDS
; Function compile flags: /Ogtpy
;	COMDAT ??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >, COMDAT
  00000	c2 00 00	 ret	 0
??1?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::~_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z PROC ; std::pointer_traits<char * __ptr64>::pointer_to, COMDAT

; 323  : 		return (_STD addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 324  : 		}

  00003	c3		 ret	 0
?pointer_to@?$pointer_traits@PEAD@std@@SAPEADAEAD@Z ENDP ; std::pointer_traits<char * __ptr64>::pointer_to
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$uniform_int@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0?$uniform_int@H@std@@QEAA@HH@Z PROC			; std::uniform_int<int>::uniform_int<int>, COMDAT

; 2256 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2268 : 		}

  00002	48 8b c1	 mov	 rax, rcx

; 2257 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2268 : 		}

  00009	c3		 ret	 0
??0?$uniform_int@H@std@@QEAA@HH@Z ENDP			; std::uniform_int<int>::uniform_int<int>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper, COMDAT

; 1425 : 		int _Ix;
; 1426 : 		for (_Ix = _Nx; _Ix < 2 * _Nx; ++_Ix)
; 1427 : 			{	// fill in values
; 1428 : 			_Ty _Tmp = (this->_Ax[_Ix - _Nx] & _HMSK)
; 1429 : 				| (this->_Ax[_Ix - _Nx + 1] & _LMSK);

  00000	48 8d 41 10	 lea	 rax, QWORD PTR [rcx+16]
  00004	41 b9 38 01 00
	00		 mov	 r9d, 312		; 00000138H
  0000a	49 ba e9 19 66
	a9 5a 6f 02 b5	 mov	 r10, -5403634167711393303 ; b5026f5aa96619e9H
  00014	0f 1f 40 00 0f
	1f 84 00 00 00
	00 00		 npad	 12
$LL4@Refill_upp:
  00020	44 8b 40 f8	 mov	 r8d, DWORD PTR [rax-8]
  00024	44 33 00	 xor	 r8d, DWORD PTR [rax]
  00027	48 8d 40 08	 lea	 rax, QWORD PTR [rax+8]
  0002b	41 0f ba f0 1f	 btr	 r8d, 31
  00030	4c 33 40 f0	 xor	 r8, QWORD PTR [rax-16]

; 1430 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00034	41 0f b6 c8	 movzx	 ecx, r8b
  00038	80 e1 01	 and	 cl, 1
  0003b	f6 d9		 neg	 cl
  0003d	48 1b d2	 sbb	 rdx, rdx
  00040	49 d1 e8	 shr	 r8, 1
  00043	49 23 d2	 and	 rdx, r10
  00046	48 33 90 d0 04
	00 00		 xor	 rdx, QWORD PTR [rax+1232]
  0004d	49 33 d0	 xor	 rdx, r8
  00050	48 89 90 b0 09
	00 00		 mov	 QWORD PTR [rax+2480], rdx
  00057	49 83 e9 01	 sub	 r9, 1
  0005b	75 c3		 jne	 SHORT $LL4@Refill_upp

; 1431 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1432 : 			}
; 1433 : 		}

  0005d	c3		 ret	 0
?_Refill_upper@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_upper
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower, COMDAT

; 1399 : 		{	// compute values for the lower half of the history array

$LN18:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	4c 8b d1	 mov	 r10, rcx

; 1400 : 		int _Ix;
; 1401 : 		for (_Ix = 0; _Ix < _Nx - _Mx; ++_Ix)

  00008	4c 8d 89 c8 09
	00 00		 lea	 r9, QWORD PTR [rcx+2504]
  0000f	48 bb e9 19 66
	a9 5a 6f 02 b5	 mov	 rbx, -5403634167711393303 ; b5026f5aa96619e9H
  00019	41 bb 9c 00 00
	00		 mov	 r11d, 156		; 0000009cH
  0001f	90		 npad	 1
$LL4@Refill_low:

; 1402 : 			{	// fill in lower region
; 1403 : 			_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK)
; 1404 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00020	41 8b 11	 mov	 edx, DWORD PTR [r9]
  00023	41 33 51 08	 xor	 edx, DWORD PTR [r9+8]
  00027	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  0002b	0f ba f2 1f	 btr	 edx, 31
  0002f	49 33 51 f8	 xor	 rdx, QWORD PTR [r9-8]

; 1405 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00033	0f b6 c2	 movzx	 eax, dl
  00036	24 01		 and	 al, 1
  00038	f6 d8		 neg	 al
  0003a	48 1b c9	 sbb	 rcx, rcx
  0003d	48 d1 ea	 shr	 rdx, 1
  00040	48 23 cb	 and	 rcx, rbx
  00043	49 33 89 d8 04
	00 00		 xor	 rcx, QWORD PTR [r9+1240]
  0004a	48 33 ca	 xor	 rcx, rdx
  0004d	49 89 89 38 f6
	ff ff		 mov	 QWORD PTR [r9-2504], rcx
  00054	49 83 eb 01	 sub	 r11, 1
  00058	75 c6		 jne	 SHORT $LL4@Refill_low

; 1406 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix + _Nx + _Mx];
; 1407 : 			}
; 1408 : 
; 1409 : 		for (; _Ix < _Nx - 1; ++_Ix)

  0005a	4d 8d 8a a8 0e
	00 00		 lea	 r9, QWORD PTR [r10+3752]
  00061	41 bb 9b 00 00
	00		 mov	 r11d, 155		; 0000009bH
  00067	66 0f 1f 84 00
	00 00 00 00	 npad	 9
$LL7@Refill_low:

; 1410 : 			{	// fill in upper region (avoids modulus operation)
; 1411 : 			_Ty _Tmp = (this->_Ax[_Ix +_Nx] & _HMSK)
; 1412 : 				| (this->_Ax[_Ix + _Nx + 1] & _LMSK);

  00070	41 8b 11	 mov	 edx, DWORD PTR [r9]
  00073	41 33 51 08	 xor	 edx, DWORD PTR [r9+8]
  00077	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  0007b	0f ba f2 1f	 btr	 edx, 31
  0007f	49 33 51 f8	 xor	 rdx, QWORD PTR [r9-8]

; 1413 : 			this->_Ax[_Ix] = (_Tmp >> 1)

  00083	0f b6 c2	 movzx	 eax, dl
  00086	24 01		 and	 al, 1
  00088	f6 d8		 neg	 al
  0008a	48 1b c9	 sbb	 rcx, rcx
  0008d	48 d1 ea	 shr	 rdx, 1
  00090	48 23 cb	 and	 rcx, rbx
  00093	49 33 89 58 f1
	ff ff		 xor	 rcx, QWORD PTR [r9-3752]
  0009a	48 33 ca	 xor	 rcx, rdx
  0009d	49 89 89 38 f6
	ff ff		 mov	 QWORD PTR [r9-2504], rcx
  000a4	49 83 eb 01	 sub	 r11, 1
  000a8	75 c6		 jne	 SHORT $LL7@Refill_low

; 1414 : 				^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Ix - _Nx + _Mx];
; 1415 : 			}
; 1416 : 
; 1417 : 		_Ty _Tmp = (this->_Ax[_Ix + _Nx] & _HMSK) | (this->_Ax[0] & _LMSK);

  000aa	41 8b 92 80 13
	00 00		 mov	 edx, DWORD PTR [r10+4992]
  000b1	41 33 52 08	 xor	 edx, DWORD PTR [r10+8]
  000b5	0f ba f2 1f	 btr	 edx, 31
  000b9	49 33 92 80 13
	00 00		 xor	 rdx, QWORD PTR [r10+4992]

; 1418 : 		this->_Ax[_Ix] = (_Tmp >> 1)

  000c0	0f b6 c2	 movzx	 eax, dl
  000c3	24 01		 and	 al, 1
  000c5	f6 d8		 neg	 al
  000c7	48 1b c9	 sbb	 rcx, rcx
  000ca	48 d1 ea	 shr	 rdx, 1
  000cd	48 23 cb	 and	 rcx, rbx

; 1419 : 			^ (_Tmp & 1 ? _Px : 0) ^ this->_Ax[_Mx - 1];
; 1420 : 		this->_Idx = 0;
; 1421 : 		}

  000d0	48 8b 5c 24 08	 mov	 rbx, QWORD PTR [rsp+8]
  000d5	49 33 8a e0 04
	00 00		 xor	 rcx, QWORD PTR [r10+1248]
  000dc	48 33 ca	 xor	 rcx, rdx
  000df	49 89 8a c0 09
	00 00		 mov	 QWORD PTR [r10+2496], rcx
  000e6	45 89 1a	 mov	 DWORD PTR [r10], r11d
  000e9	c3		 ret	 0
?_Refill_lower@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@IEAAXXZ ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::_Refill_lower
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
_Dxarg$dead$ = 24
_Fxarg$dead$ = 32
??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>, COMDAT

; 1321 : 		: _Dxval(_Dxarg)

  00000	48 b8 55 55 55
	55 55 55 55 55	 mov	 rax, 6148914691236517205 ; 5555555555555555H
  0000a	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  0000e	48 89 81 88 13
	00 00		 mov	 QWORD PTR [rcx+5000], rax
  00015	41 b8 01 00 00
	00		 mov	 r8d, 1

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  0001b	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx

; 1321 : 		: _Dxval(_Dxarg)

  0001f	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00025	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0002f	90		 npad	 1
$LL6@mersenne_t:

; 1339 : 			_Prev = this->_Ax[_Ix] =

  00030	48 8b c2	 mov	 rax, rdx
  00033	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00037	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0003b	48 33 d0	 xor	 rdx, rax
  0003e	49 0f af d3	 imul	 rdx, r11
  00042	49 03 d0	 add	 rdx, r8
  00045	49 ff c0	 inc	 r8
  00048	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0004c	49 83 ea 01	 sub	 r10, 1
  00050	75 de		 jne	 SHORT $LL6@mersenne_t

; 1340 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1341 : 		this->_Idx = _Nx;

  00052	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1323 : 		seed(_X0, _Fxarg);
; 1324 : 		}

  00058	48 8b c1	 mov	 rax, rcx
  0005b	c3		 ret	 0
??0?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAA@_K00@Z ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 141  : 			return (_Ok);

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 142  : 			}

  00004	c3		 ret	 0
??Bsentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry, COMDAT

; 129  : 			{	// destroy the object

$LN13:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 130  :  #if _HAS_EXCEPTIONS
; 131  : 			if (!_STD uncaught_exception())

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00018	90		 npad	 1
  00019	84 c0		 test	 al, al
  0001b	75 0a		 jne	 SHORT $LN2@sentry

; 132  : 				this->_Myostr._Osfx();

  0001d	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00020	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  00026	90		 npad	 1
$LN2@sentry:

; 106  : 			if (_Myostr.rdbuf() != 0)

  00027	48 8b 13	 mov	 rdx, QWORD PTR [rbx]
  0002a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00031	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  00036	48 85 c9	 test	 rcx, rcx
  00039	74 07		 je	 SHORT $LN12@sentry

; 107  : 				_Myostr.rdbuf()->_Unlock();

  0003b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003e	ff 50 10	 call	 QWORD PTR [rax+16]
  00041	90		 npad	 1
$LN12@sentry:

; 133  : 
; 134  :  #else /* _HAS_EXCEPTIONS */
; 135  : 			this->_Myostr._Osfx();
; 136  :  #endif /* _HAS_EXCEPTIONS */
; 137  : 			}

  00042	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00046	5b		 pop	 rbx
  00047	c3		 ret	 0
??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 122  : 			{	// construct locking and testing stream

$LN26:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T8[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	48 8b da	 mov	 rbx, rdx
  0001b	48 8b f9	 mov	 rdi, rcx

; 98   : 			: _Myostr(_Ostr)

  0001e	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 100  : 			if (_Myostr.rdbuf() != 0)

  00021	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00024	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00028	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  0002d	48 85 c9	 test	 rcx, rcx
  00030	74 07		 je	 SHORT $LN6@sentry

; 101  : 				_Myostr.rdbuf()->_Lock();

  00032	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00035	ff 50 08	 call	 QWORD PTR [rax+8]
  00038	90		 npad	 1
$LN6@sentry:

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00039	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0003c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00040	83 7c 19 10 00	 cmp	 DWORD PTR [rcx+rbx+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00045	75 15		 jne	 SHORT $LN2@sentry
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 79   : 		return (_Tiestr);

  00047	48 8b 4c 19 50	 mov	 rcx, QWORD PTR [rcx+rbx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 0b		 je	 SHORT $LN2@sentry
  00051	48 3b cb	 cmp	 rcx, rbx
  00054	74 06		 je	 SHORT $LN2@sentry

; 124  : 				_Ostr.tie()->flush();

  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN2@sentry:

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0005c	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  0005f	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00063	83 7c 19 10 00	 cmp	 DWORD PTR [rcx+rbx+16], 0
  00068	0f 94 c0	 sete	 al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0006b	88 47 08	 mov	 BYTE PTR [rdi+8], al

; 126  : 			}

  0006e	48 8b c7	 mov	 rax, rdi
  00071	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00076	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
??0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T8 = 32
this$ = 64
_Ostr$ = 72
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA PROC ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z@4HA ENDP ; `std::basic_ostream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1433 : 		return ((reference)**(_Mybase *)this);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1434 : 		}

  00003	c3		 ret	 0
??D?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEADXZ ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$dead$ = 8
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty, COMDAT

; 1654 : 			}

  00000	c2 00 00	 ret	 0
??1_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::~_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
_Size$ = 24
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size, COMDAT

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 2b c2	 sub	 rax, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00007	49 3b c0	 cmp	 rax, r8
  0000a	4c 0f 42 c0	 cmovb	 r8, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0000e	49 8b c0	 mov	 rax, r8

; 1644 : 		}

  00011	c3		 ret	 0
?_Clamp_suffix_size@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_K_K0@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Clamp_suffix_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Off$ = 56
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z PROC ; std::_String_val<std::_Simple_types<char> >::_Check_offset, COMDAT

; 1621 : 		{	// checks whether _Off is in the bounds of [0, this->size()]

$LN7:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1622 : 		if (_Mysize < _Off)

  00004	48 39 51 10	 cmp	 QWORD PTR [rcx+16], rdx
  00008	72 05		 jb	 SHORT $LN5@Check_offs

; 1625 : 			}
; 1626 : 		}

  0000a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0000e	c3		 ret	 0
$LN5@Check_offs:

; 1623 : 			{
; 1624 : 			_Xran();

  0000f	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  00014	cc		 int	 3
$LN4@Check_offs:
?_Check_offset@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAX_K@Z ENDP ; std::_String_val<std::_Simple_types<char> >::_Check_offset
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16
  00005	0f 93 c0	 setae	 al

; 1618 : 		}

  00008	c3		 ret	 0
?_Large_string_engaged@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBA_NXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Large_string_engaged
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;
; 1607 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN8@Myptr

; 1608 : 			{
; 1609 : 			_Result = _Unfancy(_Bx._Ptr);
; 1610 : 			}
; 1611 : 
; 1612 : 		return (_Result);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1613 : 		}

  0000a	c3		 ret	 0
$LN8@Myptr:

; 1608 : 			{
; 1609 : 			_Result = _Unfancy(_Bx._Ptr);
; 1610 : 			}
; 1611 : 
; 1612 : 		return (_Result);

  0000b	48 8b c1	 mov	 rax, rcx

; 1613 : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEBAPEBDXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ
_TEXT	SEGMENT
this$ = 8
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Myptr, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1595 : 		value_type * _Result = _Bx._Buf;
; 1596 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN8@Myptr

; 1597 : 			{
; 1598 : 			_Result = _Unfancy(_Bx._Ptr);
; 1599 : 			}
; 1600 : 
; 1601 : 		return (_Result);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1602 : 		}

  0000a	c3		 ret	 0
$LN8@Myptr:

; 1597 : 			{
; 1598 : 			_Result = _Unfancy(_Bx._Ptr);
; 1599 : 			}
; 1600 : 
; 1601 : 		return (_Result);

  0000b	48 8b c1	 mov	 rax, rcx

; 1602 : 		}

  0000e	c3		 ret	 0
?_Myptr@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAAPEADXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Myptr
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 8
_Al$dead$ = 16
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction, COMDAT

; 872  : 		return (_Al);

  00000	48 8b c1	 mov	 rax, rcx

; 873  : 		}

  00003	c3		 ret	 0
?select_on_container_copy_construction@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA?AV?$allocator@D@2@AEBV32@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::select_on_container_copy_construction
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 1840 : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 1841 : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data, COMDAT

; 1835 : 		return (_Mypair._Get_second());

  00000	48 8b c1	 mov	 rax, rcx

; 1836 : 		}

  00003	c3		 ret	 0
?_Get_data@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Get_data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 1830 : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 1831 : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal, COMDAT

; 1825 : 		return (_Mypair._Get_first());

  00000	48 8b c1	 mov	 rax, rcx

; 1826 : 		}

  00003	c3		 ret	 0
?_Getal@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Getal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ
_TEXT	SEGMENT
this$dead$ = 8
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all, COMDAT

; 1815 : 		_Get_data()._Orphan_all();
; 1816 : 		}

  00000	c2 00 00	 ret	 0
?_Orphan_all@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXXZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Orphan_all
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Al$dead$ = 16
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc, COMDAT

; 1720 : 		_Pocma(_Getal(), _Al);
; 1721 : 		}

  00000	c2 00 00	 ret	 0
?_Move_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEAV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Move_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
this$dead$ = 8
_Al$dead$ = 16
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc, COMDAT

; 1715 : 		_Pocca(_Getal(), _Al);
; 1716 : 		}

  00000	c2 00 00	 ret	 0
?_Copy_alloc@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAAXAEBV?$allocator@D@2@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_Copy_alloc
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >, COMDAT

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1703 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@XZ ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate, COMDAT

; 3706 : 		{	// initialize buffer, deallocating any storage

$LN46:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00006	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 3706 : 		{	// initialize buffer, deallocating any storage

  0000a	48 8b d9	 mov	 rbx, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0000d	48 83 f8 10	 cmp	 rax, 16

; 3707 : 		this->_Orphan_all();
; 3708 : 		auto& _My_data = this->_Get_data();
; 3709 : 		if (_My_data._Large_string_engaged())

  00011	72 31		 jb	 SHORT $LN25@Tidy_deall
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00013	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00016	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00019	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0001f	72 1e		 jb	 SHORT $LN28@Tidy_deall

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00021	f6 c1 1f	 test	 cl, 31
  00024	75 37		 jne	 SHORT $_Invalid_parameter$47

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00026	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	73 2e		 jae	 SHORT $_Invalid_parameter$47
  0002f	48 2b c8	 sub	 rcx, rax
  00032	48 83 e9 08	 sub	 rcx, 8
  00036	48 83 f9 1f	 cmp	 rcx, 31
  0003a	77 21		 ja	 SHORT $_Invalid_parameter$47

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0003c	48 8b c8	 mov	 rcx, rax
$LN28@Tidy_deall:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0003f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@Tidy_deall:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3717 : 		_My_data._Mysize = 0;

  00044	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 3718 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0004c	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00054	c6 03 00	 mov	 BYTE PTR [rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3722 : 		}

  00057	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005b	5b		 pop	 rbx
  0005c	c3		 ret	 0
$_Invalid_parameter$47:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00063	cc		 int	 3
$LN45@Tidy_deall:
?_Tidy_deallocate@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init, COMDAT

; 3697 : 		auto& _My_data = this->_Get_data();
; 3698 : 		_My_data._Mysize = 0;

  00000	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00008	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00010	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3703 : 		}

  00013	c3		 ret	 0
?_Tidy_init@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Tidy_init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 8
_Newsize$dead$ = 16
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 3691 : 		auto& _My_data = this->_Get_data();
; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00005	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1596 : 		if (_Large_string_engaged())

  0000d	72 07		 jb	 SHORT $LN19@Eos
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00012	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3693 : 		}

  00015	c3		 ret	 0
$LN19@Eos:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00016	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3693 : 		}

  00019	c3		 ret	 0
?_Eos@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Eos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small, COMDAT

; 3676 : 		{	// release any held storage and return to small string mode

$LN48:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3677 : 			// pre: *this is in large string mode
; 3678 : 			// pre: this is small enough to return to small string mode
; 3679 : 		auto& _My_data = this->_Get_data();
; 3680 : 		_My_data._Orphan_all();
; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  0000a	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx

; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00010	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00014	48 8b d3	 mov	 rdx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00017	49 ff c0	 inc	 r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001a	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0001f	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00023	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00026	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  0002c	72 1e		 jb	 SHORT $LN33@Become_sma

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0002e	f6 c3 1f	 test	 bl, 31
  00031	75 34		 jne	 SHORT $_Invalid_parameter$49

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00033	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00037	48 3b c3	 cmp	 rax, rbx
  0003a	73 2b		 jae	 SHORT $_Invalid_parameter$49
  0003c	48 2b d8	 sub	 rbx, rax
  0003f	48 83 eb 08	 sub	 rbx, 8
  00043	48 83 fb 1f	 cmp	 rbx, 31
  00047	77 1e		 ja	 SHORT $_Invalid_parameter$49

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00049	48 8b d8	 mov	 rbx, rax
$LN33@Become_sma:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0004c	48 8b cb	 mov	 rcx, rbx
  0004f	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3687 : 		}

  00054	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00059	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
  00061	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00065	5f		 pop	 rdi
  00066	c3		 ret	 0
$_Invalid_parameter$49:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0006d	cc		 int	 3
$LN47@Become_sma:
?_Become_small@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Become_small
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$dead$ = 8
__$ReturnUdt$ = 16
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator, COMDAT

; 3584 : 		return (static_cast<allocator_type>(this->_Getal()));

  00000	48 8b c2	 mov	 rax, rdx

; 3585 : 		}

  00003	c3		 ret	 0
?get_allocator@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$allocator@D@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::get_allocator
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$dead$ = 8
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size, COMDAT

; 3067 : 		const size_type _Alloc_max = _Alty_traits::max_size(this->_Getal());
; 3068 : 		const size_type _Storage_max = // can always store small string
; 3069 : 			_Max_value(_Alloc_max, static_cast<size_type>(this->_BUF_SIZE));
; 3070 : 		return (_Min_value(

  00000	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH

; 3071 : 			static_cast<size_type>((numeric_limits<difference_type>::max)()),
; 3072 : 			_Storage_max - 1 // -1 is for null terminator and/or npos
; 3073 : 			));
; 3074 : 
; 3075 : 		}

  0000a	c3		 ret	 0
?max_size@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
;	COMDAT ??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Max_value<unsigned __int64>, COMDAT

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00000	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00003	48 39 01	 cmp	 QWORD PTR [rcx], rax
  00006	48 0f 42 ca	 cmovb	 rcx, rdx
  0000a	48 8b c1	 mov	 rax, rcx

; 33   : 	}

  0000d	c3		 ret	 0
??$_Max_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Max_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z
_TEXT	SEGMENT
this$ = 8
_Ch$ = 16
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back, COMDAT

; 2990 : 		auto& _My_data = this->_Get_data();
; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00000	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2992 : 		if (_Old_size < _My_data._Myres)

  00004	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
  00008	4d 3b c1	 cmp	 r8, r9
  0000b	73 1c		 jae	 SHORT $LN2@push_back

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  0000d	49 8d 40 01	 lea	 rax, QWORD PTR [r8+1]
  00011	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00015	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00019	72 03		 jb	 SHORT $LN11@push_back
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0001b	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
$LN11@push_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001e	42 88 14 01	 mov	 BYTE PTR [rcx+r8], dl
  00022	42 c6 44 01 01
	00		 mov	 BYTE PTR [rcx+r8+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3008 : 		}

  00028	c3		 ret	 0
$LN2@push_back:

; 2995 : 			_Elem * const _Ptr = _My_data._Myptr();
; 2996 : 			_Traits::assign(_Ptr[_Old_size], _Ch);
; 2997 : 			_Traits::assign(_Ptr[_Old_size + 1], _Elem());
; 2998 : 			return;
; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00029	44 0f b6 ca	 movzx	 r9d, dl
  0002d	e9 00 00 00 00	 jmp	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
?push_back@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::push_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ch$ = 80
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z PROC ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator(), COMDAT

; 3003 : 				const _Elem _Ch) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3003 : 				const _Elem _Ch) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001c	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  00021	0f b6 44 24 50	 movzx	 eax, BYTE PTR _Ch$[rsp]
  00026	88 04 1f	 mov	 BYTE PTR [rdi+rbx], al
  00029	c6 44 1f 01 00	 mov	 BYTE PTR [rdi+rbx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3007 : 			}, _Ch);

  0002e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5f		 pop	 rdi
  00038	c3		 ret	 0
??R<lambda_319d5e083f45f90dcdce5dce53cbb275>@@QEBA@QEADQEBD_KD@Z ENDP ; <lambda_319d5e083f45f90dcdce5dce53cbb275>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1596 : 		if (_Large_string_engaged())

  00005	72 0a		 jb	 SHORT $LN28@begin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1214 : 		: _Ptr(_Parg)

  0000a	48 89 02	 mov	 QWORD PTR [rdx], rax

; 2841 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2842 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));

  0000d	48 8b c2	 mov	 rax, rdx

; 2843 : 		}

  00010	c3		 ret	 0
$LN28@begin:

; 1214 : 		: _Ptr(_Parg)

  00011	48 89 0a	 mov	 QWORD PTR [rdx], rcx

; 2841 : 		auto _My_data = _STD addressof(this->_Get_data());
; 2842 : 		return (iterator(_Refancy<pointer>(_My_data->_Myptr()), _My_data));

  00014	48 8b c2	 mov	 rax, rdx

; 2843 : 		}

  00017	c3		 ret	 0
?begin@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA?AV?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@2@XZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::begin
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 64
_Count$dead$ = 72
_Ch$dead$ = 80
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2456 : 		{	// assign _Count * _Ch

$LN154:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 2457 : 		auto& _My_data = this->_Get_data();
; 2458 : 		if (_Count <= _My_data._Myres)

  00007	48 8b 71 18	 mov	 rsi, QWORD PTR [rcx+24]
  0000b	48 8b d9	 mov	 rbx, rcx
  0000e	48 83 fe 08	 cmp	 rsi, 8
  00012	72 26		 jb	 SHORT $LN2@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  00014	48 8b c1	 mov	 rax, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00017	48 83 fe 10	 cmp	 rsi, 16

; 1596 : 		if (_Large_string_engaged())

  0001b	72 03		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2461 : 			_My_data._Mysize = _Count;

  00020	48 c7 41 10 08
	00 00 00	 mov	 QWORD PTR [rcx+16], 8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00028	33 c9		 xor	 ecx, ecx
  0002a	48 89 08	 mov	 QWORD PTR [rax], rcx

; 517  : 		_Left = _Right;

  0002d	88 48 08	 mov	 BYTE PTR [rax+8], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2467 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  00030	48 8b c3	 mov	 rax, rbx

; 2471 : 		}

  00033	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00037	5e		 pop	 rsi
  00038	5b		 pop	 rbx
  00039	c3		 ret	 0
$LN2@assign:

; 3598 : 		if (_Old > _Max - _Old / 2)

  0003a	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0003f	48 8b ce	 mov	 rcx, rsi
  00042	48 d1 e9	 shr	 rcx, 1
  00045	49 be ff ff ff
	ff ff ff ff 7f	 mov	 r14, 9223372036854775807 ; 7fffffffffffffffH
  0004f	49 8b c6	 mov	 rax, r14
  00052	48 2b c1	 sub	 rax, rcx
  00055	48 3b f0	 cmp	 rsi, rax
  00058	77 11		 ja	 SHORT $LN55@assign

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005a	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  0005e	41 be 0f 00 00
	00		 mov	 r14d, 15
  00064	49 3b c6	 cmp	 rax, r14
  00067	4c 0f 47 f0	 cmova	 r14, rax
$LN55@assign:

; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006b	48 89 6c 24 48	 mov	 QWORD PTR [rsp+72], rbp
  00070	49 8b ce	 mov	 rcx, r14
  00073	48 83 c1 01	 add	 rcx, 1
  00077	48 89 7c 24 50	 mov	 QWORD PTR [rsp+80], rdi
  0007c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00083	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00087	33 ed		 xor	 ebp, ebp
  00089	48 85 c9	 test	 rcx, rcx
  0008c	75 04		 jne	 SHORT $LN98@assign
  0008e	8b fd		 mov	 edi, ebp
  00090	eb 43		 jmp	 SHORT $LN97@assign
$LN98@assign:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00092	40 84 ed	 test	 bpl, bpl
  00095	74 07		 je	 SHORT $LN99@assign

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0009d	cc		 int	 3
$LN99@assign:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0009e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a5	72 26		 jb	 SHORT $LN100@assign

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000a7	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000ab	48 3b c1	 cmp	 rax, rcx
  000ae	77 07		 ja	 SHORT $LN101@assign

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000b6	cc		 int	 3
$LN101@assign:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b7	48 8b c8	 mov	 rcx, rax
  000ba	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000bf	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000c3	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c7	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000cb	eb 08		 jmp	 SHORT $LN97@assign
$LN100@assign:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000cd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d2	48 8b f8	 mov	 rdi, rax
$LN97@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000d5	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000d7	48 c7 43 10 08
	00 00 00	 mov	 QWORD PTR [rbx+16], 8

; 3623 : 		_My_data._Myres = _New_capacity;

  000df	4c 89 73 18	 mov	 QWORD PTR [rbx+24], r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000e3	48 89 07	 mov	 QWORD PTR [rdi], rax

; 517  : 		_Left = _Right;

  000e6	88 47 08	 mov	 BYTE PTR [rdi+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e9	48 83 fe 10	 cmp	 rsi, 16
  000ed	72 37		 jb	 SHORT $LN25@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000ef	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000f2	48 ff c6	 inc	 rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000f5	40 84 ed	 test	 bpl, bpl
  000f8	75 48		 jne	 SHORT $_Invalid_parameter$155

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000fa	48 81 fe 00 10
	00 00		 cmp	 rsi, 4096		; 00001000H
  00101	72 1e		 jb	 SHORT $LN125@assign

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00103	f6 c1 1f	 test	 cl, 31
  00106	75 3a		 jne	 SHORT $_Invalid_parameter$155

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00108	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0010c	48 3b c1	 cmp	 rax, rcx
  0010f	73 31		 jae	 SHORT $_Invalid_parameter$155
  00111	48 2b c8	 sub	 rcx, rax
  00114	48 83 e9 08	 sub	 rcx, 8
  00118	48 83 f9 1f	 cmp	 rcx, 31
  0011c	77 24		 ja	 SHORT $_Invalid_parameter$155

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0011e	48 8b c8	 mov	 rcx, rax
$LN125@assign:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00121	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN25@assign:
  00126	48 8b 6c 24 48	 mov	 rbp, QWORD PTR [rsp+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2467 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem _Ch) {

  0012b	48 8b c3	 mov	 rax, rbx
  0012e	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00133	48 89 3b	 mov	 QWORD PTR [rbx], rdi
  00136	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2471 : 		}

  0013b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0013f	5e		 pop	 rsi
  00140	5b		 pop	 rbx
  00141	c3		 ret	 0
$_Invalid_parameter$155:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00142	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00148	cc		 int	 3
$LN153@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Count$dead$ = 24
_Ch$dead$ = 32
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z PROC ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator(), COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00000	33 c0		 xor	 eax, eax
  00002	48 89 02	 mov	 QWORD PTR [rdx], rax

; 517  : 		_Left = _Right;

  00005	88 42 08	 mov	 BYTE PTR [rdx+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2470 : 			}, _Ch));

  00008	c3		 ret	 0
??R<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@QEBA@QEAD_KD@Z ENDP ; <lambda_138c3d7c38c85abb84c7fc7bfe5747b7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2451 : 		{	// assign [_Ptr, <null>)

$LN32:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000d	48 83 cb ff	 or	 rbx, -1
$LL30@assign:
  00011	48 ff c3	 inc	 rbx
  00014	80 3c 1a 00	 cmp	 BYTE PTR [rdx+rbx], 0
  00018	75 f7		 jne	 SHORT $LL30@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2435 : 		if (_Count <= _My_data._Myres)

  0001a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001e	48 3b d8	 cmp	 rbx, rax
  00021	77 38		 ja	 SHORT $LN9@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  00023	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00028	48 8b f7	 mov	 rsi, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0002b	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  0002f	72 03		 jb	 SHORT $LN18@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00031	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN18@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00034	48 89 59 10	 mov	 QWORD PTR [rcx+16], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00038	4c 8b c3	 mov	 r8, rbx
  0003b	48 8b ce	 mov	 rcx, rsi
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00044	c6 04 1e 00	 mov	 BYTE PTR [rsi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2452 : 		return (assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  00048	48 8b c7	 mov	 rax, rdi
  0004b	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2453 : 		}

  00050	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00055	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00059	5f		 pop	 rdi
  0005a	c3		 ret	 0
$LN9@assign:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005b	4c 8b ca	 mov	 r9, rdx
  0005e	48 8b d3	 mov	 rdx, rbx

; 2453 : 		}

  00061	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00066	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0006a	5f		 pop	 rdi

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0006b	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
_Count$ = 64
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2433 : 		{	// assign [_Ptr, _Ptr + _Count)

$LN24:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2434 : 		auto& _My_data = this->_Get_data();
; 2435 : 		if (_Count <= _My_data._Myres)

  0000a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0000e	49 8b f8	 mov	 rdi, r8
  00011	48 8b d9	 mov	 rbx, rcx
  00014	4c 3b c0	 cmp	 r8, rax
  00017	77 35		 ja	 SHORT $LN2@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  00019	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  0001e	48 8b f1	 mov	 rsi, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00021	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00025	72 03		 jb	 SHORT $LN11@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00027	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN11@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  0002a	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0002e	48 8b ce	 mov	 rcx, rsi
  00031	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00037	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2441 : 			return (*this);

  0003b	48 8b c3	 mov	 rax, rbx
  0003e	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]

; 2445 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2446 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2447 : 			}, _Ptr));
; 2448 : 		}

  00043	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00048	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004c	5f		 pop	 rdi
  0004d	c3		 ret	 0
$LN2@assign:

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0004e	4c 8b ca	 mov	 r9, rdx
  00051	48 8b d7	 mov	 rdx, rdi

; 2445 : 			_Traits::copy(_New_ptr, _Ptr, _Count);
; 2446 : 			_Traits::assign(_New_ptr[_Count], _Elem());
; 2447 : 			}, _Ptr));
; 2448 : 		}

  00054	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00059	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0005d	5f		 pop	 rdi

; 2442 : 			}
; 2443 : 
; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0005e	e9 00 00 00 00	 jmp	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Count$ = 64
_Ptr$ = 72
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z PROC ; <lambda_66f57f934f28d61049862f64df852ff0>::operator(), COMDAT

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b da	 mov	 rbx, rdx
  0000d	49 8b f8	 mov	 rdi, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00010	48 8b cb	 mov	 rcx, rbx
  00013	49 8b d1	 mov	 rdx, r9
  00016	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  0001b	c6 04 3b 00	 mov	 BYTE PTR [rbx+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2447 : 			}, _Ptr));

  0001f	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00024	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00028	5f		 pop	 rdi
  00029	c3		 ret	 0
??R<lambda_66f57f934f28d61049862f64df852ff0>@@QEBA@QEAD_KQEBD@Z ENDP ; <lambda_66f57f934f28d61049862f64df852ff0>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z
_TEXT	SEGMENT
this$ = 64
_Count$ = 72
_Ch$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2375 : 		{	// append _Count * _Ch

$LN24:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b f2	 mov	 rsi, rdx

; 2376 : 		auto& _My_data = this->_Get_data();
; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00014	48 8b 57 18	 mov	 rdx, QWORD PTR [rdi+24]
  00018	48 8b c2	 mov	 rax, rdx
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	48 3b f0	 cmp	 rsi, rax
  00021	77 43		 ja	 SHORT $LN2@append

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  0002c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00030	48 8b c7	 mov	 rax, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00033	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  00037	72 03		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00039	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2382 : 			_Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);

  0003c	48 8d 1c 08	 lea	 rbx, QWORD PTR [rax+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00040	41 0f be d0	 movsx	 edx, r8b
  00044	48 8b cb	 mov	 rcx, rbx
  00047	4c 8b c6	 mov	 r8, rsi
  0004a	e8 00 00 00 00	 call	 memset

; 517  : 		_Left = _Right;

  0004f	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00053	48 8b c7	 mov	 rax, rdi
  00056	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2388 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2389 : 				const size_type _Count, const _Elem _Ch) {
; 2390 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2393 : 			}, _Count, _Ch));
; 2394 : 		}

  0005b	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  00060	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00064	5f		 pop	 rdi
  00065	c3		 ret	 0
$LN2@append:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00066	4c 8b ce	 mov	 r9, rsi
  00069	44 88 44 24 20	 mov	 BYTE PTR [rsp+32], r8b
  0006e	48 8b d6	 mov	 rdx, rsi
  00071	48 8b cf	 mov	 rcx, rdi
  00074	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>

; 2388 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2389 : 				const size_type _Count, const _Elem _Ch) {
; 2390 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2393 : 			}, _Count, _Ch));
; 2394 : 		}

  00079	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007e	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00082	5f		 pop	 rdi
  00083	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Count$ = 80
_Ch$ = 88
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z PROC ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator(), COMDAT

; 2389 : 				const size_type _Count, const _Elem _Ch) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2389 : 				const size_type _Count, const _Elem _Ch) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001c	e8 00 00 00 00	 call	 memcpy

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00021	0f be 54 24 58	 movsx	 edx, BYTE PTR _Ch$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00026	48 03 fb	 add	 rdi, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00029	48 8b 5c 24 50	 mov	 rbx, QWORD PTR _Count$[rsp]
  0002e	48 8b cf	 mov	 rcx, rdi
  00031	4c 8b c3	 mov	 r8, rbx
  00034	e8 00 00 00 00	 call	 memset

; 517  : 		_Left = _Right;

  00039	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2393 : 			}, _Count, _Ch));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??R<lambda_e1befb086ad3257e3f042a63030725f7>@@QEBA@QEADQEBD_K2D@Z ENDP ; <lambda_e1befb086ad3257e3f042a63030725f7>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z
_TEXT	SEGMENT
this$ = 64
_Ptr$ = 72
_Count$ = 80
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append, COMDAT

; 2348 : 		{	// append [_Ptr, _Ptr + _Count)

$LN24:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	49 8b f0	 mov	 rsi, r8

; 2349 : 		auto& _My_data = this->_Get_data();
; 2350 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]

; 2351 : 		if (_Count <= _My_data._Myres - _Old_size)

  00014	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  00018	49 8b c0	 mov	 rax, r8
  0001b	48 2b c1	 sub	 rax, rcx
  0001e	48 3b f0	 cmp	 rsi, rax
  00021	77 40		 ja	 SHORT $LN2@append

; 2352 : 			{
; 2353 : 			_My_data._Mysize = _Old_size + _Count;

  00023	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00028	48 8d 04 31	 lea	 rax, QWORD PTR [rcx+rsi]
  0002c	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00030	48 8b c7	 mov	 rax, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00033	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00037	72 03		 jb	 SHORT $LN11@append
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00039	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN11@append:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2355 : 			_Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);

  0003c	48 8d 1c 08	 lea	 rbx, QWORD PTR [rax+rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00040	4c 8b c6	 mov	 r8, rsi
  00043	48 8b cb	 mov	 rcx, rbx
  00046	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  0004c	c6 04 33 00	 mov	 BYTE PTR [rbx+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2357 : 			return (*this);

  00050	48 8b c7	 mov	 rax, rdi
  00053	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2361 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2363 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2365 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2366 : 			}, _Ptr, _Count));
; 2367 : 		}

  00058	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0005d	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00061	5f		 pop	 rdi
  00062	c3		 ret	 0
$LN2@append:

; 2358 : 			}
; 2359 : 
; 2360 : 		return (_Reallocate_grow_by(_Count,

  00063	4c 8b ca	 mov	 r9, rdx
  00066	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0006b	48 8b d6	 mov	 rdx, rsi
  0006e	48 8b cf	 mov	 rcx, rdi
  00071	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>

; 2361 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {
; 2363 : 			_Traits::copy(_New_ptr, _Old_ptr, _Old_size);
; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
; 2365 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
; 2366 : 			}, _Ptr, _Count));
; 2367 : 		}

  00076	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  0007b	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0007f	5f		 pop	 rdi
  00080	c3		 ret	 0
?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Ptr$ = 80
_Count$ = 88
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z PROC ; <lambda_65e615be2a453ca0576c979606f46740>::operator(), COMDAT

; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	49 8b c0	 mov	 rax, r8
  0000d	48 8b da	 mov	 rbx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00010	48 8b d0	 mov	 rdx, rax
  00013	48 8b cb	 mov	 rcx, rbx
  00016	4d 8b c1	 mov	 r8, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2362 : 				const _Elem * const _Ptr, const size_type _Count) {

  00019	49 8b f9	 mov	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001c	e8 00 00 00 00	 call	 memcpy
  00021	48 8b 54 24 50	 mov	 rdx, QWORD PTR _Ptr$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00026	48 03 fb	 add	 rdi, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00029	48 8b 5c 24 58	 mov	 rbx, QWORD PTR _Count$[rsp]
  0002e	48 8b cf	 mov	 rcx, rdi
  00031	4c 8b c3	 mov	 r8, rbx
  00034	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  00039	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2366 : 			}, _Ptr, _Count));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00046	5f		 pop	 rdi
  00047	c3		 ret	 0
??R<lambda_65e615be2a453ca0576c979606f46740>@@QEBA@QEADQEBD_K12@Z ENDP ; <lambda_65e615be2a453ca0576c979606f46740>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00005	48 8b c2	 mov	 rax, rdx

; 1607 : 		if (_Large_string_engaged())

  00008	72 03		 jb	 SHORT $LN12@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000a	48 8b 02	 mov	 rax, QWORD PTR [rdx]
$LN12@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0000d	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]
  00011	48 8b d0	 mov	 rdx, rax
  00014	e9 00 00 00 00	 jmp	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
??Y?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@AEBV01@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::operator+=
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Right$ = 72
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents, COMDAT

; 2181 : 		{	// assign by copying data stored in _Right

$LN86:
  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	57		 push	 rdi
  00004	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00008	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 2181 : 		{	// assign by copying data stored in _Right

  0000d	48 8b da	 mov	 rbx, rdx

; 2182 : 			// pre: this != &_Right
; 2183 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2184 : 		auto& _My_data = this->_Get_data();
; 2185 : 		auto& _Right_data = _Right._Get_data();
; 2186 : 		const size_type _Right_size = _Right_data._Mysize;

  00010	48 8b 72 10	 mov	 rsi, QWORD PTR [rdx+16]
  00014	48 8b f9	 mov	 rdi, rcx

; 1607 : 		if (_Large_string_engaged())

  00017	72 03		 jb	 SHORT $LN17@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00019	48 8b 1a	 mov	 rbx, QWORD PTR [rdx]
$LN17@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2188 : 		if (_Right_size < this->_BUF_SIZE)

  0001c	48 83 fe 10	 cmp	 rsi, 16
  00020	73 1a		 jae	 SHORT $LN2@Construct_
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00022	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00025	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2191 : 			_My_data._Mysize = _Right_size;

  00028	48 89 71 10	 mov	 QWORD PTR [rcx+16], rsi

; 2192 : 			_My_data._Myres = this->_BUF_SIZE - 1;

  0002c	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15

; 2203 : 		}

  00034	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00038	5f		 pop	 rdi
  00039	5e		 pop	 rsi
  0003a	5b		 pop	 rbx
  0003b	c3		 ret	 0
$LN2@Construct_:

; 2193 : 			return;
; 2194 : 			}
; 2195 : 
; 2196 : 		auto& _Al = this->_Getal();
; 2197 : 		const size_type _New_capacity = _Min_value(_Right_size | this->_ALLOC_MASK, max_size());

  0003c	48 89 6c 24 50	 mov	 QWORD PTR [rsp+80], rbp
  00041	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
  0004b	48 8b ee	 mov	 rbp, rsi
  0004e	48 83 cd 0f	 or	 rbp, 15
  00052	48 3b e8	 cmp	 rbp, rax
  00055	48 0f 47 e8	 cmova	 rbp, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00059	33 c9		 xor	 ecx, ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2198 : 		const pointer _New_array = _Al.allocate(_New_capacity + 1); // throws

  0005b	48 8d 45 01	 lea	 rax, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 52   : 	if (_Count == 0)

  0005f	48 85 c0	 test	 rax, rax
  00062	74 41		 je	 SHORT $LN58@Construct_

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00064	84 c9		 test	 cl, cl
  00066	74 07		 je	 SHORT $LN60@Construct_

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00068	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0006e	cc		 int	 3
$LN60@Construct_:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0006f	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00075	72 23		 jb	 SHORT $LN61@Construct_

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00077	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]

; 72   : 		if (_Block_size <= _User_size)

  0007b	48 3b c8	 cmp	 rcx, rax
  0007e	77 07		 ja	 SHORT $LN62@Construct_

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00086	cc		 int	 3
$LN62@Construct_:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00087	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0008c	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  00090	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00094	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  00098	eb 0b		 jmp	 SHORT $LN58@Construct_
$LN61@Construct_:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0009a	48 8b c8	 mov	 rcx, rax
  0009d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000a2	48 8b c8	 mov	 rcx, rax
$LN58@Construct_:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2200 : 		_Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);

  000a5	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000a9	48 89 0f	 mov	 QWORD PTR [rdi], rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ac	48 8b d3	 mov	 rdx, rbx
  000af	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2202 : 		_My_data._Myres = _New_capacity;

  000b4	48 89 6f 18	 mov	 QWORD PTR [rdi+24], rbp
  000b8	48 8b 6c 24 50	 mov	 rbp, QWORD PTR [rsp+80]
  000bd	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 2203 : 		}

  000c1	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000c5	5f		 pop	 rdi
  000c6	5e		 pop	 rsi
  000c7	5b		 pop	 rbx
  000c8	c3		 ret	 0
$LN85@Construct_:
?_Construct_lv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAXAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Construct_lv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal, COMDAT

; 2132 : 			// pre: this != &_Right
; 2133 : 			// pre: allocator propagation (POCMA) from _Right, if necessary, is complete
; 2134 : 			// pre: *this owns no memory, iterators orphaned (note: _Buf/_Ptr/_Mysize/_Myres may be garbage init)
; 2135 : 		auto& _Right_data = _Right._Get_data();
; 2136 : 
; 2137 : #if _ITERATOR_DEBUG_LEVEL != 0
; 2138 : 		if (_Right_data._Large_string_engaged())
; 2139 : 			{	// take ownership of _Right's iterators along with its buffer
; 2140 : 			this->_Swap_all(_Right);
; 2141 : 			}
; 2142 : 		else
; 2143 : 			{
; 2144 : 			_Right._Orphan_all();
; 2145 : 			}
; 2146 : #endif /* _ITERATOR_DEBUG_LEVEL != 0 */
; 2147 : 
; 2148 : 		const auto _My_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(this->_Get_data()))
; 2149 : 			+ _Memcpy_move_offset;
; 2150 : 		const auto _Right_data_mem = reinterpret_cast<unsigned char *>(_STD addressof(_Right_data))
; 2151 : 			+ _Memcpy_move_offset;
; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00003	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00006	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0000a	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  0000e	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001e	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2154 : 		}

  00021	c3		 ret	 0
?_Assign_rv_contents_with_alloc_always_equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents_with_alloc_always_equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
this$ = 8
_Right$ = 16
__formal$dead$ = 24
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents, COMDAT

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00000	0f 10 02	 movups	 xmm0, XMMWORD PTR [rdx]
  00003	0f 11 01	 movups	 XMMWORD PTR [rcx], xmm0
  00006	0f 10 4a 10	 movups	 xmm1, XMMWORD PTR [rdx+16]
  0000a	0f 11 49 10	 movups	 XMMWORD PTR [rcx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  0000e	48 c7 42 10 00
	00 00 00	 mov	 QWORD PTR [rdx+16], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00016	48 c7 42 18 0f
	00 00 00	 mov	 QWORD PTR [rdx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0001e	c6 02 00	 mov	 BYTE PTR [rdx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2113 : 		}

  00021	c3		 ret	 0
?_Assign_rv_contents@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX$$QEAV12@U?$integral_constant@_N$00@2@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Assign_rv_contents
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 48
_Right$dead$ = 56
_Roff$dead$ = 64
_Count$dead$ = 72
_Al$dead$ = 80
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 1955 : 		{	// construct from _Right [_Roff, _Roff + _Count)

$LN77:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3698 : 		_My_data._Mysize = 0;

  00006	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1955 : 		{	// construct from _Right [_Roff, _Roff + _Count)

  0000e	48 8b d9	 mov	 rbx, rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00011	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1622 : 		if (_Mysize < _Off)

  0001c	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00023	48 83 f8 05	 cmp	 rax, 5
  00027	0f 82 89 00 00
	00		 jb	 $LN75@basic_stri

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0002d	48 83 c0 fb	 add	 rax, -5
  00031	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00036	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0003a	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00041	48 3b c7	 cmp	 rax, rdi
  00044	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00048	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2435 : 		if (_Count <= _My_data._Myres)

  00050	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 1607 : 		if (_Large_string_engaged())

  00054	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0005c	49 83 c1 05	 add	 r9, 5

; 2435 : 		if (_Count <= _My_data._Myres)

  00060	48 3b f8	 cmp	 rdi, rax
  00063	77 3b		 ja	 SHORT $LN52@basic_stri

; 1595 : 		value_type * _Result = _Bx._Buf;

  00065	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  0006a	48 8b f1	 mov	 rsi, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0006d	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  00071	72 03		 jb	 SHORT $LN61@basic_stri
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00073	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN61@basic_stri:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00076	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0007a	4c 8b c7	 mov	 r8, rdi
  0007d	48 8b ce	 mov	 rcx, rsi
  00080	49 8b d1	 mov	 rdx, r9
  00083	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00089	c6 04 3e 00	 mov	 BYTE PTR [rsi+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1958 : 		}

  0008d	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00090	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1958 : 		}

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  0009a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009e	5b		 pop	 rbx
  0009f	c3		 ret	 0
$LN52@basic_stri:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 1958 : 		}

  000a8	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]
  000ad	48 8b c3	 mov	 rax, rbx
  000b0	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000b4	5b		 pop	 rbx
  000b5	c3		 ret	 0
$LN75@basic_stri:

; 1624 : 			_Xran();

  000b6	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000bb	cc		 int	 3
$LN74@basic_stri:
??0?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@AEBV01@_K1AEBV?$allocator@D@1@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::basic_string<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back, COMDAT

; 723  : 		{	// set up putback area

  00000	4c 8b c1	 mov	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00003	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 724  : 		if (_Mysb::eback() != &_Mychar)

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000a	4d 8d 48 70	 lea	 r9, QWORD PTR [r8+112]
  0000e	49 3b c1	 cmp	 rax, r9
  00011	74 1c		 je	 SHORT $LN2@Set_back

; 725  : 			{	// save current get buffer
; 726  : 			_Set_eback = _Mysb::eback();

  00013	49 89 80 88 00
	00 00		 mov	 QWORD PTR [r8+136], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  0001a	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  0001e	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00021	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00025	48 03 10	 add	 rdx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 727  : 			_Set_egptr = _Mysb::egptr();

  00028	49 89 90 90 00
	00 00		 mov	 QWORD PTR [r8+144], rdx
$LN2@Set_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0002f	4c 89 09	 mov	 QWORD PTR [rcx], r9

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  00032	41 8b c8	 mov	 ecx, r8d
  00035	49 8b 40 38	 mov	 rax, QWORD PTR [r8+56]
  00039	41 2b c9	 sub	 ecx, r9d
  0003c	83 c1 71	 add	 ecx, 113		; 00000071H
  0003f	4c 89 08	 mov	 QWORD PTR [rax], r9
  00042	49 8b 40 50	 mov	 rax, QWORD PTR [r8+80]
  00046	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 730  : 		}

  00048	c3		 ret	 0
?_Set_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Set_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ
_TEXT	SEGMENT
this$ = 8
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  00000	4c 8b 49 18	 mov	 r9, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 718  : 		if (_Mysb::eback() == &_Mychar)

  00004	48 8d 41 70	 lea	 rax, QWORD PTR [rcx+112]
  00008	49 39 01	 cmp	 QWORD PTR [r9], rax
  0000b	75 22		 jne	 SHORT $LN2@Reset_back

; 719  : 			_Mysb::setg(_Set_eback, _Set_eback, _Set_egptr);

  0000d	48 8b 91 88 00
	00 00		 mov	 rdx, QWORD PTR [rcx+136]
  00014	4c 8b 81 90 00
	00 00		 mov	 r8, QWORD PTR [rcx+144]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0001b	49 89 11	 mov	 QWORD PTR [r9], rdx

; 253  : 		*_IGnext = _Next;
; 254  : 		*_IGcount = (int)(_Last - _Next);

  0001e	44 2b c2	 sub	 r8d, edx
  00021	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
  00025	48 89 10	 mov	 QWORD PTR [rax], rdx
  00028	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
  0002c	44 89 00	 mov	 DWORD PTR [rax], r8d
$LN2@Reset_back:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 720  : 		}

  0002f	c3		 ret	 0
?_Reset_back@?$basic_filebuf@DU?$char_traits@D@std@@@std@@AEAAXXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Reset_back
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z
_TEXT	SEGMENT
this$ = 48
_Newpcvt$ = 56
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt, COMDAT

; 698  : 		{	// initialize codecvt pointer

$LN12:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b fa	 mov	 rdi, rdx

; 699  : 		if (_Newpcvt->always_noconv())

  00010	48 8b ca	 mov	 rcx, rdx
  00013	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00019	84 c0		 test	 al, al
  0001b	74 13		 je	 SHORT $LN2@Initcvt

; 700  : 			_Pcvt = 0;	// nothing to do

  0001d	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 705  : 			}
; 706  : 		}

  00025	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0002a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002e	5f		 pop	 rdi
  0002f	c3		 ret	 0
$LN2@Initcvt:

; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering

  00030	48 8b cb	 mov	 rcx, rbx
  00033	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 705  : 			}
; 706  : 		}

  00037	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0003c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00040	5f		 pop	 rdi

; 701  : 		else
; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;
; 704  : 			_Mysb::_Init();	// reset any buffering

  00041	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
?_Initcvt@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEBV?$codecvt@DDU_Mbstatet@@@2@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Initcvt
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ
_TEXT	SEGMENT
$T57 = 48
_Dest$58 = 56
_Str$59 = 64
__$ArrayPad$ = 96
this$ = 128
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite, COMDAT

; 657  : 		{	// put shift to initial conversion state, as needed

$LN454:
  00000	48 8b c4	 mov	 rax, rsp
  00003	55		 push	 rbp
  00004	48 8b ec	 mov	 rbp, rsp
  00007	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  0000b	48 c7 45 c0 fe
	ff ff ff	 mov	 QWORD PTR $T57[rbp-112], -2
  00013	48 89 58 10	 mov	 QWORD PTR [rax+16], rbx
  00017	48 89 70 18	 mov	 QWORD PTR [rax+24], rsi
  0001b	48 89 78 20	 mov	 QWORD PTR [rax+32], rdi
  0001f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00026	48 33 c4	 xor	 rax, rsp
  00029	48 89 45 f0	 mov	 QWORD PTR __$ArrayPad$[rbp-112], rax
  0002d	48 8b f9	 mov	 rdi, rcx

; 658  : 		if (_Pcvt == 0 || !_Wrotesome)

  00030	48 83 79 68 00	 cmp	 QWORD PTR [rcx+104], 0
  00035	0f 84 90 01 00
	00		 je	 $LN9@Endwrite
  0003b	80 79 71 00	 cmp	 BYTE PTR [rcx+113], 0
  0003f	0f 84 86 01 00
	00		 je	 $LN9@Endwrite

; 660  : 		else
; 661  : 			{	// may have to put
; 662  : 			const int _STRING_INC = 8;
; 663  : 			char *_Dest;
; 664  : 			if (_Traits::eq_int_type(_Traits::eof(), overflow()))

  00045	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00048	83 ca ff	 or	 edx, -1
  0004b	ff 50 18	 call	 QWORD PTR [rax+24]
  0004e	83 f8 ff	 cmp	 eax, -1
  00051	75 07		 jne	 SHORT $LN10@Endwrite

; 665  : 				return (false);

  00053	32 c0		 xor	 al, al
  00055	e9 73 01 00 00	 jmp	 $LN399@Endwrite
$LN10@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0005a	48 c7 45 e0 00
	00 00 00	 mov	 QWORD PTR _Str$59[rbp-96], 0

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00062	48 c7 45 e8 0f
	00 00 00	 mov	 QWORD PTR _Str$59[rbp-88], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0006a	c6 45 d0 00	 mov	 BYTE PTR _Str$59[rbp-112], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1993 : 		assign(_Count, _Ch);

  0006e	48 8d 4d d0	 lea	 rcx, QWORD PTR _Str$59[rbp-112]
  00072	e8 00 00 00 00	 call	 ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
  00077	90		 npad	 1
$LN452@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 667  : 			string _Str(_STRING_INC, '\0');

  00078	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$59[rbp-88]
  0007c	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$59[rbp-112]
$LL2@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  00080	48 8d 55 d0	 lea	 rdx, QWORD PTR _Str$59[rbp-112]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00084	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00088	48 0f 43 d1	 cmovae	 rdx, rcx

; 1595 : 		value_type * _Result = _Bx._Buf;

  0008c	4c 8d 45 d0	 lea	 r8, QWORD PTR _Str$59[rbp-112]

; 1596 : 		if (_Large_string_engaged())

  00090	4c 0f 43 c1	 cmovae	 r8, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 669  : 				switch (_Pcvt->unshift(_State,

  00094	4c 8b 4d e0	 mov	 r9, QWORD PTR _Str$59[rbp-96]
  00098	4c 03 ca	 add	 r9, rdx
  0009b	48 8d 45 c8	 lea	 rax, QWORD PTR _Dest$58[rbp-112]
  0009f	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  000a4	48 8d 57 74	 lea	 rdx, QWORD PTR [rdi+116]
  000a8	48 8b 4f 68	 mov	 rcx, QWORD PTR [rdi+104]
  000ac	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?unshift@?$codecvt@DDU_Mbstatet@@@std@@QEBAHAEAU_Mbstatet@@PEAD1AEAPEAD@Z
  000b2	85 c0		 test	 eax, eax
  000b4	74 0b		 je	 SHORT $LN11@Endwrite
  000b6	83 e8 01	 sub	 eax, 1
  000b9	0f 85 b5 00 00
	00		 jne	 $LN450@Endwrite
  000bf	eb 04		 jmp	 SHORT $LN12@Endwrite
$LN11@Endwrite:

; 670  : 					&*_Str.begin(), &*_Str.begin() + _Str.size(), _Dest))
; 671  : 				{	// test result of homing conversion
; 672  : 				case codecvt_base::ok:
; 673  : 					_Wrotesome = false;	// homed successfully

  000c1	c6 47 71 00	 mov	 BYTE PTR [rdi+113], 0
$LN12@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  000c5	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$59[rbp-112]

; 1596 : 		if (_Large_string_engaged())

  000c9	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$59[rbp-112]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000cd	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$59[rbp-88]
  000d1	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  000d5	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 677  : 					size_t _Count = _Dest - &*_Str.begin();

  000d9	48 8b 5d c8	 mov	 rbx, QWORD PTR _Dest$58[rbp-112]
  000dd	48 2b d8	 sub	 rbx, rax

; 678  : 					if (0 < _Count && _Count !=

  000e0	74 31		 je	 SHORT $LN13@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1595 : 		value_type * _Result = _Bx._Buf;

  000e2	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$59[rbp-112]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e6	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  000ea	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 678  : 					if (0 < _Count && _Count !=

  000ee	4c 8b 8f 80 00
	00 00		 mov	 r9, QWORD PTR [rdi+128]
  000f5	4c 8b c3	 mov	 r8, rbx
  000f8	ba 01 00 00 00	 mov	 edx, 1
  000fd	48 8b c8	 mov	 rcx, rax
  00100	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00106	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$59[rbp-88]
  0010a	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$59[rbp-112]
  0010e	48 3b d8	 cmp	 rbx, rax
  00111	75 6e		 jne	 SHORT $LN445@Endwrite
$LN13@Endwrite:
$_Invalid_parameter$455:

; 679  : 						fwrite(&*_Str.begin(), 1, _Count, _Myfile))
; 680  : 						return (false);	// write failed
; 681  : 					if (!_Wrotesome)

  00113	80 7f 71 00	 cmp	 BYTE PTR [rdi+113], 0
  00117	74 6c		 je	 SHORT $LN446@Endwrite
$_Invalid_parameter$456:

; 683  : 					if (_Count == 0)

  00119	48 85 db	 test	 rbx, rbx
  0011c	0f 85 5e ff ff
	ff		 jne	 $LL2@Endwrite
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  00122	48 8b 55 e0	 mov	 rdx, QWORD PTR _Str$59[rbp-96]
  00126	4c 8b c2	 mov	 r8, rdx

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  00129	49 8b c1	 mov	 rax, r9
  0012c	48 2b c2	 sub	 rax, rdx
  0012f	48 83 f8 08	 cmp	 rax, 8
  00133	72 24		 jb	 SHORT $LN285@Endwrite

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  00135	48 83 c2 08	 add	 rdx, 8
  00139	48 89 55 e0	 mov	 QWORD PTR _Str$59[rbp-96], rdx

; 1595 : 		value_type * _Result = _Bx._Buf;

  0013d	48 8d 45 d0	 lea	 rax, QWORD PTR _Str$59[rbp-112]

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00141	49 83 f9 10	 cmp	 r9, 16

; 1596 : 		if (_Large_string_engaged())

  00145	48 0f 43 c1	 cmovae	 rax, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00149	33 c9		 xor	 ecx, ecx
  0014b	4a 89 0c 00	 mov	 QWORD PTR [rax+r8], rcx

; 517  : 		_Left = _Right;

  0014f	42 88 4c 00 08	 mov	 BYTE PTR [rax+r8+8], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  00154	e9 1f ff ff ff	 jmp	 $LN452@Endwrite
$LN285@Endwrite:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00159	c6 44 24 20 00	 mov	 BYTE PTR [rsp+32], 0
  0015e	ba 08 00 00 00	 mov	 edx, 8
  00163	44 8b ca	 mov	 r9d, edx
  00166	48 8d 4d d0	 lea	 rcx, QWORD PTR _Str$59[rbp-112]
  0016a	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 693  : 				}

  0016f	e9 04 ff ff ff	 jmp	 $LN452@Endwrite
$LN450@Endwrite:

; 669  : 				switch (_Pcvt->unshift(_State,

  00174	83 e8 02	 sub	 eax, 2

; 692  : 					return (false);	// conversion failed

  00177	4c 8b 4d e8	 mov	 r9, QWORD PTR _Str$59[rbp-88]
  0017b	48 8b 4d d0	 mov	 rcx, QWORD PTR _Str$59[rbp-112]

; 669  : 				switch (_Pcvt->unshift(_State,

  0017f	74 04		 je	 SHORT $LN446@Endwrite
$_Invalid_parameter$457:
$LN445@Endwrite:
  00181	32 db		 xor	 bl, bl
  00183	eb 02		 jmp	 SHORT $LN22@Endwrite
$LN446@Endwrite:

; 682  : 						return (true);

  00185	b3 01		 mov	 bl, 1
$LN22@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00187	49 83 f9 10	 cmp	 r9, 16

; 3709 : 		if (_My_data._Large_string_engaged())

  0018b	72 39		 jb	 SHORT $LN379@Endwrite

; 3710 : 			{
; 3711 : 			const pointer _Ptr = _My_data._Bx._Ptr;
; 3712 : 			auto& _Al = this->_Getal();
; 3713 : 			_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3714 : 			_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0018d	49 8d 41 01	 lea	 rax, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00191	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00197	72 28		 jb	 SHORT $LN382@Endwrite

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00199	f6 45 d0 1f	 test	 BYTE PTR _Str$59[rbp-112], 31
  0019d	75 1b		 jne	 SHORT $_Invalid_parameter$458

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0019f	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  001a3	48 3b c1	 cmp	 rax, rcx
  001a6	73 12		 jae	 SHORT $_Invalid_parameter$458
  001a8	48 2b c8	 sub	 rcx, rax
  001ab	48 83 e9 08	 sub	 rcx, 8
  001af	48 83 f9 1f	 cmp	 rcx, 31
  001b3	77 05		 ja	 SHORT $_Invalid_parameter$458

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  001b5	48 8b c8	 mov	 rcx, rax
  001b8	eb 07		 jmp	 SHORT $LN382@Endwrite
$_Invalid_parameter$458:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  001ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  001c0	cc		 int	 3
$LN382@Endwrite:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  001c1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN379@Endwrite:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 692  : 					return (false);	// conversion failed

  001c6	0f b6 c3	 movzx	 eax, bl
  001c9	eb 02		 jmp	 SHORT $LN399@Endwrite
$LN9@Endwrite:

; 659  : 			return (true);

  001cb	b0 01		 mov	 al, 1
$LN399@Endwrite:

; 694  : 			}
; 695  : 		}

  001cd	48 8b 4d f0	 mov	 rcx, QWORD PTR __$ArrayPad$[rbp-112]
  001d1	48 33 cc	 xor	 rcx, rsp
  001d4	e8 00 00 00 00	 call	 __security_check_cookie
  001d9	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001de	49 8b 5b 18	 mov	 rbx, QWORD PTR [r11+24]
  001e2	49 8b 73 20	 mov	 rsi, QWORD PTR [r11+32]
  001e6	49 8b 7b 28	 mov	 rdi, QWORD PTR [r11+40]
  001ea	49 8b e3	 mov	 rsp, r11
  001ed	5d		 pop	 rbp
  001ee	c3		 ret	 0
$LN451@Endwrite:
?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T57 = 48
_Dest$58 = 56
_Str$59 = 64
__$ArrayPad$ = 96
this$ = 128
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Str$59[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T57 = 48
_Dest$58 = 56
_Str$59 = 64
__$ArrayPad$ = 96
this$ = 128
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Str$59[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
?dtor$0@?0??_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::_Endwrite'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z
_TEXT	SEGMENT
_Pb$1 = 32
_Pn$2 = 40
_Nr$3 = 48
__$ArrayPad$ = 56
this$ = 80
_File$ = 88
_Which$ = 96
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::_Init, COMDAT

; 622  : 		{	// initialize to C stream _File after {new, open, close}

$LN13:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 74 24 20	 mov	 QWORD PTR [rsp+32], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  0000f	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00016	48 33 c4	 xor	 rax, rsp
  00019	48 89 44 24 38	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 623  : 		__PURE_APPDOMAIN_GLOBAL static _Myst _Stinit;	// initial state
; 624  : 
; 625  : 		_Closef = _Which == _Openfl;

  0001e	41 83 f8 01	 cmp	 r8d, 1

; 626  : 		_Wrotesome = false;

  00022	c6 41 71 00	 mov	 BYTE PTR [rcx+113], 0
  00026	48 8b fa	 mov	 rdi, rdx
  00029	48 8b d9	 mov	 rbx, rcx
  0002c	0f 94 c0	 sete	 al
  0002f	88 41 7c	 mov	 BYTE PTR [rcx+124], al

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00032	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)

  00038	33 f6		 xor	 esi, esi
  0003a	48 85 ff	 test	 rdi, rdi
  0003d	74 4e		 je	 SHORT $LN2@Init

; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(

  0003f	4c 8d 4c 24 30	 lea	 r9, QWORD PTR _Nr$3[rsp]
  00044	48 89 74 24 20	 mov	 QWORD PTR _Pb$1[rsp], rsi
  00049	4c 8d 44 24 28	 lea	 r8, QWORD PTR _Pn$2[rsp]
  0004e	48 89 74 24 28	 mov	 QWORD PTR _Pn$2[rsp], rsi
  00053	48 8d 54 24 20	 lea	 rdx, QWORD PTR _Pb$1[rsp]
  00058	48 89 74 24 30	 mov	 QWORD PTR _Nr$3[rsp], rsi
  0005d	48 8b cf	 mov	 rcx, rdi
  00060	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__get_stream_buffer_pointers
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 331  : 		_IGfirst = _Gf;

  00066	48 8b 44 24 20	 mov	 rax, QWORD PTR _Pb$1[rsp]
  0006b	48 89 43 18	 mov	 QWORD PTR [rbx+24], rax

; 332  : 		_IPfirst = _Pf;

  0006f	48 89 43 20	 mov	 QWORD PTR [rbx+32], rax

; 333  : 		_IGnext = _Gn;

  00073	48 8b 44 24 28	 mov	 rax, QWORD PTR _Pn$2[rsp]
  00078	48 89 43 38	 mov	 QWORD PTR [rbx+56], rax

; 334  : 		_IPnext = _Pn;

  0007c	48 89 43 40	 mov	 QWORD PTR [rbx+64], rax

; 335  : 		_IGcount = _Gc;

  00080	48 8b 44 24 30	 mov	 rax, QWORD PTR _Nr$3[rsp]
  00085	48 89 43 50	 mov	 QWORD PTR [rbx+80], rax

; 336  : 		_IPcount = _Pc;

  00089	48 89 43 58	 mov	 QWORD PTR [rbx+88], rax
$LN2@Init:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 652  : 		_State = _Stinit;

  0008d	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00094	48 89 43 74	 mov	 QWORD PTR [rbx+116], rax
  00098	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0009f	48 89 73 68	 mov	 QWORD PTR [rbx+104], rsi

; 654  : 		}

  000a3	48 8b 4c 24 38	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000a8	48 33 cc	 xor	 rcx, rsp
  000ab	e8 00 00 00 00	 call	 __security_check_cookie
  000b0	48 8b 5c 24 60	 mov	 rbx, QWORD PTR [rsp+96]
  000b5	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
  000ba	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000be	5f		 pop	 rdi
  000bf	c3		 ret	 0
?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ
_TEXT	SEGMENT
this$ = 48
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ PROC ; std::basic_filebuf<char,std::char_traits<char> >::close, COMDAT

; 359  : 		{	// close the C stream

$LN19:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 360  : 		_Myt *_Ans = this;
; 361  : 		if (_Myfile == 0)

  0000f	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00017	48 8b d9	 mov	 rbx, rcx
  0001a	75 06		 jne	 SHORT $LN2@close

; 362  : 			_Ans = 0;

  0001c	33 ff		 xor	 edi, edi
  0001e	8b f7		 mov	 esi, edi

; 363  : 		else

  00020	eb 23		 jmp	 SHORT $LN5@close
$LN2@close:

; 364  : 			{	// put any homing sequence and close file
; 365  : 			if (!_Endwrite())

  00022	e8 00 00 00 00	 call	 ?_Endwrite@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAA_NXZ ; std::basic_filebuf<char,std::char_traits<char> >::_Endwrite

; 366  : 				_Ans = 0;
; 367  : 			if (fclose(_Myfile) != 0)

  00027	48 8b 8b 80 00
	00 00		 mov	 rcx, QWORD PTR [rbx+128]
  0002e	33 ff		 xor	 edi, edi
  00030	84 c0		 test	 al, al
  00032	48 8b f3	 mov	 rsi, rbx
  00035	48 0f 44 f7	 cmove	 rsi, rdi
  00039	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  0003f	85 c0		 test	 eax, eax
  00041	48 0f 45 f7	 cmovne	 rsi, rdi
$LN5@close:

; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00045	48 8b cb	 mov	 rcx, rbx
  00048	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0
  0004c	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0
  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;
; 652  : 		_State = _Stinit;

  00056	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit

; 368  : 				_Ans = 0;
; 369  : 			}
; 370  : 		_Init(0, _Closefl);
; 371  : 		return (_Ans);

  0005d	48 8b c6	 mov	 rax, rsi

; 372  : 		}

  00060	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 652  : 		_State = _Stinit;

  00065	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx
  00069	48 89 bb 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rdi

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  00070	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 372  : 		}

  00074	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  00079	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007d	5f		 pop	 rdi
  0007e	c3		 ret	 0
?close@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@XZ ENDP ; std::basic_filebuf<char,std::char_traits<char> >::close
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z
_TEXT	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::open, COMDAT

; 275  : 		{	// open a C stream with specified mode

$LN22:
  00000	40 57		 push	 rdi
  00002	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T4[rsp], -2
  0000f	48 89 5c 24 50	 mov	 QWORD PTR [rsp+80], rbx
  00014	41 8b c0	 mov	 eax, r8d
  00017	4c 8b ca	 mov	 r9, rdx
  0001a	48 8b d9	 mov	 rbx, rcx

; 276  : 		_Filet *_File;
; 277  : 		if (_Myfile != 0 || (_File = _Fiopen(_Filename, _Mode, _Prot)) == 0)

  0001d	48 83 b9 80 00
	00 00 00	 cmp	 QWORD PTR [rcx+128], 0
  00025	0f 85 8f 00 00
	00		 jne	 $LN3@open
  0002b	41 b8 40 00 00
	00		 mov	 r8d, 64			; 00000040H
  00031	8b d0		 mov	 edx, eax
  00033	49 8b c9	 mov	 rcx, r9
  00036	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Fiopen@std@@YAPEAU_iobuf@@PEBDHH@Z
  0003c	48 85 c0	 test	 rax, rax
  0003f	74 79		 je	 SHORT $LN3@open

; 279  : 
; 280  : 		_Init(_File, _Openfl);

  00041	41 b8 01 00 00
	00		 mov	 r8d, 1
  00047	48 8b d0	 mov	 rdx, rax
  0004a	48 8b cb	 mov	 rcx, rbx
  0004d	e8 00 00 00 00	 call	 ?_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@12@@Z ; std::basic_filebuf<char,std::char_traits<char> >::_Init

; 281  : 		_Initcvt(&_USE(_Mysb::getloc(), _Cvt));

  00052	48 8d 54 24 28	 lea	 rdx, QWORD PTR $T1[rsp]
  00057	48 8b cb	 mov	 rcx, rbx
  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEBA?AVlocale@2@XZ
  00060	90		 npad	 1
  00061	48 8b c8	 mov	 rcx, rax
  00064	e8 00 00 00 00	 call	 ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
  00069	48 8b f8	 mov	 rdi, rax

; 699  : 		if (_Newpcvt->always_noconv())

  0006c	48 8b c8	 mov	 rcx, rax
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?always_noconv@codecvt_base@std@@QEBA_NXZ
  00075	84 c0		 test	 al, al
  00077	74 0a		 je	 SHORT $LN7@open

; 700  : 			_Pcvt = 0;	// nothing to do

  00079	48 c7 43 68 00
	00 00 00	 mov	 QWORD PTR [rbx+104], 0

; 701  : 		else

  00081	eb 0e		 jmp	 SHORT $LN8@open
$LN7@open:

; 702  : 			{	// set up for nontrivial codecvt facet
; 703  : 			_Pcvt = _Newpcvt;

  00083	48 89 7b 68	 mov	 QWORD PTR [rbx+104], rdi

; 704  : 			_Mysb::_Init();	// reset any buffering

  00087	48 8b cb	 mov	 rcx, rbx
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ
  00090	90		 npad	 1
$LN8@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 404  : 		if (_Ptr != 0)

  00091	48 8b 4c 24 30	 mov	 rcx, QWORD PTR $T1[rsp+8]
  00096	48 85 c9	 test	 rcx, rcx
  00099	74 1a		 je	 SHORT $LN19@open

; 405  : 			delete _Ptr->_Decref();

  0009b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0009e	ff 50 10	 call	 QWORD PTR [rax+16]
  000a1	48 85 c0	 test	 rax, rax
  000a4	74 0f		 je	 SHORT $LN19@open
  000a6	4c 8b 00	 mov	 r8, QWORD PTR [rax]
  000a9	ba 01 00 00 00	 mov	 edx, 1
  000ae	48 8b c8	 mov	 rcx, rax
  000b1	41 ff 10	 call	 QWORD PTR [r8]
  000b4	90		 npad	 1
$LN19@open:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream

; 282  : 		return (this);	// open succeeded

  000b5	48 8b c3	 mov	 rax, rbx
  000b8	eb 02		 jmp	 SHORT $LN1@open
$LN3@open:

; 278  : 			return (0);	// open failed

  000ba	33 c0		 xor	 eax, eax
$LN1@open:

; 283  : 		}

  000bc	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c1	48 83 c4 40	 add	 rsp, 64			; 00000040H
  000c5	5f		 pop	 rdi
  000c6	c3		 ret	 0
?open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::open
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T4 = 32
$T1 = 40
this$ = 80
_Filename$ = 88
_Mode$ = 96
_Prot$dead$ = 104
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR $T1[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$0@?0??open@?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAAPEAV12@PEBDHH@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::open'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\fstream
;	COMDAT ??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z
_TEXT	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z PROC ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >, COMDAT

; 156  : 		{	// construct from pointer to C stream

$LN15:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T1[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx
  00012	48 89 4c 24 28	 mov	 QWORD PTR this$GSCopy$[rsp], rcx

; 155  : 		: _Mysb()

  00017	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  0001d	90		 npad	 1

; 156  : 		{	// construct from pointer to C stream

  0001e	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_filebuf@DU?$char_traits@D@std@@@std@@6B@
  00025	48 89 03	 mov	 QWORD PTR [rbx], rax

; 625  : 		_Closef = _Which == _Openfl;

  00028	c6 43 7c 00	 mov	 BYTE PTR [rbx+124], 0

; 626  : 		_Wrotesome = false;

  0002c	c6 43 71 00	 mov	 BYTE PTR [rbx+113], 0

; 627  : 
; 628  : 		_Mysb::_Init();	// initialize stream buffer base object

  00030	48 8b cb	 mov	 rcx, rbx
  00033	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Init@?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAAXXZ

; 629  : 
; 630  :  #ifndef _IORCNT
; 631  :   #define _IORCNT	_IOCNT	/* read and write counts are the same */
; 632  :   #define _IOWCNT _IOCNT
; 633  :  #endif /* _IORCNT */
; 634  : 
; 635  : 		if (_File != 0 && sizeof (_Elem) == 1)
; 636  : 			{	// point inside C stream with [first, first + count) buffer
; 637  : 			_Elem **_Pb = 0;
; 638  : 			_Elem **_Pn = 0;
; 639  : 			int *_Nr = 0;
; 640  : 
; 641  : 			::_get_stream_buffer_pointers(
; 642  : 				_File,
; 643  : 				reinterpret_cast<char***>(&_Pb),
; 644  : 				reinterpret_cast<char***>(&_Pn),
; 645  : 				&_Nr);
; 646  : 			int *_Nw = _Nr;
; 647  : 
; 648  : 			_Mysb::_Init(_Pb, _Pn, _Nr, _Pb, _Pn, _Nw);
; 649  : 			}
; 650  : 
; 651  : 		_Myfile = _File;

  00039	33 c0		 xor	 eax, eax
  0003b	48 89 83 80 00
	00 00		 mov	 QWORD PTR [rbx+128], rax

; 652  : 		_State = _Stinit;

  00042	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR ?_Stinit@?1??_Init@?$basic_filebuf@DU?$char_traits@D@std@@@std@@IEAAXPEAU_iobuf@@W4_Initfl@23@@Z@4U_Mbstatet@@A ; `std::basic_filebuf<char,std::char_traits<char> >::_Init'::`2'::_Stinit
  00049	48 89 4b 74	 mov	 QWORD PTR [rbx+116], rcx

; 653  : 		_Pcvt = 0;	// pointer to codecvt facet

  0004d	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 157  : 		_Init(_File, _Newfl);
; 158  : 		}

  00051	48 8b c3	 mov	 rax, rbx
  00054	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00058	5b		 pop	 rbx
  00059	c3		 ret	 0
??0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z ENDP ; std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
this$GSCopy$ = 40
this$ = 64
_File$dead$ = 72
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA PROC ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
  00000	48 8b 8a 28 00
	00 00		 mov	 rcx, QWORD PTR this$GSCopy$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_filebuf@DU?$char_traits@D@std@@@std@@QEAA@PEAU_iobuf@@@Z@4HA ENDP ; `std::basic_filebuf<char,std::char_traits<char> >::basic_filebuf<char,std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ
_TEXT	SEGMENT
this$ = 48
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy, COMDAT

; 337  : 		{	// discard any allocated buffer and clear pointers

$LN45:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 338  : 		if (_Mystate & _Allocated)

  00006	f6 41 70 01	 test	 BYTE PTR [rcx+112], 1
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	74 5c		 je	 SHORT $LN23@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  0000f	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00013	48 8b 08	 mov	 rcx, QWORD PTR [rax]
  00016	48 85 c9	 test	 rcx, rcx
  00019	74 0c		 je	 SHORT $LN4@Tidy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 259  : 		return (*_IPnext + *_IPcount);

  0001b	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  0001f	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  00022	48 03 d1	 add	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  00025	eb 0e		 jmp	 SHORT $LN5@Tidy
$LN4@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 241  : 		return (*_IGnext + *_IGcount);

  00027	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0002b	48 63 10	 movsxd	 rdx, DWORD PTR [rax]
  0002e	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00032	48 03 10	 add	 rdx, QWORD PTR [rax]
$LN5@Tidy:

; 221  : 		return (*_IGfirst);

  00035	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  00039	48 8b 08	 mov	 rcx, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 339  : 			_Al.deallocate(pointer_traits<_Ptrty>::pointer_to(*_Mysb::eback()),

  0003c	48 2b d1	 sub	 rdx, rcx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0003f	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  00046	72 1e		 jb	 SHORT $LN26@Tidy

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00048	f6 c1 1f	 test	 cl, 31
  0004b	75 56		 jne	 SHORT $_Invalid_parameter$46

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  0004d	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00051	48 3b c1	 cmp	 rax, rcx
  00054	73 4d		 jae	 SHORT $_Invalid_parameter$46
  00056	48 2b c8	 sub	 rcx, rax
  00059	48 83 e9 08	 sub	 rcx, 8
  0005d	48 83 f9 1f	 cmp	 rcx, 31
  00061	77 40		 ja	 SHORT $_Invalid_parameter$46

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00063	48 8b c8	 mov	 rcx, rax
$LN26@Tidy:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00066	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN23@Tidy:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 252  : 		*_IGfirst = _First;

  0006b	48 8b 43 18	 mov	 rax, QWORD PTR [rbx+24]
  0006f	33 c9		 xor	 ecx, ecx
  00071	48 89 08	 mov	 QWORD PTR [rax], rcx

; 253  : 		*_IGnext = _Next;

  00074	48 8b 43 38	 mov	 rax, QWORD PTR [rbx+56]
  00078	48 89 08	 mov	 QWORD PTR [rax], rcx

; 254  : 		*_IGcount = (int)(_Last - _Next);

  0007b	48 8b 43 50	 mov	 rax, QWORD PTR [rbx+80]
  0007f	89 08		 mov	 DWORD PTR [rax], ecx

; 293  : 		*_IPfirst = _First;

  00081	48 8b 43 20	 mov	 rax, QWORD PTR [rbx+32]
  00085	48 89 08	 mov	 QWORD PTR [rax], rcx

; 294  : 		*_IPnext = _First;

  00088	48 8b 43 40	 mov	 rax, QWORD PTR [rbx+64]
  0008c	48 89 08	 mov	 QWORD PTR [rax], rcx

; 295  : 		*_IPcount = (int)(_Last - _First);

  0008f	48 8b 43 58	 mov	 rax, QWORD PTR [rbx+88]
  00093	89 08		 mov	 DWORD PTR [rax], ecx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 345  : 		_Mystate &= ~_Allocated;

  00095	83 63 70 fe	 and	 DWORD PTR [rbx+112], -2
  00099	48 89 4b 68	 mov	 QWORD PTR [rbx+104], rcx

; 346  : 		}

  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
$_Invalid_parameter$46:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000a3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000a9	cc		 int	 3
$LN44@Tidy:
?_Tidy@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXXZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Tidy
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ
_TEXT	SEGMENT
_Nul$68 = 32
_Str$69 = 32
_Str$70 = 32
__$ArrayPad$ = 64
this$ = 96
__$ReturnUdt$ = 104
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str, COMDAT

; 93   : 		{	// return string copy of character array

$LN458:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  0000a	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  00011	48 33 c4	 xor	 rax, rsp
  00014	48 89 44 24 40	 mov	 QWORD PTR __$ArrayPad$[rsp], rax

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  00019	44 8b 41 70	 mov	 r8d, DWORD PTR [rcx+112]
  0001d	48 8b da	 mov	 rbx, rdx
  00020	41 f6 c0 02	 test	 r8b, 2
  00024	75 6b		 jne	 SHORT $LN2@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 236  : 		return (*_IPnext);

  00026	48 8b 41 40	 mov	 rax, QWORD PTR [rcx+64]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 94   : 		if (!(_Mystate & _Constant) && _Mysb::pptr() != 0)

  0002a	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0002d	48 85 d2	 test	 rdx, rdx
  00030	74 5f		 je	 SHORT $LN2@str

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00032	48 8b 79 68	 mov	 rdi, QWORD PTR [rcx+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  00036	48 8b 41 20	 mov	 rax, QWORD PTR [rcx+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0003a	48 3b fa	 cmp	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  0003d	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00045	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$70[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  0004a	48 0f 42 fa	 cmovb	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 231  : 		return (*_IPfirst);

  0004e	4c 8b 08	 mov	 r9, QWORD PTR [rax]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 96   : 			_Mystr _Str(_Mysb::pbase(), (_Seekhigh < _Mysb::pptr()

  00051	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00054	c6 44 24 20 00	 mov	 BYTE PTR _Str$70[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  00059	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$70[rsp+16], xmm0

; 2435 : 		if (_Count <= _My_data._Myres)

  0005f	48 83 ff 0f	 cmp	 rdi, 15
  00063	77 1d		 ja	 SHORT $LN47@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00065	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00068	48 89 7c 24 30	 mov	 QWORD PTR _Str$70[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0006d	49 8b d1	 mov	 rdx, r9
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00076	c6 44 3c 20 00	 mov	 BYTE PTR _Str$70[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0007b	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$70[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  00080	eb 7c		 jmp	 SHORT $LN456@str
$LN47@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  00082	48 8b d7	 mov	 rdx, rdi
  00085	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0008a	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$70[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  0008f	eb 6d		 jmp	 SHORT $LN456@str
$LN2@str:

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  00091	41 f6 c0 04	 test	 r8b, 4
  00095	75 5b		 jne	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 226  : 		return (*_IGnext);

  00097	48 8b 41 38	 mov	 rax, QWORD PTR [rcx+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 100  : 		else if (!(_Mystate & _Noread) && _Mysb::gptr() != 0)

  0009b	48 8b 10	 mov	 rdx, QWORD PTR [rax]
  0009e	48 85 d2	 test	 rdx, rdx
  000a1	74 4f		 je	 SHORT $LN4@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000a3	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000a7	66 0f 6f 05 00
	00 00 00	 movdqa	 xmm0, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000af	4c 8b 08	 mov	 r9, QWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000b2	48 8b 41 50	 mov	 rax, QWORD PTR [rcx+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000b6	48 8d 4c 24 20	 lea	 rcx, QWORD PTR _Str$69[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\streambuf

; 221  : 		return (*_IGfirst);

  000bb	48 63 38	 movsxd	 rdi, DWORD PTR [rax]

; 241  : 		return (*_IGnext + *_IGcount);

  000be	49 2b f9	 sub	 rdi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000c1	c6 44 24 20 00	 mov	 BYTE PTR _Str$69[rsp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 102  : 			_Mystr _Str(_Mysb::eback(), _Mysb::egptr() - _Mysb::eback());

  000c6	48 03 fa	 add	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3698 : 		_My_data._Mysize = 0;

  000c9	f3 0f 7f 44 24
	30		 movdqu	 XMMWORD PTR _Str$69[rsp+16], xmm0

; 2435 : 		if (_Count <= _My_data._Myres)

  000cf	48 83 ff 0f	 cmp	 rdi, 15
  000d3	77 ad		 ja	 SHORT $LN47@str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000d5	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  000d8	48 89 7c 24 30	 mov	 QWORD PTR _Str$69[rsp+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  000dd	49 8b d1	 mov	 rdx, r9
  000e0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  000e6	c6 44 3c 20 00	 mov	 BYTE PTR _Str$69[rsp+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000eb	0f 10 4c 24 30	 movups	 xmm1, XMMWORD PTR _Str$70[rsp+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 98   : 			return (_Str);

  000f0	eb 0c		 jmp	 SHORT $LN456@str
$LN4@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000f2	0f 10 0d 00 00
	00 00		 movups	 xmm1, XMMWORD PTR __xmm@000000000000000f0000000000000000
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000f9	c6 44 24 20 00	 mov	 BYTE PTR _Nul$68[rsp], 0
$LN456@str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  000fe	0f 10 44 24 20	 movups	 xmm0, XMMWORD PTR _Nul$68[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 108  : 			return (_Nul);

  00103	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00106	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00109	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream

; 110  : 		}

  0010d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  00112	48 33 cc	 xor	 rcx, rsp
  00115	e8 00 00 00 00	 call	 __security_check_cookie
  0011a	48 8b 5c 24 70	 mov	 rbx, QWORD PTR [rsp+112]
  0011f	48 83 c4 50	 add	 rsp, 80			; 00000050H
  00123	5f		 pop	 rdi
  00124	c3		 ret	 0
?str@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@2@XZ ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::str
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z
_TEXT	SEGMENT
$T5 = 32
this$ = 64
_Mode$dead$ = 72
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 28   : 	explicit basic_stringbuf(ios_base::openmode _Mode =

$LN47:
  00000	40 53		 push	 rbx
  00002	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00006	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T5[rsp], -2
  0000f	48 8b d9	 mov	 rbx, rcx

; 29   : 		ios_base::in | ios_base::out)
; 30   : 		{	// construct empty character buffer from mode

  00012	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0?$basic_streambuf@DU?$char_traits@D@std@@@std@@IEAA@XZ
  00018	90		 npad	 1
  00019	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@6B@
  00020	48 89 03	 mov	 QWORD PTR [rbx], rax

; 311  : 		_Seekhigh = 0;

  00023	33 c0		 xor	 eax, eax
  00025	48 89 43 68	 mov	 QWORD PTR [rbx+104], rax

; 312  : 		_Mystate = _State;

  00029	89 43 70	 mov	 DWORD PTR [rbx+112], eax

; 31   : 		_Init(0, 0, _Getstate(_Mode));
; 32   : 		}

  0002c	48 8b c3	 mov	 rax, rbx
  0002f	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00033	5b		 pop	 rbx
  00034	c3		 ret	 0
??0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
this$ = 64
_Mode$dead$ = 72
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T5 = 32
this$ = 64
_Mode$dead$ = 72
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA PROC ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1?$basic_streambuf@DU?$char_traits@D@std@@@std@@UEAA@XZ
?dtor$0@?0???0?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@H@Z@4HA ENDP ; `std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?allocate@?$allocator@D@std@@QEAAPEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Count$ = 56
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z PROC		; std::allocator<char>::allocate, COMDAT

; 945  : 		{	// allocate array of _Count elements

$LN14:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 54   : 		return (_Ptr);

  00004	33 c9		 xor	 ecx, ecx
  00006	48 85 d2	 test	 rdx, rdx
  00009	74 48		 je	 SHORT $LN3@allocate

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0000b	84 c9		 test	 cl, cl
  0000d	74 07		 je	 SHORT $LN5@allocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0000f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00015	cc		 int	 3
$LN5@allocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00016	48 81 fa 00 10
	00 00		 cmp	 rdx, 4096		; 00001000H
  0001d	72 29		 jb	 SHORT $LN6@allocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  0001f	48 8d 4a 27	 lea	 rcx, QWORD PTR [rdx+39]

; 72   : 		if (_Block_size <= _User_size)

  00023	48 3b ca	 cmp	 rcx, rdx
  00026	77 07		 ja	 SHORT $LN7@allocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00028	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0002e	cc		 int	 3
$LN7@allocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  0002f	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  00034	48 8d 48 27	 lea	 rcx, QWORD PTR [rax+39]
  00038	48 83 e1 e0	 and	 rcx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  0003c	48 89 41 f8	 mov	 QWORD PTR [rcx-8], rax

; 946  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof(_Ty))));

  00040	48 8b c1	 mov	 rax, rcx

; 947  : 		}

  00043	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00047	c3		 ret	 0
$LN6@allocate:

; 93   : 	_Ptr = ::operator new(_User_size);

  00048	48 8b ca	 mov	 rcx, rdx
  0004b	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  00050	48 8b c8	 mov	 rcx, rax
$LN3@allocate:

; 946  : 		return (static_cast<pointer>(_Allocate(_Count, sizeof(_Ty))));

  00053	48 8b c1	 mov	 rax, rcx

; 947  : 		}

  00056	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005a	c3		 ret	 0
$LN13@allocate:
?allocate@?$allocator@D@std@@QEAAPEAD_K@Z ENDP		; std::allocator<char>::allocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z
_TEXT	SEGMENT
this$dead$ = 48
_Ptr$ = 56
_Count$ = 64
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z PROC	; std::allocator<char>::deallocate, COMDAT

; 940  : 		{	// deallocate object at _Ptr

$LN20:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00004	49 81 f8 00 10
	00 00		 cmp	 r8, 4096		; 00001000H
  0000b	72 1e		 jb	 SHORT $LN6@deallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0000d	f6 c2 1f	 test	 dl, 31
  00010	75 25		 jne	 SHORT $_Invalid_parameter$21

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00012	48 8b 42 f8	 mov	 rax, QWORD PTR [rdx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00016	48 3b c2	 cmp	 rax, rdx
  00019	73 1c		 jae	 SHORT $_Invalid_parameter$21
  0001b	48 2b d0	 sub	 rdx, rax
  0001e	48 83 ea 08	 sub	 rdx, 8
  00022	48 83 fa 1f	 cmp	 rdx, 31
  00026	77 0f		 ja	 SHORT $_Invalid_parameter$21

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00028	48 8b d0	 mov	 rdx, rax
$LN6@deallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0002b	48 8b ca	 mov	 rcx, rdx

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));
; 942  : 		}

  0002e	48 83 c4 28	 add	 rsp, 40			; 00000028H

; 151  : 	::operator delete(_Ptr);

  00032	e9 00 00 00 00	 jmp	 ??3@YAXPEAX@Z		; operator delete
$_Invalid_parameter$21:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00037	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0003d	cc		 int	 3
$LN19@deallocate:
?deallocate@?$allocator@D@std@@QEAAXQEAD_K@Z ENDP	; std::allocator<char>::deallocate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::operator __int64, COMDAT

; 66   : 		return (_Myoff + _Fpos);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]
  00004	48 03 01	 add	 rax, QWORD PTR [rcx]

; 67   : 		}

  00007	c3		 ret	 0
??B?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::operator __int64
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ
_TEXT	SEGMENT
this$ = 8
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ PROC		; std::fpos<_Mbstatet>::seekpos, COMDAT

; 61   : 		return (_Fpos);

  00000	48 8b 41 08	 mov	 rax, QWORD PTR [rcx+8]

; 62   : 		}

  00004	c3		 ret	 0
?seekpos@?$fpos@U_Mbstatet@@@std@@QEBA_JXZ ENDP		; std::fpos<_Mbstatet>::seekpos
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ
_TEXT	SEGMENT
this$ = 8
__$ReturnUdt$ = 16
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ PROC ; std::fpos<_Mbstatet>::state, COMDAT

; 51   : 		return (_Mystate);

  00000	48 8b 41 10	 mov	 rax, QWORD PTR [rcx+16]
  00004	48 89 02	 mov	 QWORD PTR [rdx], rax
  00007	48 8b c2	 mov	 rax, rdx

; 52   : 		}

  0000a	c3		 ret	 0
?state@?$fpos@U_Mbstatet@@@std@@QEBA?AU_Mbstatet@@XZ ENDP ; std::fpos<_Mbstatet>::state
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z
_TEXT	SEGMENT
this$ = 8
_State$ = 16
_Fileposition$ = 24
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z PROC	; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 45   : 		: _Myoff(0), _Fpos(_Fileposition), _Mystate(_State)

  00000	48 c7 01 00 00
	00 00		 mov	 QWORD PTR [rcx], 0

; 47   : 		}

  00007	48 8b c1	 mov	 rax, rcx
  0000a	4c 89 41 08	 mov	 QWORD PTR [rcx+8], r8
  0000e	48 89 51 10	 mov	 QWORD PTR [rcx+16], rdx
  00012	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@U_Mbstatet@@_J@Z ENDP	; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
;	COMDAT ??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z
_TEXT	SEGMENT
this$ = 8
_Off$ = 16
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z PROC		; std::fpos<_Mbstatet>::fpos<_Mbstatet>, COMDAT

; 40   : 		: _Myoff(_Off), _Fpos(0), _Mystate()

  00000	33 c0		 xor	 eax, eax
  00002	48 89 11	 mov	 QWORD PTR [rcx], rdx
  00005	48 c7 41 08 00
	00 00 00	 mov	 QWORD PTR [rcx+8], 0
  0000d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 42   : 		}

  00011	48 8b c1	 mov	 rax, rcx
  00014	c3		 ret	 0
??0?$fpos@U_Mbstatet@@@std@@QEAA@_J@Z ENDP		; std::fpos<_Mbstatet>::fpos<_Mbstatet>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??0param_type@?$uniform_int@H@std@@QEAA@HH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
??0param_type@?$uniform_int@H@std@@QEAA@HH@Z PROC	; std::uniform_int<int>::param_type::param_type, COMDAT

; 2256 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2228 : 			{	// construct from parameters
; 2229 : 			_Init(_Min0, _Max0);
; 2230 : 			}

  00002	48 8b c1	 mov	 rax, rcx

; 2257 : 			_Max = _Max0;

  00005	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2228 : 			{	// construct from parameters
; 2229 : 			_Init(_Min0, _Max0);
; 2230 : 			}

  00009	c3		 ret	 0
??0param_type@?$uniform_int@H@std@@QEAA@HH@Z ENDP	; std::uniform_int<int>::param_type::param_type
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z
_TEXT	SEGMENT
this$ = 8
_X0$ = 16
_Fx$dead$ = 24
?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z PROC ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed, COMDAT

; 1337 : 		_Ty _Prev = this->_Ax[0] = _X0 & _WMSK;

  00000	48 89 51 08	 mov	 QWORD PTR [rcx+8], rdx
  00004	4c 8d 49 10	 lea	 r9, QWORD PTR [rcx+16]
  00008	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000e	41 ba 37 01 00
	00		 mov	 r10d, 311		; 00000137H
  00014	49 bb 2d 7f 95
	4c 2d f4 51 58	 mov	 r11, 6364136223846793005 ; 5851f42d4c957f2dH
  0001e	66 90		 npad	 2
$LL4@seed:

; 1338 : 		for (int _Ix = 1; _Ix < _Nx; ++_Ix)
; 1339 : 			_Prev = this->_Ax[_Ix] =

  00020	48 8b c2	 mov	 rax, rdx
  00023	4d 8d 49 08	 lea	 r9, QWORD PTR [r9+8]
  00027	48 c1 e8 3e	 shr	 rax, 62			; 0000003eH
  0002b	48 33 d0	 xor	 rdx, rax
  0002e	49 0f af d3	 imul	 rdx, r11
  00032	49 03 d0	 add	 rdx, r8
  00035	49 ff c0	 inc	 r8
  00038	49 89 51 f8	 mov	 QWORD PTR [r9-8], rdx
  0003c	49 83 ea 01	 sub	 r10, 1
  00040	75 de		 jne	 SHORT $LL4@seed

; 1340 : 				(_Ix + _Fx * (_Prev ^ (_Prev >> (_Wx - 2)))) & _WMSK;
; 1341 : 		this->_Idx = _Nx;

  00042	c7 01 38 01 00
	00		 mov	 DWORD PTR [rcx], 312	; 00000138H

; 1342 : 		}

  00048	c3		 ret	 0
?seed@?$mersenne_twister@_K$0EA@$0BDI@$0JM@$0BP@$0?EKPNJAKFFGJJOGBH@$0BN@$0BB@$0HBNGHPPPONKGAAAA@$0CF@$0?IBBCAAAAAAAAA@$0CL@@std@@QEAAX_K0@Z ENDP ; std::mersenne_twister<unsigned __int64,64,312,156,31,-5403634167711393303,29,17,8202884508482404352,37,-2270628950310912,43>::seed
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 105  : 			{	// destroy after unlocking

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 106  : 			if (_Myostr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN2@Sentry_bas

; 107  : 				_Myostr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN2@Sentry_bas:

; 108  : 			}

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Ostr$ = 56
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 99   : 			{	// lock the stream buffer, if there

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 98   : 			: _Myostr(_Ostr)

  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 99   : 			{	// lock the stream buffer, if there

  00009	48 8b d9	 mov	 rbx, rcx

; 100  : 			if (_Myostr.rdbuf() != 0)

  0000c	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000f	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00013	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 06		 je	 SHORT $LN8@Sentry_bas

; 101  : 				_Myostr.rdbuf()->_Lock();

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00020	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 102  : 			}

  00023	48 8b c3	 mov	 rax, rbx
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
??0_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 343  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 344  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second, COMDAT

; 338  : 		return (_Myval2);

  00000	48 8b c1	 mov	 rax, rcx

; 339  : 		}

  00003	c3		 ret	 0
?_Get_second@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$_String_val@U?$_Simple_types@D@std@@@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_second
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 323  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 324  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEBAAEBV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ
_TEXT	SEGMENT
this$ = 8
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first, COMDAT

; 318  : 		return (*this);

  00000	48 8b c1	 mov	 rax, rcx

; 319  : 		}

  00003	c3		 ret	 0
?_Get_first@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAAAEAV?$allocator@D@2@XZ ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Get_first
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ
_TEXT	SEGMENT
this$ = 8
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*, COMDAT

; 1223 : #if _ITERATOR_DEBUG_LEVEL >= 1
; 1224 : 		_IDL_VERIFY(_Ptr, "cannot dereference value-initialized string iterator");
; 1225 : 		const auto _Mycont = static_cast<const _Mystr *>(this->_Getcont());
; 1226 : 		_IDL_VERIFY(_Mycont, "cannot dereference string iterator because the iterator was"
; 1227 : 			" invalidated (e.g. reallocation occurred, or the string was destroyed)");
; 1228 : 		const auto _Contptr = _Mycont->_Myptr();
; 1229 : 		const auto _Rawptr = _Unfancy(_Ptr);
; 1230 : 		_IDL_VERIFY(_Contptr <= _Rawptr && _Rawptr < _Contptr + _Mycont->_Mysize,
; 1231 : 			"cannot dereference string iterator because it is out of range (e.g. an end iterator)");
; 1232 : #endif /* _ITERATOR_DEBUG_LEVEL >= 1 */
; 1233 : 
; 1234 : 		_Analysis_assume_(_Ptr);
; 1235 : 		return (*_Ptr);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 1236 : 		}

  00003	c3		 ret	 0
??D?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEBAAEBDXZ ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::operator*
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z PROC ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1214 : 		: _Ptr(_Parg)

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 1427 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_String_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEADPEBU_Container_base0@1@@Z ENDP ; std::_String_iterator<std::_String_val<std::_Simple_types<char> > >::_String_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ
_TEXT	SEGMENT
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ PROC ; std::_String_val<std::_Simple_types<char> >::_Xran, COMDAT

; 1637 : 		{	// report an out_of_range error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 1638 : 		_Xout_of_range("invalid string position");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BI@CFPLBAOH@invalid?5string?5position?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xout_of_range@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xran:
?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Xran
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::max_size, COMDAT

; 867  : 		return (static_cast<size_t>(-1) / sizeof(value_type));

  00000	48 83 c8 ff	 or	 rax, -1

; 868  : 		}

  00004	c3		 ret	 0
?max_size@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SA_KAEBV?$allocator@D@2@@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::max_size
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z
_TEXT	SEGMENT
this$ = 48
_Right$dead$ = 56
_Roff$dead$ = 64
_Count$dead$ = 72
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign, COMDAT

; 2410 : 		{	// assign _Right [_Roff, _Roff + _Count)

$LN51:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 1622 : 		if (_Mysize < _Off)

  00006	48 8b 05 10 00
	00 00		 mov	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 2410 : 		{	// assign _Right [_Roff, _Roff + _Count)

  0000d	48 8b d9	 mov	 rbx, rcx

; 1622 : 		if (_Mysize < _Off)

  00010	48 83 f8 05	 cmp	 rax, 5
  00014	0f 82 89 00 00
	00		 jb	 $LN49@assign

; 1643 : 		return (_Min_value(_Size, _Mysize - _Off));

  0001a	48 83 c0 fb	 add	 rax, -5
  0001e	48 89 7c 24 40	 mov	 QWORD PTR [rsp+64], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00023	48 83 cf ff	 or	 rdi, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00027	4c 8d 0d 00 00
	00 00		 lea	 r9, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 23   : 	return (_Right < _Left ? _Right : _Left);

  0002e	48 3b c7	 cmp	 rax, rdi
  00031	48 0f 42 f8	 cmovb	 rdi, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00035	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 2435 : 		if (_Count <= _My_data._Myres)

  0003d	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 1607 : 		if (_Large_string_engaged())

  00041	4c 0f 43 0d 00
	00 00 00	 cmovae	 r9, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00049	49 83 c1 05	 add	 r9, 5

; 2435 : 		if (_Count <= _My_data._Myres)

  0004d	48 3b f8	 cmp	 rdi, rax
  00050	77 3b		 ja	 SHORT $LN27@assign

; 1595 : 		value_type * _Result = _Bx._Buf;

  00052	48 89 74 24 38	 mov	 QWORD PTR [rsp+56], rsi
  00057	48 8b f1	 mov	 rsi, rcx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0005a	48 83 f8 10	 cmp	 rax, 16

; 1596 : 		if (_Large_string_engaged())

  0005e	72 03		 jb	 SHORT $LN36@assign
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00060	48 8b 31	 mov	 rsi, QWORD PTR [rcx]
$LN36@assign:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2438 : 			_My_data._Mysize = _Count;

  00063	48 89 79 10	 mov	 QWORD PTR [rcx+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00067	4c 8b c7	 mov	 r8, rdi
  0006a	48 8b ce	 mov	 rcx, rsi
  0006d	49 8b d1	 mov	 rdx, r9
  00070	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 517  : 		_Left = _Right;

  00076	c6 04 37 00	 mov	 BYTE PTR [rdi+rsi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  0007a	48 8b c3	 mov	 rax, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0007d	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00082	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2415 : 		}

  00087	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0008b	5b		 pop	 rbx
  0008c	c3		 ret	 0
$LN27@assign:

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0008d	48 8b d7	 mov	 rdx, rdi
  00090	e8 00 00 00 00	 call	 ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>

; 2414 : 		return (assign(_Right_data._Myptr() + _Roff, _Count));

  00095	48 8b 7c 24 40	 mov	 rdi, QWORD PTR [rsp+64]

; 2444 : 		return (_Reallocate_for(_Count, [](_Elem * const _New_ptr, const size_type _Count, const _Elem * const _Ptr) {

  0009a	48 8b d8	 mov	 rbx, rax

; 2415 : 		}

  0009d	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a1	5b		 pop	 rbx
  000a2	c3		 ret	 0
$LN49@assign:

; 1624 : 			_Xran();

  000a3	e8 00 00 00 00	 call	 ?_Xran@?$_String_val@U?$_Simple_types@D@std@@@std@@SAXXZ ; std::_String_val<std::_Simple_types<char> >::_Xran
  000a8	cc		 int	 3
$LN48@assign:
?assign@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@AEBV12@_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::assign
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z
_TEXT	SEGMENT
this$dead$ = 8
_Mode$dead$ = 16
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate, COMDAT

; 357  : 		_Strstate _State = (_Strstate)0;
; 358  : 		if (!(_Mode & ios_base::in))
; 359  : 			_State |= _Noread;
; 360  : 		if (!(_Mode & ios_base::out))
; 361  : 			_State |= _Constant;
; 362  : 		if (_Mode & ios_base::app)
; 363  : 			_State |= _Append;
; 364  : 		if (_Mode & ios_base::ate)
; 365  : 			_State |= _Atend;
; 366  : 		return (_State);

  00000	33 c0		 xor	 eax, eax

; 367  : 		}

  00002	c3		 ret	 0
?_Getstate@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@AEAAHH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Getstate
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\sstream
;	COMDAT ?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z
_TEXT	SEGMENT
this$ = 8
_Ptr$dead$ = 16
_Count$dead$ = 24
_State$ = 32
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z PROC ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init, COMDAT

; 311  : 		_Seekhigh = 0;

  00000	48 c7 41 68 00
	00 00 00	 mov	 QWORD PTR [rcx+104], 0

; 312  : 		_Mystate = _State;

  00008	44 89 49 70	 mov	 DWORD PTR [rcx+112], r9d

; 313  : 
; 314  : 		if (_Count != 0
; 315  : 			&& (_Mystate & (_Noread | _Constant)) != (_Noread | _Constant))
; 316  : 			{	// finite buffer that can be read or written, set it up
; 317  : 			_Elem *_Pnew = _Unfancy(_Al.allocate(_Count));
; 318  : 			_Traits::copy(_Pnew, _Ptr, _Count);
; 319  : 			_Seekhigh = _Pnew + _Count;
; 320  : 
; 321  : 			if (!(_Mystate & _Noread))
; 322  : 				_Mysb::setg(_Pnew, _Pnew,
; 323  : 					_Pnew + _Count);	// setup read buffer
; 324  : 			if (!(_Mystate & _Constant))
; 325  : 				{	// setup write buffer, and maybe read buffer
; 326  : 				_Mysb::setp(_Pnew,
; 327  : 					(_Mystate & (_Atend | _Append)) ? _Pnew + _Count : _Pnew,
; 328  : 					_Pnew + _Count);
; 329  : 				if (_Mysb::gptr() == 0)
; 330  : 					_Mysb::setg(_Pnew, 0, _Pnew);
; 331  : 				}
; 332  : 			_Mystate |= _Allocated;
; 333  : 			}
; 334  : 		}

  0000c	c3		 ret	 0
?_Init@?$basic_stringbuf@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@IEAAXPEBD_KH@Z ENDP ; std::basic_stringbuf<char,std::char_traits<char>,std::allocator<char> >::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??0?$allocator@D@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$allocator@D@std@@QEAA@XZ PROC			; std::allocator<char>::allocator<char>, COMDAT

; 930  : 		{	// construct default allocator (do nothing)
; 931  : 		}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0?$allocator@D@std@@QEAA@XZ ENDP			; std::allocator<char>::allocator<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z
_TEXT	SEGMENT
this$ = 8
_Min0$ = 16
_Max0$ = 24
?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z PROC	; std::uniform_int<int>::param_type::_Init, COMDAT

; 2254 : 			_RNG_ASSERT(_Min0 <= _Max0,
; 2255 : 				"invalid min and max arguments for uniform_int");
; 2256 : 			_Min = _Min0;

  00000	89 11		 mov	 DWORD PTR [rcx], edx

; 2257 : 			_Max = _Max0;

  00002	44 89 41 04	 mov	 DWORD PTR [rcx+4], r8d

; 2258 : 			}

  00006	c3		 ret	 0
?_Init@param_type@?$uniform_int@H@std@@QEAAXHH@Z ENDP	; std::uniform_int<int>::param_type::_Init
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z
_TEXT	SEGMENT
this$ = 8
_Parg$ = 16
_Pstring$dead$ = 24
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z PROC ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 1214 : 		: _Ptr(_Parg)

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 1216 : 		this->_Adopt(_Pstring);
; 1217 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	c3		 ret	 0
??0?$_String_const_iterator@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@QEAA@PEBDPEBU_Container_base0@1@@Z ENDP ; std::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >::_String_const_iterator<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::ctype<char> >, COMDAT

; 505  : 	{	// get facet reference from locale

$LN23:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	49 c7 43 b8 fe
	ff ff ff	 mov	 QWORD PTR [r11-72], -2
  00010	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00014	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b f1	 mov	 rsi, rcx

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002a	33 d2		 xor	 edx, edx
  0002c	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00036	90		 npad	 1

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::ctype<char> >::_Psave
  0003e	48 89 44 24 40	 mov	 QWORD PTR _Psave$3[rsp], rax

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$ctype@D@std@@2V0locale@2@A
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00050	48 8b f8	 mov	 rdi, rax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00053	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00057	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0005b	73 0f		 jae	 SHORT $LN15@use_facet
  0005d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00061	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00065	48 85 db	 test	 rbx, rbx
  00068	75 7b		 jne	 SHORT $LN7@use_facet
  0006a	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0006c	33 db		 xor	 ebx, ebx
$LN19@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006e	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  00072	74 14		 je	 SHORT $LN12@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  0007a	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0007e	73 0d		 jae	 SHORT $LN20@use_facet
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN12@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

  00088	48 85 db	 test	 rbx, rbx
  0008b	75 58		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]
  00092	48 85 db	 test	 rbx, rbx
  00095	75 4e		 jne	 SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Psave$3[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$ctype@D@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  000a5	48 83 f8 ff	 cmp	 rax, -1
  000a9	75 1c		 jne	 SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ab	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000b0	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  000bc	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000c1	e8 00 00 00 00	 call	 _CxxThrowException
  000c6	cc		 int	 3
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

  000c7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;

  000cc	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$ctype@D@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::ctype<char> >::_Psave

; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

  000d3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	ff 50 08	 call	 QWORD PTR [rax+8]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register
  000e4	90		 npad	 1
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000e5	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$4[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000f0	48 8b c3	 mov	 rax, rbx

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f8	48 33 cc	 xor	 rcx, rsp
  000fb	e8 00 00 00 00	 call	 __security_check_cookie
  00100	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00105	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0010d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
$LN21@use_facet:
??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::ctype<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::ctype<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z
_TEXT	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z PROC ; std::operator<<<std::char_traits<char> >, COMDAT

; 772  : 	{	// insert NTBS into char stream

$LN113:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T28[rsp], -2
  0001a	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  0001f	4c 8b fa	 mov	 r15, rdx
  00022	48 8b f1	 mov	 rsi, rcx

; 773  : 	typedef char _Elem;
; 774  : 	typedef basic_ostream<_Elem, _Traits> _Myos;
; 775  : 	ios_base::iostate _State = ios_base::goodbit;

  00025	33 db		 xor	 ebx, ebx
  00027	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0002e	49 83 ce ff	 or	 r14, -1
$LL108@operator:
  00032	49 ff c6	 inc	 r14
  00035	42 38 1c 32	 cmp	 BYTE PTR [rdx+r14], bl
  00039	75 f7		 jne	 SHORT $LL108@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  0003b	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0003e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  00042	48 8b 7c 31 28	 mov	 rdi, QWORD PTR [rcx+rsi+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 777  : 	streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count

  00047	48 85 ff	 test	 rdi, rdi
  0004a	7e 0a		 jle	 SHORT $LN17@operator
  0004c	49 3b fe	 cmp	 rdi, r14
  0004f	7e 05		 jle	 SHORT $LN17@operator
  00051	49 2b fe	 sub	 rdi, r14
  00054	eb 02		 jmp	 SHORT $LN18@operator
$LN17@operator:
  00056	33 ff		 xor	 edi, edi
$LN18@operator:

; 98   : 			: _Myostr(_Ostr)

  00058	4c 8b e6	 mov	 r12, rsi
  0005b	48 89 74 24 28	 mov	 QWORD PTR _Ok$[rsp], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00060	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  00065	48 85 c9	 test	 rcx, rcx
  00068	74 07		 je	 SHORT $LN38@operator

; 101  : 				_Myostr.rdbuf()->_Lock();

  0006a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0006d	ff 50 08	 call	 QWORD PTR [rax+8]
  00070	90		 npad	 1
$LN38@operator:

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00071	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00074	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00078	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0007d	75 15		 jne	 SHORT $LN34@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 79   : 		return (_Tiestr);

  0007f	48 8b 4c 31 50	 mov	 rcx, QWORD PTR [rcx+rsi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00084	48 85 c9	 test	 rcx, rcx
  00087	74 0b		 je	 SHORT $LN34@operator
  00089	48 3b ce	 cmp	 rcx, rsi
  0008c	74 06		 je	 SHORT $LN34@operator

; 124  : 				_Ostr.tie()->flush();

  0008e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN34@operator:

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  00094	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00097	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  0009b	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
  000a0	0f 94 c0	 sete	 al
  000a3	88 44 24 30	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 781  : 	if (!_Ok)

  000a7	84 c0		 test	 al, al
  000a9	75 0a		 jne	 SHORT $LN8@operator

; 782  : 		_State |= ios_base::badbit;

  000ab	bb 04 00 00 00	 mov	 ebx, 4

; 783  : 	else

  000b0	e9 b0 00 00 00	 jmp	 $LN22@operator
$LN8@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 377  : 		return (_Fmtfl);

  000b5	8b 44 31 18	 mov	 eax, DWORD PTR [rcx+rsi+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 786  : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000b9	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000be	83 f8 40	 cmp	 eax, 64			; 00000040H
  000c1	74 2a		 je	 SHORT $LN104@operator
$LL4@operator:

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000c3	48 85 ff	 test	 rdi, rdi
  000c6	7e 21		 jle	 SHORT $LN3@operator

; 788  : 				if (_Traits::eq_int_type(_Traits::eof(),

  000c8	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000cb	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000cf	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000d4	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000d9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000df	83 f8 ff	 cmp	 eax, -1
  000e2	74 52		 je	 SHORT $LN111@operator

; 787  : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000e4	48 ff cf	 dec	 rdi
  000e7	eb da		 jmp	 SHORT $LL4@operator
$LN3@operator:

; 792  : 					break;
; 793  : 					}
; 794  : 
; 795  : 		if (_State == ios_base::goodbit
; 796  : 			&& _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)

  000e9	85 db		 test	 ebx, ebx
  000eb	75 55		 jne	 SHORT $LN6@operator
$LN104@operator:
  000ed	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000f0	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000f4	4d 8b c6	 mov	 r8, r14
  000f7	49 8b d7	 mov	 rdx, r15
  000fa	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000ff	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00105	49 3b c6	 cmp	 rax, r14
  00108	75 2c		 jne	 SHORT $LN111@operator
  0010a	66 0f 1f 44 00
	00		 npad	 6
$LL109@operator:

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00110	48 85 ff	 test	 rdi, rdi
  00113	7e 2d		 jle	 SHORT $LN6@operator

; 801  : 				if (_Traits::eq_int_type(_Traits::eof(),

  00115	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00118	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0011c	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00121	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00126	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0012c	83 f8 ff	 cmp	 eax, -1
  0012f	74 05		 je	 SHORT $LN111@operator

; 797  : 			_State |= ios_base::badbit;
; 798  : 
; 799  : 		if (_State == ios_base::goodbit)
; 800  : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00131	48 ff cf	 dec	 rdi
  00134	eb da		 jmp	 SHORT $LL109@operator
$LN111@operator:

; 789  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 790  : 					{	// insertion failed, quit
; 791  : 					_State |= ios_base::badbit;

  00136	bb 04 00 00 00	 mov	 ebx, 4
  0013b	89 9c 24 80 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
$LN6@operator:

; 802  : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 803  : 					{	// insertion failed, quit
; 804  : 					_State |= ios_base::badbit;
; 805  : 					break;
; 806  : 					}
; 807  : 		_Ostr.width(0);

  00142	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00145	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00149	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
  00152	eb 11		 jmp	 SHORT $LN22@operator
$LN23@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  00154	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00159	8b 9c 24 80 00
	00 00		 mov	 ebx, DWORD PTR _State$[rsp]
  00160	4c 8b 64 24 28	 mov	 r12, QWORD PTR _Ok$[rsp]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 811  : 	_Ostr.setstate(_State);

  00165	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00168	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0016c	48 03 ce	 add	 rcx, rsi
  0016f	45 33 c0	 xor	 r8d, r8d
  00172	8b d3		 mov	 edx, ebx
  00174	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0017a	90		 npad	 1

; 131  : 			if (!_STD uncaught_exception())

  0017b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00181	84 c0		 test	 al, al
  00183	75 0a		 jne	 SHORT $LN87@operator

; 132  : 				this->_Myostr._Osfx();

  00185	49 8b cc	 mov	 rcx, r12
  00188	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0018e	90		 npad	 1
$LN87@operator:

; 106  : 			if (_Myostr.rdbuf() != 0)

  0018f	49 8b 04 24	 mov	 rax, QWORD PTR [r12]
  00193	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00197	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  0019c	48 85 c9	 test	 rcx, rcx
  0019f	74 07		 je	 SHORT $LN91@operator

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001a1	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001a4	ff 50 10	 call	 QWORD PTR [rax+16]
  001a7	90		 npad	 1
$LN91@operator:

; 812  : 	return (_Ostr);

  001a8	48 8b c6	 mov	 rax, rsi

; 813  : 	}

  001ab	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001b0	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001b4	41 5f		 pop	 r15
  001b6	41 5e		 pop	 r14
  001b8	41 5c		 pop	 r12
  001ba	5f		 pop	 rdi
  001bb	5e		 pop	 rsi
  001bc	c3		 ret	 0
??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z ENDP ; std::operator<<<std::char_traits<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9

; 808  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$9
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T28 = 32
_Ok$ = 40
_Ostr$ = 112
_Val$ = 120
_State$ = 128
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA PROC ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9

; 808  : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$9
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$9@?0???$?6U?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@PEBD@Z@4HA ENDP ; `std::operator<<<std::char_traits<char> >'::`1'::catch$9
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
;	COMDAT ??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Ostr$ = 48
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::endl<char,std::char_traits<char> >, COMDAT

; 983  : 	{	// insert newline and flush stream

$LN4:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 984  : 	_Ostr.put(_Ostr.widen('\n'));

  00006	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00009	48 8b d9	 mov	 rbx, rcx
  0000c	b2 0a		 mov	 dl, 10
  0000e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00012	48 03 cb	 add	 rcx, rbx
  00015	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  0001b	0f b6 d0	 movzx	 edx, al
  0001e	48 8b cb	 mov	 rcx, rbx
  00021	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?put@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@D@Z

; 985  : 	_Ostr.flush();

  00027	48 8b cb	 mov	 rcx, rbx
  0002a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ

; 986  : 	return (_Ostr);

  00030	48 8b c3	 mov	 rax, rbx

; 987  : 	}

  00033	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00037	5b		 pop	 rbx
  00038	c3		 ret	 0
??$endl@DU?$char_traits@D@std@@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::endl<char,std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Istr$ = 8
_Str$ = 16
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 138  : 	return (_STD move(_Istr) >> _Str);

  00000	e9 00 00 00 00	 jmp	 ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3955 : 	{	// test for string vs. NTCTS inequality

$LN34:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL32@operator:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL32@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1607 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN18@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN18@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 11		 jne	 SHORT $LN26@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 05		 jne	 SHORT $LN26@operator

; 3957 : 	}

  0003b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0003f	c3		 ret	 0
$LN26@operator:

; 3956 : 	return (!(_Left == _Right));

  00040	b0 01		 mov	 al, 1

; 3957 : 	}

  00042	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00046	c3		 ret	 0
??$?9DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator!=<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z
_TEXT	SEGMENT
_Left$ = 48
_Right$ = 56
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z PROC ; std::operator==<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3925 : 	{	// test for string vs. NTCTS equality

$LN32:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL30@operator:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL30@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1607 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN16@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN16@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 13		 jne	 SHORT $LN24@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN24@operator

; 3926 : 	return (_Left._Equal(_Right));

  0003b	b0 01		 mov	 al, 1

; 3927 : 	}

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN24@operator:

; 3926 : 	return (_Left._Equal(_Right));

  00042	32 c0		 xor	 al, al

; 3927 : 	}

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
??$?8DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA_NAEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBD@Z ENDP ; std::operator==<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z
_TEXT	SEGMENT
this$ = 48
_Eng$dead$ = 56
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z PROC ; std::uniform_int<int>::operator()<std::random_device>, COMDAT

; 2311 : 		{	// return next value

$LN93:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  00015	8b 29		 mov	 ebp, DWORD PTR [rcx]
  00017	41 be 00 00 00
	80		 mov	 r14d, -2147483648	; ffffffff80000000H

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  0001d	8b 79 04	 mov	 edi, DWORD PTR [rcx+4]

; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  00020	41 03 ee	 add	 ebp, r14d

; 2312 : 		return (_Eval(_Eng, _Par._Min, _Par._Max));

  00023	2b fd		 sub	 edi, ebp

; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  00025	33 db		 xor	 ebx, ebx
  00027	41 03 fe	 add	 edi, r14d
  0002a	83 ff ff	 cmp	 edi, -1			; ffffffffH
  0002d	75 0f		 jne	 SHORT $LN4@operator
  0002f	90		 npad	 1
$LL34@operator:

; 6442 : 		return (_Random_device());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00036	8b d0		 mov	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00038	84 db		 test	 bl, bl
  0003a	75 f4		 jne	 SHORT $LL34@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2362 : 		else

  0003c	eb 4b		 jmp	 SHORT $LN45@operator
$LN4@operator:

; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  0003e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00043	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
$LL44@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3487 : 			_Udiff _Ret = 0;	// random bits

  00046	44 8b c3	 mov	 r8d, ebx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00049	8b c3		 mov	 eax, ebx

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0004b	85 ff		 test	 edi, edi
  0004d	74 15		 je	 SHORT $LN48@operator
  0004f	90		 npad	 1
$LL53@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00056	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00059	84 db		 test	 bl, bl
  0005b	75 f3		 jne	 SHORT $LL53@operator

; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0005d	83 c8 ff	 or	 eax, -1			; ffffffffH
  00060	84 db		 test	 bl, bl
  00062	75 ec		 jne	 SHORT $LL53@operator
$LN48@operator:

; 3491 : 				{	// need more random bits
; 3492 : 				_Ret <<= _Bits - 1;	// avoid full shift
; 3493 : 				_Ret <<= 1;
; 3494 : 				_Ret |= _Get_bits();
; 3495 : 				_Mask <<= _Bits - 1;	// avoid full shift
; 3496 : 				_Mask <<= 1;
; 3497 : 				_Mask |= _Bmask;
; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00064	33 d2		 xor	 edx, edx
  00066	f7 f6		 div	 esi
  00068	8b c8		 mov	 ecx, eax
  0006a	44 8b ca	 mov	 r9d, edx
  0006d	33 d2		 xor	 edx, edx
  0006f	41 8b c0	 mov	 eax, r8d
  00072	f7 f6		 div	 esi
  00074	3b c1		 cmp	 eax, ecx
  00076	72 05		 jb	 SHORT $LN78@operator
  00078	44 3b cf	 cmp	 r9d, edi
  0007b	75 c9		 jne	 SHORT $LL44@operator
$LN78@operator:

; 3503 : 				return (_Ret % _Index);

  0007d	33 d2		 xor	 edx, edx
  0007f	41 8b c0	 mov	 eax, r8d
  00082	f7 f6		 div	 esi
  00084	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN45@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2313 : 		}

  00089	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008e	4a 8d 04 32	 lea	 rax, QWORD PTR [rdx+r14]
  00092	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00097	03 c5		 add	 eax, ebp
  00099	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	41 5e		 pop	 r14
  000a4	c3		 ret	 0
??$?RVrandom_device@std@@@?$uniform_int@H@std@@QEBAHAEAVrandom_device@1@@Z ENDP ; std::uniform_int<int>::operator()<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3849 : 	{	// return string + string

$LN201:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3850 : 	if (_Right.size() <= _Left.capacity() - _Left.size()
; 3851 : 		|| _Right.capacity() - _Right.size() < _Left.size())

  00006	48 8b 42 18	 mov	 rax, QWORD PTR [rdx+24]
  0000a	48 8b d9	 mov	 rbx, rcx
  0000d	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]
  00011	4d 8b c8	 mov	 r9, r8
  00014	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  00018	48 2b c1	 sub	 rax, rcx
  0001b	4c 8b d2	 mov	 r10, rdx
  0001e	4c 3b c0	 cmp	 r8, rax
  00021	76 19		 jbe	 SHORT $LN4@operator
  00023	49 8b 41 18	 mov	 rax, QWORD PTR [r9+24]
  00027	49 2b c0	 sub	 rax, r8
  0002a	48 3b c1	 cmp	 rax, rcx
  0002d	72 0d		 jb	 SHORT $LN4@operator

; 3853 : 	else
; 3854 : 		return (_STD move(_Right.insert(0, _Left)));

  0002f	4c 8b c2	 mov	 r8, rdx
  00032	49 8b c9	 mov	 rcx, r9
  00035	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
  0003a	eb 15		 jmp	 SHORT $LN199@operator
$LN4@operator:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0003c	49 83 79 18 10	 cmp	 QWORD PTR [r9+24], 16

; 1607 : 		if (_Large_string_engaged())

  00041	72 03		 jb	 SHORT $LN71@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00043	4d 8b 09	 mov	 r9, QWORD PTR [r9]
$LN71@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00046	49 8b d1	 mov	 rdx, r9
  00049	49 8b ca	 mov	 rcx, r10
  0004c	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
$LN199@operator:

; 1576 : 		_Mysize(0),

  00051	33 c9		 xor	 ecx, ecx
  00053	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1577 : 		_Myres(0)

  00057	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  0005b	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  0005e	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00061	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  00065	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00069	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  0006d	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00075	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3852 : 		return (_STD move(_Left.append(_Right)));

  00077	48 8b c3	 mov	 rax, rbx

; 3855 : 	}

  0007a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007e	5b		 pop	 rbx
  0007f	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$dead$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3829 : 	{	// return string + string

$LN67:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b c0	 mov	 rax, r8
  00009	48 8b d9	 mov	 rbx, rcx

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  0000c	48 8b c8	 mov	 rcx, rax
  0000f	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os
  00016	e8 00 00 00 00	 call	 ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert

; 1576 : 		_Mysize(0),

  0001b	33 c9		 xor	 ecx, ecx
  0001d	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1577 : 		_Myres(0)

  00021	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00025	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00028	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  0002b	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0002f	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00033	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00037	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0003f	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3830 : 	return (_STD move(_Right.insert(0, _Left)));

  00041	48 8b c3	 mov	 rax, rbx

; 3831 : 	}

  00044	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00048	5b		 pop	 rbx
  00049	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@$$QEAV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z
_TEXT	SEGMENT
$T1 = 32
$T17 = 40
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3755 : 	{	// return string + string

$LN142:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00011	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T17[rsp], -2
  0001a	48 89 5c 24 68	 mov	 QWORD PTR [rsp+104], rbx
  0001f	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00024	49 8b f0	 mov	 rsi, r8
  00027	4c 8b f2	 mov	 r14, rdx
  0002a	48 8b f9	 mov	 rdi, rcx
  0002d	33 c0		 xor	 eax, eax
  0002f	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3698 : 		_My_data._Mysize = 0;

  00033	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00037	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0003f	88 01		 mov	 BYTE PTR [rcx], al
  00041	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  00049	4c 8d 62 10	 lea	 r12, QWORD PTR [rdx+16]
  0004d	4d 8d 78 10	 lea	 r15, QWORD PTR [r8+16]

; 3756 : 	basic_string<_Elem, _Traits, _Alloc> _Ans;
; 3757 : 	_Ans.reserve(_Left.size() + _Right.size());

  00051	49 8b 07	 mov	 rax, QWORD PTR [r15]
  00054	49 03 04 24	 add	 rax, QWORD PTR [r12]

; 3098 : 		if (_My_data._Mysize > _Newcap)

  00058	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]
  0005c	48 3b e8	 cmp	 rbp, rax
  0005f	0f 87 83 00 00
	00		 ja	 $LN50@operator

; 3099 : 			{	// requested capacity is not large enough for current size, ignore
; 3100 : 			return;	// nothing to do
; 3101 : 			}
; 3102 : 
; 3103 : 		if (_My_data._Myres == _Newcap)

  00065	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00069	48 3b c8	 cmp	 rcx, rax
  0006c	74 7a		 je	 SHORT $LN50@operator

; 3104 : 			{	// we're already at the requested capacity
; 3105 : 			return;	// nothing to do
; 3106 : 			}
; 3107 : 
; 3108 : 		if (_My_data._Myres < _Newcap)

  0006e	73 14		 jae	 SHORT $LN49@operator

; 3109 : 			{	// reallocate to grow
; 3110 : 			const size_type _Old_size = _My_data._Mysize;
; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00070	48 2b c5	 sub	 rax, rbp
  00073	48 8b d0	 mov	 rdx, rax
  00076	48 8b cf	 mov	 rcx, rdi
  00079	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  0007e	48 89 6f 10	 mov	 QWORD PTR [rdi+16], rbp

; 3117 : 			return;

  00082	eb 64		 jmp	 SHORT $LN50@operator
$LN49@operator:

; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00084	48 83 f8 10	 cmp	 rax, 16
  00088	73 5e		 jae	 SHORT $LN50@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0008a	48 83 f9 10	 cmp	 rcx, 16

; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0008e	72 58		 jb	 SHORT $LN50@operator

; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  00090	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00093	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00097	48 8b d3	 mov	 rdx, rbx
  0009a	48 8b cf	 mov	 rcx, rdi
  0009d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000a2	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  000a6	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000a9	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  000af	72 27		 jb	 SHORT $LN92@operator

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000b1	f6 c3 1f	 test	 bl, 31
  000b4	75 1b		 jne	 SHORT $_Invalid_parameter$143

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000b6	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000ba	48 3b c3	 cmp	 rax, rbx
  000bd	73 12		 jae	 SHORT $_Invalid_parameter$143
  000bf	48 2b d8	 sub	 rbx, rax
  000c2	48 83 eb 08	 sub	 rbx, 8
  000c6	48 83 fb 1f	 cmp	 rbx, 31
  000ca	77 05		 ja	 SHORT $_Invalid_parameter$143

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000cc	48 8b d8	 mov	 rbx, rax
  000cf	eb 07		 jmp	 SHORT $LN92@operator
$_Invalid_parameter$143:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000d1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000d7	cc		 int	 3
$LN92@operator:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000d8	48 8b cb	 mov	 rcx, rbx
  000db	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000e0	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
$LN50@operator:

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000e8	49 83 7e 18 10	 cmp	 QWORD PTR [r14+24], 16

; 1607 : 		if (_Large_string_engaged())

  000ed	72 03		 jb	 SHORT $LN117@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000ef	4d 8b 36	 mov	 r14, QWORD PTR [r14]
$LN117@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000f2	4d 8b 04 24	 mov	 r8, QWORD PTR [r12]
  000f6	49 8b d6	 mov	 rdx, r14
  000f9	48 8b cf	 mov	 rcx, rdi
  000fc	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00101	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16

; 1607 : 		if (_Large_string_engaged())

  00106	72 03		 jb	 SHORT $LN134@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00108	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN134@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  0010b	4d 8b 07	 mov	 r8, QWORD PTR [r15]
  0010e	48 8b d6	 mov	 rdx, rsi
  00111	48 8b cf	 mov	 rcx, rdi
  00114	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3758 : 	_Ans += _Left;
; 3759 : 	_Ans += _Right;
; 3760 : 	return (_Ans);

  00119	48 8b c7	 mov	 rax, rdi

; 3761 : 	}

  0011c	48 8b 5c 24 68	 mov	 rbx, QWORD PTR [rsp+104]
  00121	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
  00126	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0012a	41 5f		 pop	 r15
  0012c	41 5e		 pop	 r14
  0012e	41 5c		 pop	 r12
  00130	5f		 pop	 rdi
  00131	5e		 pop	 rsi
  00132	c3		 ret	 0
  00133	cc		 int	 3
$LN141@operator:
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T17 = 40
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T17 = 40
__$ReturnUdt$ = 96
_Left$ = 104
_Right$ = 112
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 60	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@0@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3884 : 	{	// return string + NTCTS

$LN75:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	49 8b c0	 mov	 rax, r8
  00009	4c 8b ca	 mov	 r9, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  0000c	49 83 c8 ff	 or	 r8, -1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3884 : 	{	// return string + NTCTS

  00010	48 8b d9	 mov	 rbx, rcx
$LL73@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00013	49 ff c0	 inc	 r8
  00016	42 80 3c 00 00	 cmp	 BYTE PTR [rax+r8], 0
  0001b	75 f6		 jne	 SHORT $LL73@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0001d	48 8b d0	 mov	 rdx, rax
  00020	49 8b c9	 mov	 rcx, r9
  00023	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1576 : 		_Mysize(0),

  00028	33 c9		 xor	 ecx, ecx
  0002a	48 89 4b 10	 mov	 QWORD PTR [rbx+16], rcx

; 1577 : 		_Myres(0)

  0002e	48 89 4b 18	 mov	 QWORD PTR [rbx+24], rcx

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00032	0f 10 00	 movups	 xmm0, XMMWORD PTR [rax]
  00035	0f 11 03	 movups	 XMMWORD PTR [rbx], xmm0
  00038	0f 10 48 10	 movups	 xmm1, XMMWORD PTR [rax+16]
  0003c	0f 11 4b 10	 movups	 XMMWORD PTR [rbx+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00040	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00044	48 c7 40 18 0f
	00 00 00	 mov	 QWORD PTR [rax+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0004c	88 08		 mov	 BYTE PTR [rax], cl
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3885 : 	return (_STD move(_Left.append(_Right)));

  0004e	48 8b c3	 mov	 rax, rbx

; 3886 : 	}

  00051	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00055	5b		 pop	 rbx
  00056	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z
_TEXT	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3799 : 	{	// return string + NTCTS

$LN132:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T15[rsp], -2
  00016	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0001b	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00020	49 8b e8	 mov	 rbp, r8
  00023	48 8b f1	 mov	 rsi, rcx
  00026	33 c0		 xor	 eax, eax
  00028	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3698 : 		_My_data._Mysize = 0;

  0002c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00030	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00038	88 01		 mov	 BYTE PTR [rcx], al
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1

; 480  : 		return (_CSTD strlen(_First));

  00042	48 83 cb ff	 or	 rbx, -1
  00046	48 8b c3	 mov	 rax, rbx
  00049	0f 1f 80 00 00
	00 00		 npad	 7
$LL130@operator:
  00050	48 ff c0	 inc	 rax
  00053	42 80 3c 00 00	 cmp	 BYTE PTR [rax+r8], 0
  00058	75 f6		 jne	 SHORT $LL130@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3803 : 	_Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));

  0005a	48 03 05 10 00
	00 00		 add	 rax, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16

; 3098 : 		if (_My_data._Mysize > _Newcap)

  00061	4c 8b 71 10	 mov	 r14, QWORD PTR [rcx+16]
  00065	4c 3b f0	 cmp	 r14, rax
  00068	0f 87 84 00 00
	00		 ja	 $LN46@operator

; 3099 : 			{	// requested capacity is not large enough for current size, ignore
; 3100 : 			return;	// nothing to do
; 3101 : 			}
; 3102 : 
; 3103 : 		if (_My_data._Myres == _Newcap)

  0006e	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00072	48 3b c8	 cmp	 rcx, rax
  00075	74 7b		 je	 SHORT $LN46@operator

; 3104 : 			{	// we're already at the requested capacity
; 3105 : 			return;	// nothing to do
; 3106 : 			}
; 3107 : 
; 3108 : 		if (_My_data._Myres < _Newcap)

  00077	73 14		 jae	 SHORT $LN45@operator

; 3109 : 			{	// reallocate to grow
; 3110 : 			const size_type _Old_size = _My_data._Mysize;
; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00079	49 2b c6	 sub	 rax, r14
  0007c	48 8b d0	 mov	 rdx, rax
  0007f	48 8b ce	 mov	 rcx, rsi
  00082	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00087	4c 89 76 10	 mov	 QWORD PTR [rsi+16], r14

; 3117 : 			return;

  0008b	eb 65		 jmp	 SHORT $LN46@operator
$LN45@operator:

; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0008d	48 83 f8 10	 cmp	 rax, 16
  00091	73 5f		 jae	 SHORT $LN46@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00093	48 83 f9 10	 cmp	 rcx, 16

; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00097	72 59		 jb	 SHORT $LN46@operator

; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  00099	48 8b 3e	 mov	 rdi, QWORD PTR [rsi]

; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  0009c	4d 8d 46 01	 lea	 r8, QWORD PTR [r14+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000a0	48 8b d7	 mov	 rdx, rdi
  000a3	48 8b ce	 mov	 rcx, rsi
  000a6	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  000ab	48 8b 46 18	 mov	 rax, QWORD PTR [rsi+24]
  000af	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000b2	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  000b8	72 28		 jb	 SHORT $LN88@operator

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000ba	40 f6 c7 1f	 test	 dil, 31
  000be	75 1b		 jne	 SHORT $_Invalid_parameter$133

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000c0	48 8b 47 f8	 mov	 rax, QWORD PTR [rdi-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000c4	48 3b c7	 cmp	 rax, rdi
  000c7	73 12		 jae	 SHORT $_Invalid_parameter$133
  000c9	48 2b f8	 sub	 rdi, rax
  000cc	48 83 ef 08	 sub	 rdi, 8
  000d0	48 83 ff 1f	 cmp	 rdi, 31
  000d4	77 05		 ja	 SHORT $_Invalid_parameter$133

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000d6	48 8b f8	 mov	 rdi, rax
  000d9	eb 07		 jmp	 SHORT $LN88@operator
$_Invalid_parameter$133:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000db	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000e1	cc		 int	 3
$LN88@operator:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000e2	48 8b cf	 mov	 rcx, rdi
  000e5	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000ea	48 c7 46 18 0f
	00 00 00	 mov	 QWORD PTR [rsi+24], 15
$LN46@operator:

; 1606 : 		const value_type * _Result = _Bx._Buf;

  000f2	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A ; G³os

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000f9	48 83 3d 18 00
	00 00 10	 cmp	 QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+24, 16

; 1607 : 		if (_Large_string_engaged())

  00101	48 0f 43 15 00
	00 00 00	 cmovae	 rdx, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  00109	4c 8b 05 10 00
	00 00		 mov	 r8, QWORD PTR ?G³os@@3V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@A+16
  00110	48 8b ce	 mov	 rcx, rsi
  00113	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append
  00118	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL129@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00120	48 ff c3	 inc	 rbx
  00123	80 3c 2b 00	 cmp	 BYTE PTR [rbx+rbp], 0
  00127	75 f7		 jne	 SHORT $LL129@operator
  00129	4c 8b c3	 mov	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  0012c	48 8b d5	 mov	 rdx, rbp
  0012f	48 8b ce	 mov	 rcx, rsi
  00132	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3804 : 	_Ans += _Left;
; 3805 : 	_Ans += _Right;
; 3806 : 	return (_Ans);

  00137	48 8b c6	 mov	 rax, rsi

; 3807 : 	}

  0013a	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  0013f	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00144	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00148	41 5e		 pop	 r14
  0014a	5f		 pop	 rdi
  0014b	5e		 pop	 rsi
  0014c	c3		 ret	 0
  0014d	cc		 int	 3
$LN131@operator:
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@QEBD@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z
_TEXT	SEGMENT
__$ReturnUdt$ = 48
_Left$ = 56
_Right$ = 64
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3894 : 	{	// return string + character

$LN89:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0000a	48 8b f9	 mov	 rdi, rcx
  0000d	48 8b da	 mov	 rbx, rdx

; 2991 : 		const size_type _Old_size = _My_data._Mysize;

  00010	48 8b 4a 10	 mov	 rcx, QWORD PTR [rdx+16]

; 2992 : 		if (_Old_size < _My_data._Myres)

  00014	48 8b 52 18	 mov	 rdx, QWORD PTR [rdx+24]
  00018	48 3b ca	 cmp	 rcx, rdx
  0001b	73 1f		 jae	 SHORT $LN6@operator

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  0001d	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  00021	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00025	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00028	48 83 fa 10	 cmp	 rdx, 16

; 1596 : 		if (_Large_string_engaged())

  0002c	72 03		 jb	 SHORT $LN15@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0002e	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN15@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00031	44 88 04 08	 mov	 BYTE PTR [rax+rcx], r8b
  00035	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  0003a	eb 0c		 jmp	 SHORT $LN5@operator
$LN6@operator:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  0003c	45 0f b6 c8	 movzx	 r9d, r8b
  00040	48 8b cb	 mov	 rcx, rbx
  00043	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN5@operator:

; 1576 : 		_Mysize(0),

  00048	33 c0		 xor	 eax, eax
  0004a	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1577 : 		_Myres(0)

  0004e	48 89 47 18	 mov	 QWORD PTR [rdi+24], rax

; 2152 : 		_CSTD memcpy(_My_data_mem, _Right_data_mem, _Memcpy_move_size);

  00052	0f 10 03	 movups	 xmm0, XMMWORD PTR [rbx]
  00055	0f 11 07	 movups	 XMMWORD PTR [rdi], xmm0
  00058	0f 10 4b 10	 movups	 xmm1, XMMWORD PTR [rbx+16]
  0005c	0f 11 4f 10	 movups	 XMMWORD PTR [rdi+16], xmm1

; 3698 : 		_My_data._Mysize = 0;

  00060	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00064	48 c7 43 18 0f
	00 00 00	 mov	 QWORD PTR [rbx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0006c	88 03		 mov	 BYTE PTR [rbx], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3896 : 	return (_STD move(_Left));

  0006e	48 8b c7	 mov	 rax, rdi

; 3897 : 	}

  00071	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]
  00076	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0007a	5f		 pop	 rdi
  0007b	c3		 ret	 0
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@$$QEAV10@D@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Istr$ = 48
_Str$ = 56
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 158  : 	{	// get characters into string, discard newline

$LN7:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  0000a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0000d	48 8b f9	 mov	 rdi, rcx
  00010	48 8b da	 mov	 rbx, rdx
  00013	b2 0a		 mov	 dl, 10
  00015	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00019	48 03 cf	 add	 rcx, rdi
  0001c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?widen@?$basic_ios@DU?$char_traits@D@std@@@std@@QEBADD@Z
  00022	48 8b d3	 mov	 rdx, rbx
  00025	48 8b cf	 mov	 rcx, rdi
  00028	44 0f b6 c0	 movzx	 r8d, al

; 160  : 	}

  0002c	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00031	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00035	5f		 pop	 rdi

; 159  : 	return (getline(_STD move(_Istr), _Str, _Istr.widen('\n')));

  00036	e9 00 00 00 00	 jmp	 ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ; std::getline<char,std::char_traits<char>,std::allocator<char> >
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z
_TEXT	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z PROC ; std::operator+<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 3769 : 	{	// return NTCTS + string

$LN130:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 56		 push	 r14
  00009	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000d	48 c7 44 24 28
	fe ff ff ff	 mov	 QWORD PTR $T15[rsp], -2
  00016	48 89 5c 24 58	 mov	 QWORD PTR [rsp+88], rbx
  0001b	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  00020	49 8b f0	 mov	 rsi, r8
  00023	48 8b f9	 mov	 rdi, rcx
  00026	33 c0		 xor	 eax, eax
  00028	89 44 24 20	 mov	 DWORD PTR $T1[rsp], eax

; 3698 : 		_My_data._Mysize = 0;

  0002c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 3699 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00030	48 c7 41 18 0f
	00 00 00	 mov	 QWORD PTR [rcx+24], 15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00038	88 01		 mov	 BYTE PTR [rcx], al
  0003a	c7 44 24 20 01
	00 00 00	 mov	 DWORD PTR $T1[rsp], 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  00042	4d 8d 70 10	 lea	 r14, QWORD PTR [r8+16]

; 3770 : 	using _String_type = basic_string<_Elem, _Traits, _Alloc>;
; 3771 : 	using _Size_type = typename _String_type::size_type;
; 3772 : 	_String_type _Ans;
; 3773 : 	_Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));

  00046	49 8b 06	 mov	 rax, QWORD PTR [r14]
  00049	48 83 c0 05	 add	 rax, 5

; 3098 : 		if (_My_data._Mysize > _Newcap)

  0004d	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]
  00051	48 3b e8	 cmp	 rbp, rax
  00054	0f 87 83 00 00
	00		 ja	 $LN46@operator

; 3099 : 			{	// requested capacity is not large enough for current size, ignore
; 3100 : 			return;	// nothing to do
; 3101 : 			}
; 3102 : 
; 3103 : 		if (_My_data._Myres == _Newcap)

  0005a	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0005e	48 3b c8	 cmp	 rcx, rax
  00061	74 7a		 je	 SHORT $LN46@operator

; 3104 : 			{	// we're already at the requested capacity
; 3105 : 			return;	// nothing to do
; 3106 : 			}
; 3107 : 
; 3108 : 		if (_My_data._Myres < _Newcap)

  00063	73 14		 jae	 SHORT $LN45@operator

; 3109 : 			{	// reallocate to grow
; 3110 : 			const size_type _Old_size = _My_data._Mysize;
; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00065	48 2b c5	 sub	 rax, rbp
  00068	48 8b d0	 mov	 rdx, rax
  0006b	48 8b cf	 mov	 rcx, rdi
  0006e	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  00073	48 89 6f 10	 mov	 QWORD PTR [rdi+16], rbp

; 3117 : 			return;

  00077	eb 64		 jmp	 SHORT $LN46@operator
$LN45@operator:

; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00079	48 83 f8 10	 cmp	 rax, 16
  0007d	73 5e		 jae	 SHORT $LN46@operator

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0007f	48 83 f9 10	 cmp	 rcx, 16

; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00083	72 58		 jb	 SHORT $LN46@operator

; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  00085	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]

; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  00088	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0008c	48 8b d3	 mov	 rdx, rbx
  0008f	48 8b cf	 mov	 rcx, rdi
  00092	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  00097	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  0009b	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0009e	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  000a4	72 27		 jb	 SHORT $LN88@operator

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000a6	f6 c3 1f	 test	 bl, 31
  000a9	75 1b		 jne	 SHORT $_Invalid_parameter$131

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000ab	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000af	48 3b c3	 cmp	 rax, rbx
  000b2	73 12		 jae	 SHORT $_Invalid_parameter$131
  000b4	48 2b d8	 sub	 rbx, rax
  000b7	48 83 eb 08	 sub	 rbx, 8
  000bb	48 83 fb 1f	 cmp	 rbx, 31
  000bf	77 05		 ja	 SHORT $_Invalid_parameter$131

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000c1	48 8b d8	 mov	 rbx, rax
  000c4	eb 07		 jmp	 SHORT $LN88@operator
$_Invalid_parameter$131:

; 152  : 	return;
; 153  : 
; 154  : _Invalid_parameter:
; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000c6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000cc	cc		 int	 3
$LN88@operator:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000cd	48 8b cb	 mov	 rcx, rbx
  000d0	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  000d5	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
$LN46@operator:

; 2371 : 		return (append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr))));

  000dd	41 b8 05 00 00
	00		 mov	 r8d, 5
  000e3	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_05CMOJBPHN@G?$LDos?1?$AA@
  000ea	48 8b cf	 mov	 rcx, rdi
  000ed	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000f2	48 83 7e 18 10	 cmp	 QWORD PTR [rsi+24], 16

; 1607 : 		if (_Large_string_engaged())

  000f7	72 03		 jb	 SHORT $LN122@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000f9	48 8b 36	 mov	 rsi, QWORD PTR [rsi]
$LN122@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2321 : 		return (append(_Right_data._Myptr(), _Right_data._Mysize));

  000fc	4d 8b 06	 mov	 r8, QWORD PTR [r14]
  000ff	48 8b d6	 mov	 rdx, rsi
  00102	48 8b cf	 mov	 rcx, rdi
  00105	e8 00 00 00 00	 call	 ?append@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@QEBD_K@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::append

; 3774 : 	_Ans += _Left;
; 3775 : 	_Ans += _Right;
; 3776 : 	return (_Ans);

  0010a	48 8b c7	 mov	 rax, rdi

; 3777 : 	}

  0010d	48 8b 5c 24 58	 mov	 rbx, QWORD PTR [rsp+88]
  00112	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
  00117	48 83 c4 30	 add	 rsp, 48			; 00000030H
  0011b	41 5e		 pop	 r14
  0011d	5f		 pop	 rdi
  0011e	5e		 pop	 rsi
  0011f	c3		 ret	 0
  00120	cc		 int	 3
$LN129@operator:
??$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z ENDP ; std::operator+<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 32
$T15 = 40
__$ReturnUdt$ = 80
_Left$dead$ = 88
_Right$ = 96
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA PROC ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  00000	40 55		 push	 rbp
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b ea	 mov	 rbp, rdx
  00009	8b 45 20	 mov	 eax, DWORD PTR $T1[rbp]
  0000c	83 e0 01	 and	 eax, 1
  0000f	85 c0		 test	 eax, eax
  00011	74 0d		 je	 SHORT $LN4@dtor$0
  00013	83 65 20 fe	 and	 DWORD PTR $T1[rbp], -2
  00017	48 8b 4d 50	 mov	 rcx, QWORD PTR __$ReturnUdt$[rbp]
  0001b	e8 00 00 00 00	 call	 ??1?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAA@XZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::~basic_string<char,std::char_traits<char>,std::allocator<char> >
$LN4@dtor$0:
  00020	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00024	5d		 pop	 rbp
  00025	c3		 ret	 0
?dtor$0@?0???$?HDU?$char_traits@D@std@@V?$allocator@D@1@@std@@YA?AV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@QEBDAEBV10@@Z@4HA ENDP ; `std::operator+<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Ostr$ = 8
_Str$ = 16
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 7a 18 10	 cmp	 QWORD PTR [rdx+24], 16

; 3062 : 		return (this->_Get_data()._Mysize);

  00005	4c 8b 42 10	 mov	 r8, QWORD PTR [rdx+16]

; 1607 : 		if (_Large_string_engaged())

  00009	72 03		 jb	 SHORT $LN22@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000b	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
$LN22@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 169  : 	return (_Insert_string(_Ostr, _Str.data(), _Str.size()));

  0000e	e9 00 00 00 00	 jmp	 ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
??$?6DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@AEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator<<<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z PROC		; std::size<char,32>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 20 00 00 00	 mov	 eax, 32			; 00000020H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0CA@@std@@YA_KAEAY0CA@$$CBD@Z ENDP		; std::size<char,32>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z PROC		; std::size<char,38>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 26 00 00 00	 mov	 eax, 38			; 00000026H

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0CG@@std@@YA_KAEAY0CG@$$CBD@Z ENDP		; std::size<char,38>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z PROC		; std::size<char,28>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 1c 00 00 00	 mov	 eax, 28

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BM@@std@@YA_KAEAY0BM@$$CBD@Z ENDP		; std::size<char,28>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z PROC		; std::size<char,27>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 1b 00 00 00	 mov	 eax, 27

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BL@@std@@YA_KAEAY0BL@$$CBD@Z ENDP		; std::size<char,27>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z PROC		; std::size<char,23>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 17 00 00 00	 mov	 eax, 23

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BH@@std@@YA_KAEAY0BH@$$CBD@Z ENDP		; std::size<char,23>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z PROC		; std::size<char,17>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 11 00 00 00	 mov	 eax, 17

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BB@@std@@YA_KAEAY0BB@$$CBD@Z ENDP		; std::size<char,17>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z PROC		; std::size<char,14>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 0e 00 00 00	 mov	 eax, 14

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0O@@std@@YA_KAEAY0O@$$CBD@Z ENDP		; std::size<char,14>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z PROC		; std::size<char,20>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 14 00 00 00	 mov	 eax, 20

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BE@@std@@YA_KAEAY0BE@$$CBD@Z ENDP		; std::size<char,20>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z PROC		; std::size<char,29>, COMDAT

; 1474 : 	return (_Size);

  00000	b8 1d 00 00 00	 mov	 eax, 29

; 1475 : 	}

  00005	c3		 ret	 0
??$size@D$0BN@@std@@YA_KAEAY0BN@$$CBD@Z ENDP		; std::size<char,29>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z
_TEXT	SEGMENT
_Haystack$ = 48
_Hay_size$ = 56
_Start_at$dead$ = 64
_Needle$ = 72
_Needle_size$ = 80
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z PROC ; std::_Traits_find<std::char_traits<char> >, COMDAT

; 56   : 	{	// search [_Haystack, _Haystack + _Hay_size) for [_Needle, _Needle + _Needle_size), at/after _Start_at

$LN26:
  00000	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 57   : 	if (_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)

  00010	48 8b 74 24 50	 mov	 rsi, QWORD PTR _Needle_size$[rsp]
  00015	49 8b f9	 mov	 rdi, r9
  00018	4c 8b f1	 mov	 r14, rcx
  0001b	48 3b f2	 cmp	 rsi, rdx
  0001e	0f 87 a3 00 00
	00		 ja	 $LN6@Traits_fin

; 58   : 		{	// xpos cannot exist, report failure
; 59   : 			// N4659 24.3.2.7.2 [string.find]/1 says:
; 60   : 			// 1. _Start_at <= xpos
; 61   : 			// 2. xpos + _Needle_size <= _Hay_size;
; 62   : 			// therefore:
; 63   : 			// 3. _Needle_size <= _Hay_size (by 2) (checked above)
; 64   : 			// 4. _Start_at + _Needle_size <= _Hay_size (substitute 1 into 2)
; 65   : 			// 5. _Start_at <= _Hay_size - _Needle_size (4, move _Needle_size to other side) (also checked above)
; 66   : 		return (static_cast<size_t>(-1));
; 67   : 		}
; 68   : 
; 69   : 	if (_Needle_size == 0)

  00024	48 85 f6	 test	 rsi, rsi
  00027	75 13		 jne	 SHORT $LN7@Traits_fin

; 70   : 		{	// empty string always matches if xpos is possible
; 71   : 		return (_Start_at);

  00029	33 c0		 xor	 eax, eax

; 86   : 			}
; 87   : 		}
; 88   : 	}

  0002b	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00030	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00035	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00039	41 5e		 pop	 r14
  0003b	c3		 ret	 0
$LN7@Traits_fin:

; 72   : 		}
; 73   : 
; 74   : 	const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;

  0003c	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx
  00041	48 89 6c 24 38	 mov	 QWORD PTR [rsp+56], rbp
  00046	49 8b ee	 mov	 rbp, r14
  00049	48 2b ee	 sub	 rbp, rsi
  0004c	48 03 ea	 add	 rbp, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0004f	41 0f be 11	 movsx	 edx, BYTE PTR [r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00053	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00057	4d 2b c6	 sub	 r8, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0005a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00060	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  00063	48 85 c0	 test	 rax, rax
  00066	74 38		 je	 SHORT $LN18@Traits_fin
  00068	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL4@Traits_fin:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  00070	4c 8b c6	 mov	 r8, rsi
  00073	48 8b d7	 mov	 rdx, rdi
  00076	48 8b cb	 mov	 rcx, rbx
  00079	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 83   : 		if (_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)

  0007e	85 c0		 test	 eax, eax
  00080	74 3d		 je	 SHORT $LN19@Traits_fin
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  00082	0f be 17	 movsx	 edx, BYTE PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 77   : 		_Match_try = _Traits::find(_Match_try, _Possible_matches_end - _Match_try, *_Needle);

  00085	4c 8d 45 01	 lea	 r8, QWORD PTR [rbp+1]
  00089	48 ff c3	 inc	 rbx
  0008c	4c 2b c3	 sub	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 500  : 		return ((const _Elem *)_CSTD memchr(_First, _Ch, _Count));

  0008f	48 8b cb	 mov	 rcx, rbx
  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memchr
  00098	48 8b d8	 mov	 rbx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 78   : 		if (!_Match_try)

  0009b	48 85 c0	 test	 rax, rax
  0009e	75 d0		 jne	 SHORT $LL4@Traits_fin
$LN18@Traits_fin:

; 79   : 			{	// didn't find first character; report failure
; 80   : 			return (static_cast<size_t>(-1));

  000a0	48 83 c8 ff	 or	 rax, -1
$LN24@Traits_fin:
  000a4	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  000a9	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000ae	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000b3	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000b8	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000bc	41 5e		 pop	 r14
  000be	c3		 ret	 0
$LN19@Traits_fin:

; 84   : 			{	// found match
; 85   : 			return (_Match_try - _Haystack);

  000bf	49 2b de	 sub	 rbx, r14
  000c2	48 8b c3	 mov	 rax, rbx
  000c5	eb dd		 jmp	 SHORT $LN24@Traits_fin
$LN6@Traits_fin:

; 86   : 			}
; 87   : 		}
; 88   : 	}

  000c7	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  000cc	48 83 c8 ff	 or	 rax, -1
  000d0	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  000d5	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000d9	41 5e		 pop	 r14
  000db	c3		 ret	 0
??$_Traits_find@U?$char_traits@D@std@@@std@@YA_KQEBD_K101@Z ENDP ; std::_Traits_find<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
;	COMDAT ??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z
_TEXT	SEGMENT
_Left$ = 8
_Right$ = 16
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z PROC		; std::_Min_value<unsigned __int64>, COMDAT

; 23   : 	return (_Right < _Left ? _Right : _Left);

  00000	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00003	48 39 02	 cmp	 QWORD PTR [rdx], rax
  00006	48 0f 42 ca	 cmovb	 rcx, rdx
  0000a	48 8b c1	 mov	 rax, rcx

; 24   : 	}

  0000d	c3		 ret	 0
??$_Min_value@_K@std@@YAAEB_KAEB_K0@Z ENDP		; std::_Min_value<unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$_Unfancy@D@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Unfancy@D@std@@YAPEADPEAD@Z PROC			; std::_Unfancy<char>, COMDAT

; 265  : 	return (_Ptr);

  00000	48 8b c1	 mov	 rax, rcx

; 266  : 	}

  00003	c3		 ret	 0
??$_Unfancy@D@std@@YAPEADPEAD@Z ENDP			; std::_Unfancy<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@$$CBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEBV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEBV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > const >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@V?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YAPEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::addressof<std::basic_string<char,std::char_traits<char>,std::allocator<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z PROC ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>, COMDAT

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1608 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@@std@@YA$$QEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@AEAV10@@Z ENDP ; std::move<std::basic_string<char,std::char_traits<char>,std::allocator<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::move<std::allocator<char> & __ptr64>, COMDAT

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1608 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::move<std::allocator<char> & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>, COMDAT

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1711 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0V?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@$$QEAV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char>,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
;	COMDAT ??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z
_TEXT	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z PROC ; std::use_facet<std::codecvt<char,char,_Mbstatet> >, COMDAT

; 505  : 	{	// get facet reference from locale

$LN23:
  00000	4c 8b dc	 mov	 r11, rsp
  00003	57		 push	 rdi
  00004	48 83 ec 60	 sub	 rsp, 96			; 00000060H
  00008	49 c7 43 b8 fe
	ff ff ff	 mov	 QWORD PTR [r11-72], -2
  00010	49 89 5b 10	 mov	 QWORD PTR [r11+16], rbx
  00014	49 89 73 18	 mov	 QWORD PTR [r11+24], rsi
  00018	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR __security_cookie
  0001f	48 33 c4	 xor	 rax, rsp
  00022	48 89 44 24 50	 mov	 QWORD PTR __$ArrayPad$[rsp], rax
  00027	48 8b f1	 mov	 rsi, rcx

; 506  : 	_BEGIN_LOCK(_LOCK_LOCALE)	// the thread lock, make get atomic

  0002a	33 d2		 xor	 edx, edx
  0002c	49 8d 4b e0	 lea	 rcx, QWORD PTR [r11-32]
  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??0_Lockit@std@@QEAA@H@Z
  00036	90		 npad	 1

; 507  : 		const locale::facet *_Psave =
; 508  : 			_Facetptr<_Facet>::_Psave;	// static pointer to lazy facet

  00037	48 8b 05 00 00
	00 00		 mov	 rax, QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave
  0003e	48 89 44 24 40	 mov	 QWORD PTR _Psave$3[rsp], rax

; 509  : 
; 510  : 		size_t _Id = _Facet::id;

  00043	48 8b 0d 00 00
	00 00		 mov	 rcx, QWORD PTR __imp_?id@?$codecvt@DDU_Mbstatet@@@std@@2V0locale@2@A
  0004a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??Bid@locale@std@@QEAA_KXZ
  00050	48 8b f8	 mov	 rdi, rax

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  00053	48 8b 46 08	 mov	 rax, QWORD PTR [rsi+8]
  00057	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0005b	73 0f		 jae	 SHORT $LN15@use_facet
  0005d	48 8b 48 10	 mov	 rcx, QWORD PTR [rax+16]
  00061	48 8b 1c f9	 mov	 rbx, QWORD PTR [rcx+rdi*8]

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  00065	48 85 db	 test	 rbx, rbx
  00068	75 7b		 jne	 SHORT $LN7@use_facet
  0006a	eb 02		 jmp	 SHORT $LN19@use_facet
$LN15@use_facet:

; 431  : 		const facet *_Facptr = _Id < _Ptr->_Facetcount

  0006c	33 db		 xor	 ebx, ebx
$LN19@use_facet:

; 432  : 			? _Ptr->_Facetvec[_Id] : 0;	// null if id off end
; 433  : 		if (_Facptr != 0 || !_Ptr->_Xparent)

  0006e	80 78 24 00	 cmp	 BYTE PTR [rax+36], 0
  00072	74 14		 je	 SHORT $LN12@use_facet

; 434  : 			return (_Facptr);	// found facet or not transparent
; 435  : 		else
; 436  : 			{	// look in current locale
; 437  : 			locale::_Locimp *_Ptr0 = _Getgloballocale();

  00074	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getgloballocale@locale@std@@CAPEAV_Locimp@12@XZ

; 438  : 			return (_Id < _Ptr0->_Facetcount

  0007a	48 3b 78 18	 cmp	 rdi, QWORD PTR [rax+24]
  0007e	73 0d		 jae	 SHORT $LN20@use_facet
  00080	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00084	48 8b 1c f8	 mov	 rbx, QWORD PTR [rax+rdi*8]
$LN12@use_facet:

; 511  : 		const locale::facet *_Pf = _Loc._Getfacet(_Id);
; 512  : 
; 513  : 		if (_Pf != 0)

  00088	48 85 db	 test	 rbx, rbx
  0008b	75 58		 jne	 SHORT $LN7@use_facet
$LN20@use_facet:

; 514  : 			;	// got facet from locale
; 515  : 		else if (_Psave != 0)

  0008d	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]
  00092	48 85 db	 test	 rbx, rbx
  00095	75 4e		 jne	 SHORT $LN7@use_facet

; 516  : 			_Pf = _Psave;	// lazy facet already allocated
; 517  : 		else if (_Facet::_Getcat(&_Psave, &_Loc) == (size_t)(-1))

  00097	48 8b d6	 mov	 rdx, rsi
  0009a	48 8d 4c 24 40	 lea	 rcx, QWORD PTR _Psave$3[rsp]
  0009f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Getcat@?$codecvt@DDU_Mbstatet@@@std@@SA_KPEAPEBVfacet@locale@2@PEBV42@@Z
  000a5	48 83 f8 ff	 cmp	 rax, -1
  000a9	75 1c		 jne	 SHORT $LN6@use_facet

; 518  : 
; 519  :  #if _HAS_EXCEPTIONS
; 520  : 
; 521  : 			_THROW(bad_cast, _EMPTY_ARGUMENT);	// lazy disallowed

  000ab	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000b0	e8 00 00 00 00	 call	 ??0bad_cast@std@@QEAA@XZ ; std::bad_cast::bad_cast
  000b5	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:_TI2?AVbad_cast@std@@
  000bc	48 8d 4c 24 28	 lea	 rcx, QWORD PTR $T1[rsp]
  000c1	e8 00 00 00 00	 call	 _CxxThrowException
  000c6	cc		 int	 3
$LN6@use_facet:

; 522  : 
; 523  :  #else /* _HAS_EXCEPTIONS */
; 524  : 			abort();	// lazy disallowed
; 525  :  #endif /* _HAS_EXCEPTIONS */
; 526  : 
; 527  : 		else
; 528  : 			{	// queue up lazy facet for destruction
; 529  : 			_Pf = _Psave;

  000c7	48 8b 5c 24 40	 mov	 rbx, QWORD PTR _Psave$3[rsp]

; 530  : 			_Facetptr<_Facet>::_Psave = _Psave;

  000cc	48 89 1d 00 00
	00 00		 mov	 QWORD PTR ?_Psave@?$_Facetptr@V?$codecvt@DDU_Mbstatet@@@std@@@std@@2PEBVfacet@locale@2@EB, rbx ; std::_Facetptr<std::codecvt<char,char,_Mbstatet> >::_Psave

; 531  : 
; 532  : 			locale::facet *_Pfmod = (_Facet *)_Psave;
; 533  : 			_Pfmod->_Incref();

  000d3	48 8b 03	 mov	 rax, QWORD PTR [rbx]
  000d6	48 8b cb	 mov	 rcx, rbx
  000d9	ff 50 08	 call	 QWORD PTR [rax+8]

; 534  : 
; 535  :  #if defined(_M_CEE)
; 536  : 			_Facet_Register_m(_Pfmod);
; 537  : 
; 538  :  #else /* defined(_M_CEE) */
; 539  : 			_Facet_Register(_Pfmod);

  000dc	48 8b cb	 mov	 rcx, rbx
  000df	e8 00 00 00 00	 call	 ?_Facet_Register@std@@YAXPEAV_Facet_base@1@@Z ; std::_Facet_Register
  000e4	90		 npad	 1
$LN7@use_facet:

; 540  :  #endif /* defined(_M_CEE) */
; 541  : 			}
; 542  : 
; 543  : 		return ((const _Facet&)(*_Pf));	// should be dynamic_cast

  000e5	48 8d 4c 24 48	 lea	 rcx, QWORD PTR _Lock$4[rsp]
  000ea	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
  000f0	48 8b c3	 mov	 rax, rbx

; 544  : 	_END_LOCK()
; 545  : 	}	// end of use_facet body

  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR __$ArrayPad$[rsp]
  000f8	48 33 cc	 xor	 rcx, rsp
  000fb	e8 00 00 00 00	 call	 __security_check_cookie
  00100	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  00105	48 8b b4 24 80
	00 00 00	 mov	 rsi, QWORD PTR [rsp+128]
  0010d	48 83 c4 60	 add	 rsp, 96			; 00000060H
  00111	5f		 pop	 rdi
  00112	c3		 ret	 0
$LN21@use_facet:
??$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z ENDP ; std::use_facet<std::codecvt<char,char,_Mbstatet> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T1 = 40
_Psave$3 = 64
_Lock$4 = 72
__$ArrayPad$ = 80
_Loc$ = 112
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA PROC ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
  00000	48 8d 8a 48 00
	00 00		 lea	 rcx, QWORD PTR _Lock$4[rdx]
  00007	48 ff 25 00 00
	00 00		 rex_jmp QWORD PTR __imp_??1_Lockit@std@@QEAA@XZ
?dtor$0@?0???$use_facet@V?$codecvt@DDU_Mbstatet@@@std@@@std@@YAAEBV?$codecvt@DDU_Mbstatet@@@0@AEBVlocale@0@@Z@4HA ENDP ; `std::use_facet<std::codecvt<char,char,_Mbstatet> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@D@std@@YAPEADAEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@D@std@@YAPEADAEAD@Z PROC			; std::addressof<char>, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@D@std@@YAPEADAEAD@Z ENDP			; std::addressof<char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1053 : 	typename allocator_traits<_Alloc>::propagate_on_container_move_assignment _Tag;
; 1054 : 	_Pocma(_Left, _Right, _Tag);
; 1055 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1034 : 	typename allocator_traits<_Alloc>::propagate_on_container_copy_assignment _Tag;
; 1035 : 	_Pocca(_Left, _Right, _Tag);
; 1036 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 304  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_Zero_then_variadic_args_t@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z PROC		; std::addressof<char * __ptr64>, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@PEAD@std@@YAPEAPEADAEAPEAD@Z ENDP		; std::addressof<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$dead$ = 16
??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>, COMDAT

; 862  : 		_Ptr->~_Uty();
; 863  : 		}

  00000	c2 00 00	 ret	 0
??$destroy@PEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::destroy<char * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$dead$ = 88
_Fn$dead$ = 96
<_Args_0>$ = 104
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>, COMDAT

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	57		 push	 rdi
  00004	41 55		 push	 r13
  00006	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;

  0000a	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]

; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000e	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 8b c3	 mov	 rax, rbx
  0001b	45 0f b6 e9	 movzx	 r13d, r9b
  0001f	48 2b c5	 sub	 rax, rbp
  00022	48 8b f9	 mov	 rdi, rcx
  00025	48 83 f8 01	 cmp	 rax, 1
  00029	0f 82 46 01 00
	00		 jb	 $LN147@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002f	4c 89 64 24 60	 mov	 QWORD PTR [rsp+96], r12
  00034	4c 8d 65 01	 lea	 r12, QWORD PTR [rbp+1]
  00038	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0003d	4c 8b 79 18	 mov	 r15, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00041	49 8b cc	 mov	 rcx, r12
  00044	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  00048	48 3b cb	 cmp	 rcx, rbx
  0004b	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  0004d	49 8b d7	 mov	 rdx, r15
  00050	48 8b c3	 mov	 rax, rbx
  00053	48 d1 ea	 shr	 rdx, 1
  00056	48 2b c2	 sub	 rax, rdx
  00059	4c 3b f8	 cmp	 r15, rax
  0005c	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005e	4a 8d 04 3a	 lea	 rax, QWORD PTR [rdx+r15]
  00062	48 8b d9	 mov	 rbx, rcx
  00065	48 3b c8	 cmp	 rcx, rax
  00068	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006c	48 8b cb	 mov	 rcx, rbx
  0006f	48 89 74 24 58	 mov	 QWORD PTR [rsp+88], rsi
  00074	48 83 c1 01	 add	 rcx, 1
  00078	4c 89 74 24 68	 mov	 QWORD PTR [rsp+104], r14
  0007d	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00084	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00088	45 33 f6	 xor	 r14d, r14d
  0008b	48 85 c9	 test	 rcx, rcx
  0008e	75 05		 jne	 SHORT $LN76@Reallocate
  00090	41 8b f6	 mov	 esi, r14d
  00093	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00095	45 84 f6	 test	 r14b, r14b
  00098	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0009a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000a0	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  000a1	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a8	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000aa	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000ae	48 3b c1	 cmp	 rax, rcx
  000b1	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000b9	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000ba	48 8b c8	 mov	 rcx, rax
  000bd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000c2	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000c6	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000ca	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000ce	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000d0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d5	48 8b f0	 mov	 rsi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000d8	4c 89 67 10	 mov	 QWORD PTR [rdi+16], r12
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000dc	4c 8b c5	 mov	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3657 : 		_My_data._Myres = _New_capacity;

  000df	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e3	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e6	49 83 ff 10	 cmp	 r15, 16
  000ea	72 54		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ec	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ef	48 8b d3	 mov	 rdx, rbx
  000f2	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000f7	49 ff c7	 inc	 r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000fa	44 88 2c 2e	 mov	 BYTE PTR [rsi+rbp], r13b
  000fe	c6 44 2e 01 00	 mov	 BYTE PTR [rsi+rbp+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00103	45 84 f6	 test	 r14b, r14b
  00106	75 31		 jne	 SHORT $_Invalid_parameter$149

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00108	49 81 ff 00 10
	00 00		 cmp	 r15, 4096		; 00001000H
  0010f	72 1e		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00111	f6 c3 1f	 test	 bl, 31
  00114	75 23		 jne	 SHORT $_Invalid_parameter$149

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00116	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0011a	48 3b c3	 cmp	 rax, rbx
  0011d	73 1a		 jae	 SHORT $_Invalid_parameter$149
  0011f	48 2b d8	 sub	 rbx, rax
  00122	48 83 eb 08	 sub	 rbx, 8
  00126	48 83 fb 1f	 cmp	 rbx, 31
  0012a	77 0d		 ja	 SHORT $_Invalid_parameter$149

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0012c	48 8b d8	 mov	 rbx, rax
$LN108@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0012f	48 8b cb	 mov	 rcx, rbx
  00132	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3666 : 		else

  00137	eb 18		 jmp	 SHORT $LN146@Reallocate
$_Invalid_parameter$149:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00139	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0013f	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00140	48 8b d7	 mov	 rdx, rdi
  00143	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  00148	44 88 2c 2e	 mov	 BYTE PTR [rsi+rbp], r13b
  0014c	c6 44 2e 01 00	 mov	 BYTE PTR [rsi+rbp+1], 0
$LN146@Reallocate:
  00151	4c 8b 74 24 68	 mov	 r14, QWORD PTR [rsp+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  00156	48 8b c7	 mov	 rax, rdi
  00159	4c 8b 64 24 60	 mov	 r12, QWORD PTR [rsp+96]
  0015e	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00163	48 89 37	 mov	 QWORD PTR [rdi], rsi
  00166	48 8b 74 24 58	 mov	 rsi, QWORD PTR [rsp+88]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3673 : 		}

  0016b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0016f	41 5d		 pop	 r13
  00171	5f		 pop	 rdi
  00172	5d		 pop	 rbp
  00173	5b		 pop	 rbx
  00174	c3		 ret	 0
$LN147@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00175	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  0017a	cc		 int	 3
$LN145@Reallocate:
??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
;	COMDAT ??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Val$ = 8
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z PROC ; std::addressof<std::_String_val<std::_Simple_types<char> > >, COMDAT

; 249  : 	return (__builtin_addressof(_Val));

  00000	48 8b c1	 mov	 rax, rcx

; 250  : 	}

  00003	c3		 ret	 0
??$addressof@V?$_String_val@U?$_Simple_types@D@std@@@std@@@std@@YAPEAV?$_String_val@U?$_Simple_types@D@std@@@0@AEAV10@@Z ENDP ; std::addressof<std::_String_val<std::_Simple_types<char> > >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z
_TEXT	SEGMENT
_Ptr$ = 8
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z PROC		; std::_Refancy<char * __ptr64,0>, COMDAT

; 344  : 	return (_Ptr);

  00000	48 8b c1	 mov	 rax, rcx

; 345  : 	}

  00003	c3		 ret	 0
??$_Refancy@PEAD$0A@@std@@YAPEADPEAD@Z ENDP		; std::_Refancy<char * __ptr64,0>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z
_TEXT	SEGMENT
this$ = 64
_New_size$dead$ = 72
_Fn$dead$ = 80
<_Args_0>$dead$ = 88
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>, COMDAT

; 3609 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	40 55		 push	 rbp
  00002	57		 push	 rdi
  00003	41 56		 push	 r14
  00005	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3610 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3611 : 		if (_New_size > max_size())
; 3612 : 			{
; 3613 : 			_Xlen();	// result too long
; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  00009	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]
  0000d	48 8b f9	 mov	 rdi, rcx

; 3598 : 		if (_Old > _Max - _Old / 2)

  00010	49 8b ce	 mov	 rcx, r14
  00013	48 bd ff ff ff
	ff ff ff ff 7f	 mov	 rbp, 9223372036854775807 ; 7fffffffffffffffH
  0001d	48 d1 e9	 shr	 rcx, 1
  00020	48 8b c5	 mov	 rax, rbp
  00023	48 2b c1	 sub	 rax, rcx
  00026	4c 3b f0	 cmp	 r14, rax
  00029	77 10		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002b	4a 8d 04 31	 lea	 rax, QWORD PTR [rcx+r14]
  0002f	bd 0f 00 00 00	 mov	 ebp, 15
  00034	48 3b c5	 cmp	 rax, rbp
  00037	48 0f 47 e8	 cmova	 rbp, rax
$LN33@Reallocate:

; 3618 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3619 : 		auto& _Al = this->_Getal();
; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0003b	48 8b cd	 mov	 rcx, rbp
  0003e	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00043	48 83 c1 01	 add	 rcx, 1
  00047	48 89 74 24 50	 mov	 QWORD PTR [rsp+80], rsi
  0004c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00053	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00057	33 f6		 xor	 esi, esi
  00059	48 85 c9	 test	 rcx, rcx
  0005c	75 04		 jne	 SHORT $LN76@Reallocate
  0005e	8b de		 mov	 ebx, esi
  00060	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00062	40 84 f6	 test	 sil, sil
  00065	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0006d	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0006e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00075	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00077	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  0007b	48 3b c1	 cmp	 rax, rcx
  0007e	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  00080	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00086	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  00087	48 8b c8	 mov	 rcx, rax
  0008a	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  0008f	48 8d 58 27	 lea	 rbx, QWORD PTR [rax+39]
  00093	48 83 e3 e0	 and	 rbx, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  00097	48 89 43 f8	 mov	 QWORD PTR [rbx-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  0009b	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  0009d	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000a2	48 8b d8	 mov	 rbx, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000a5	33 c0		 xor	 eax, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000a7	48 c7 47 10 08
	00 00 00	 mov	 QWORD PTR [rdi+16], 8

; 3623 : 		_My_data._Myres = _New_capacity;

  000af	48 89 6f 18	 mov	 QWORD PTR [rdi+24], rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000b3	48 89 03	 mov	 QWORD PTR [rbx], rax

; 517  : 		_Left = _Right;

  000b6	88 43 08	 mov	 BYTE PTR [rbx+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000b9	49 83 fe 10	 cmp	 r14, 16
  000bd	72 37		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000bf	48 8b 0f	 mov	 rcx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000c2	49 ff c6	 inc	 r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000c5	40 84 f6	 test	 sil, sil
  000c8	75 45		 jne	 SHORT $_Invalid_parameter$127

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000ca	49 81 fe 00 10
	00 00		 cmp	 r14, 4096		; 00001000H
  000d1	72 1e		 jb	 SHORT $LN103@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000d3	f6 c1 1f	 test	 cl, 31
  000d6	75 37		 jne	 SHORT $_Invalid_parameter$127

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000d8	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  000dc	48 3b c1	 cmp	 rax, rcx
  000df	73 2e		 jae	 SHORT $_Invalid_parameter$127
  000e1	48 2b c8	 sub	 rcx, rax
  000e4	48 83 e9 08	 sub	 rcx, 8
  000e8	48 83 f9 1f	 cmp	 rcx, 31
  000ec	77 21		 ja	 SHORT $_Invalid_parameter$127

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  000ee	48 8b c8	 mov	 rcx, rax
$LN103@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  000f1	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3636 : 		}

  000f6	48 8b 74 24 50	 mov	 rsi, QWORD PTR [rsp+80]
  000fb	48 8b c7	 mov	 rax, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  000fe	48 89 1f	 mov	 QWORD PTR [rdi], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3636 : 		}

  00101	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00106	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0010a	41 5e		 pop	 r14
  0010c	5f		 pop	 rdi
  0010d	5d		 pop	 rbp
  0010e	c3		 ret	 0
$_Invalid_parameter$127:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0010f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00115	cc		 int	 3
$LN126@Reallocate:
??$_Reallocate_for@V<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>@@D@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_138c3d7c38c85abb84c7fc7bfe5747b7>,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z
_TEXT	SEGMENT
this$ = 96
_New_size$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>, COMDAT

; 3609 : 		{	// reallocate to store exactly _New_size elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	56		 push	 rsi
  00003	41 54		 push	 r12
  00005	41 57		 push	 r15
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3610 : 			// _Fn(_New_ptr, _New_size, _Args...)
; 3611 : 		if (_New_size > max_size())

  0000b	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00015	4d 8b e1	 mov	 r12, r9
  00018	4c 8b fa	 mov	 r15, rdx
  0001b	48 8b f1	 mov	 rsi, rcx
  0001e	48 3b d3	 cmp	 rdx, rbx
  00021	0f 87 1d 01 00
	00		 ja	 $LN129@Reallocate

; 3614 : 			}
; 3615 : 
; 3616 : 		auto& _My_data = this->_Get_data();
; 3617 : 		const size_type _Old_capacity = _My_data._Myres;

  00027	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0002c	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00030	48 8b ca	 mov	 rcx, rdx
  00033	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  00037	48 3b cb	 cmp	 rcx, rbx
  0003a	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  0003c	49 8b d6	 mov	 rdx, r14
  0003f	48 8b c3	 mov	 rax, rbx
  00042	48 d1 ea	 shr	 rdx, 1
  00045	48 2b c2	 sub	 rax, rdx
  00048	4c 3b f0	 cmp	 r14, rax
  0004b	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0004d	4a 8d 04 32	 lea	 rax, QWORD PTR [rdx+r14]
  00051	48 8b d9	 mov	 rbx, rcx
  00054	48 3b c8	 cmp	 rcx, rax
  00057	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3618 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3619 : 		auto& _Al = this->_Getal();
; 3620 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0005b	48 89 6c 24 30	 mov	 QWORD PTR [rsp+48], rbp
  00060	48 8b cb	 mov	 rcx, rbx
  00063	48 83 c1 01	 add	 rcx, 1
  00067	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  0006c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00073	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00077	33 ed		 xor	 ebp, ebp
  00079	48 85 c9	 test	 rcx, rcx
  0007c	75 04		 jne	 SHORT $LN76@Reallocate
  0007e	8b fd		 mov	 edi, ebp
  00080	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00082	40 84 ed	 test	 bpl, bpl
  00085	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00087	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0008d	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0008e	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  00095	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  00097	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  0009b	48 3b c1	 cmp	 rax, rcx
  0009e	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000a0	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000a6	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000a7	48 8b c8	 mov	 rcx, rax
  000aa	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000af	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000b3	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000b7	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000bb	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000bd	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000c2	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000c5	4d 8b c7	 mov	 r8, r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3622 : 		_My_data._Mysize = _New_size;

  000c8	4c 89 7e 10	 mov	 QWORD PTR [rsi+16], r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000cc	49 8b d4	 mov	 rdx, r12
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3623 : 		_My_data._Myres = _New_capacity;

  000cf	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000d3	48 8b cf	 mov	 rcx, rdi
  000d6	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  000db	41 c6 04 3f 00	 mov	 BYTE PTR [r15+rdi], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3625 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e0	49 83 fe 10	 cmp	 r14, 16
  000e4	72 37		 jb	 SHORT $LN3@Reallocate
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 941  : 		_Deallocate(_Ptr, _Count, sizeof(_Ty));

  000e6	48 8b 0e	 mov	 rcx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3627 : 			_Al.deallocate(_My_data._Bx._Ptr, _Old_capacity + 1);

  000e9	49 ff c6	 inc	 r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000ec	40 84 ed	 test	 bpl, bpl
  000ef	75 4c		 jne	 SHORT $_Invalid_parameter$131

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000f1	49 81 fe 00 10
	00 00		 cmp	 r14, 4096		; 00001000H
  000f8	72 1e		 jb	 SHORT $LN103@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  000fa	f6 c1 1f	 test	 cl, 31
  000fd	75 3e		 jne	 SHORT $_Invalid_parameter$131

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  000ff	48 8b 41 f8	 mov	 rax, QWORD PTR [rcx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00103	48 3b c1	 cmp	 rax, rcx
  00106	73 35		 jae	 SHORT $_Invalid_parameter$131
  00108	48 2b c8	 sub	 rcx, rax
  0010b	48 83 e9 08	 sub	 rcx, 8
  0010f	48 83 f9 1f	 cmp	 rcx, 31
  00113	77 28		 ja	 SHORT $_Invalid_parameter$131

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00115	48 8b c8	 mov	 rcx, rax
$LN103@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00118	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
$LN3@Reallocate:
  0011d	48 8b 6c 24 30	 mov	 rbp, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3635 : 		return (*this);

  00122	48 8b c6	 mov	 rax, rsi
  00125	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0012a	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0012d	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3636 : 		}

  00132	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00136	41 5f		 pop	 r15
  00138	41 5c		 pop	 r12
  0013a	5e		 pop	 rsi
  0013b	5b		 pop	 rbx
  0013c	c3		 ret	 0
$_Invalid_parameter$131:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00143	cc		 int	 3
$LN129@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3613 : 			_Xlen();	// result too long

  00144	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00149	cc		 int	 3
$LN128@Reallocate:
??$_Reallocate_for@V<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_66f57f934f28d61049862f64df852ff0>@@PEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_for<<lambda_66f57f934f28d61049862f64df852ff0>,char const * __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>, COMDAT

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	55		 push	 rbp
  00003	56		 push	 rsi
  00004	41 54		 push	 r12
  00006	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;

  0000a	48 8b 69 10	 mov	 rbp, QWORD PTR [rcx+16]

; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000e	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00018	48 8b c3	 mov	 rax, rbx
  0001b	4d 8b e1	 mov	 r12, r9
  0001e	48 2b c5	 sub	 rax, rbp
  00021	48 8b f1	 mov	 rsi, rcx
  00024	48 3b c2	 cmp	 rax, rdx
  00027	0f 82 6c 01 00
	00		 jb	 $LN147@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002d	4c 89 6c 24 30	 mov	 QWORD PTR [rsp+48], r13
  00032	4c 8d 2c 2a	 lea	 r13, QWORD PTR [rdx+rbp]
  00036	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0003b	4c 8b 79 18	 mov	 r15, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0003f	49 8b cd	 mov	 rcx, r13
  00042	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  00046	48 3b cb	 cmp	 rcx, rbx
  00049	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  0004b	49 8b d7	 mov	 rdx, r15
  0004e	48 8b c3	 mov	 rax, rbx
  00051	48 d1 ea	 shr	 rdx, 1
  00054	48 2b c2	 sub	 rax, rdx
  00057	4c 3b f8	 cmp	 r15, rax
  0005a	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005c	4a 8d 04 3a	 lea	 rax, QWORD PTR [rdx+r15]
  00060	48 8b d9	 mov	 rbx, rcx
  00063	48 3b c8	 cmp	 rcx, rax
  00066	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006a	48 8b cb	 mov	 rcx, rbx
  0006d	48 89 7c 24 70	 mov	 QWORD PTR [rsp+112], rdi
  00072	48 83 c1 01	 add	 rcx, 1
  00076	4c 89 74 24 28	 mov	 QWORD PTR [rsp+40], r14
  0007b	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00082	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00086	45 33 f6	 xor	 r14d, r14d
  00089	48 85 c9	 test	 rcx, rcx
  0008c	75 05		 jne	 SHORT $LN76@Reallocate
  0008e	41 8b fe	 mov	 edi, r14d
  00091	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00093	45 84 f6	 test	 r14b, r14b
  00096	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0009e	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0009f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a6	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000a8	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000ac	48 3b c1	 cmp	 rax, rcx
  000af	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000b7	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000c0	48 8d 78 27	 lea	 rdi, QWORD PTR [rax+39]
  000c4	48 83 e7 e0	 and	 rdi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c8	48 89 47 f8	 mov	 QWORD PTR [rdi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000cc	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000ce	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d3	48 8b f8	 mov	 rdi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000d6	4c 89 6e 10	 mov	 QWORD PTR [rsi+16], r13
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000da	4c 8b c5	 mov	 r8, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3657 : 		_My_data._Myres = _New_capacity;

  000dd	48 89 5e 18	 mov	 QWORD PTR [rsi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e1	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e4	49 83 ff 10	 cmp	 r15, 16
  000e8	72 67		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ea	48 8b 1e	 mov	 rbx, QWORD PTR [rsi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ed	48 8b d3	 mov	 rdx, rbx
  000f0	e8 00 00 00 00	 call	 memcpy

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  000f5	0f be 94 24 80
	00 00 00	 movsx	 edx, BYTE PTR <_Args_1>$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  000fd	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00101	4d 8b c4	 mov	 r8, r12
  00104	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00109	49 ff c7	 inc	 r15

; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0010c	49 8d 04 3c	 lea	 rax, QWORD PTR [r12+rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00110	c6 04 28 00	 mov	 BYTE PTR [rax+rbp], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00114	45 84 f6	 test	 r14b, r14b
  00117	75 31		 jne	 SHORT $_Invalid_parameter$149

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00119	49 81 ff 00 10
	00 00		 cmp	 r15, 4096		; 00001000H
  00120	72 1e		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00122	f6 c3 1f	 test	 bl, 31
  00125	75 23		 jne	 SHORT $_Invalid_parameter$149

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00127	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0012b	48 3b c3	 cmp	 rax, rbx
  0012e	73 1a		 jae	 SHORT $_Invalid_parameter$149
  00130	48 2b d8	 sub	 rbx, rax
  00133	48 83 eb 08	 sub	 rbx, 8
  00137	48 83 fb 1f	 cmp	 rbx, 31
  0013b	77 0d		 ja	 SHORT $_Invalid_parameter$149

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0013d	48 8b d8	 mov	 rbx, rax
$LN108@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00140	48 8b cb	 mov	 rcx, rbx
  00143	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3666 : 		else

  00148	eb 2b		 jmp	 SHORT $LN146@Reallocate
$_Invalid_parameter$149:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0014a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00150	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00151	48 8b d6	 mov	 rdx, rsi
  00154	e8 00 00 00 00	 call	 memcpy

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00159	0f be 94 24 80
	00 00 00	 movsx	 edx, BYTE PTR <_Args_1>$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2391 : 			_Traits::assign(_New_ptr + _Old_size, _Count, _Ch);

  00161	48 8d 0c 2f	 lea	 rcx, QWORD PTR [rdi+rbp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  00165	4d 8b c4	 mov	 r8, r12
  00168	e8 00 00 00 00	 call	 memset
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2392 : 			_Traits::assign(_New_ptr[_Old_size + _Count], _Elem());

  0016d	49 8d 0c 3c	 lea	 rcx, QWORD PTR [r12+rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00171	c6 04 29 00	 mov	 BYTE PTR [rcx+rbp], 0
$LN146@Reallocate:
  00175	4c 8b 74 24 28	 mov	 r14, QWORD PTR [rsp+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0017a	48 8b c6	 mov	 rax, rsi
  0017d	4c 8b 6c 24 30	 mov	 r13, QWORD PTR [rsp+48]
  00182	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00187	48 89 3e	 mov	 QWORD PTR [rsi], rdi
  0018a	48 8b 7c 24 70	 mov	 rdi, QWORD PTR [rsp+112]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3673 : 		}

  0018f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00193	41 5c		 pop	 r12
  00195	5e		 pop	 rsi
  00196	5d		 pop	 rbp
  00197	5b		 pop	 rbx
  00198	c3		 ret	 0
$LN147@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  00199	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  0019e	cc		 int	 3
$LN145@Reallocate:
??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$ = 120
<_Args_1>$ = 128
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>, COMDAT

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 54		 push	 r12
  00005	41 57		 push	 r15
  00007	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;

  0000b	48 8b 79 10	 mov	 rdi, QWORD PTR [rcx+16]

; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000f	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00019	48 8b c3	 mov	 rax, rbx
  0001c	4d 8b e1	 mov	 r12, r9
  0001f	48 2b c7	 sub	 rax, rdi
  00022	4c 8b f9	 mov	 r15, rcx
  00025	48 3b c2	 cmp	 rax, rdx
  00028	0f 82 6f 01 00
	00		 jb	 $LN147@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  0002e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00033	48 8d 34 3a	 lea	 rsi, QWORD PTR [rdx+rdi]
  00037	4c 89 6c 24 28	 mov	 QWORD PTR [rsp+40], r13

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  0003c	4c 8b 69 18	 mov	 r13, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00040	48 8b ce	 mov	 rcx, rsi
  00043	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  00047	48 3b cb	 cmp	 rcx, rbx
  0004a	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  0004c	49 8b d5	 mov	 rdx, r13
  0004f	48 8b c3	 mov	 rax, rbx
  00052	48 d1 ea	 shr	 rdx, 1
  00055	48 2b c2	 sub	 rax, rdx
  00058	4c 3b e8	 cmp	 r13, rax
  0005b	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0005d	4a 8d 04 2a	 lea	 rax, QWORD PTR [rdx+r13]
  00061	48 8b d9	 mov	 rbx, rcx
  00064	48 3b c8	 cmp	 rcx, rax
  00067	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  0006b	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00070	48 8b cb	 mov	 rcx, rbx
  00073	48 83 c1 01	 add	 rcx, 1
  00077	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0007c	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00083	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00087	33 ed		 xor	 ebp, ebp
  00089	48 85 c9	 test	 rcx, rcx
  0008c	75 05		 jne	 SHORT $LN76@Reallocate
  0008e	44 8b f5	 mov	 r14d, ebp
  00091	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00093	40 84 ed	 test	 bpl, bpl
  00096	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00098	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  0009e	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  0009f	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a6	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000a8	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000ac	48 3b c1	 cmp	 rax, rcx
  000af	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000b7	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b8	48 8b c8	 mov	 rcx, rax
  000bb	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000c0	4c 8d 70 27	 lea	 r14, QWORD PTR [rax+39]
  000c4	49 83 e6 e0	 and	 r14, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c8	49 89 46 f8	 mov	 QWORD PTR [r14-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000cc	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000ce	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d3	4c 8b f0	 mov	 r14, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000d6	49 89 77 10	 mov	 QWORD PTR [r15+16], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000da	4c 8b c7	 mov	 r8, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3657 : 		_My_data._Myres = _New_capacity;

  000dd	49 89 5f 18	 mov	 QWORD PTR [r15+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e1	49 8b ce	 mov	 rcx, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000e4	49 83 fd 10	 cmp	 r13, 16
  000e8	72 69		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000ea	49 8b 37	 mov	 rsi, QWORD PTR [r15]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000ed	48 8b d6	 mov	 rdx, rsi
  000f0	e8 00 00 00 00	 call	 memcpy
  000f5	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR <_Args_1>$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  000fd	49 03 fe	 add	 rdi, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00100	4c 8b c3	 mov	 r8, rbx
  00103	48 8b cf	 mov	 rcx, rdi
  00106	49 8b d4	 mov	 rdx, r12
  00109	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  0010e	49 ff c5	 inc	 r13
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00111	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00115	40 84 ed	 test	 bpl, bpl
  00118	75 32		 jne	 SHORT $_Invalid_parameter$149

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0011a	49 81 fd 00 10
	00 00		 cmp	 r13, 4096		; 00001000H
  00121	72 1f		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00123	40 f6 c6 1f	 test	 sil, 31
  00127	75 23		 jne	 SHORT $_Invalid_parameter$149

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00129	48 8b 46 f8	 mov	 rax, QWORD PTR [rsi-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0012d	48 3b c6	 cmp	 rax, rsi
  00130	73 1a		 jae	 SHORT $_Invalid_parameter$149
  00132	48 2b f0	 sub	 rsi, rax
  00135	48 83 ee 08	 sub	 rsi, 8
  00139	48 83 fe 1f	 cmp	 rsi, 31
  0013d	77 0d		 ja	 SHORT $_Invalid_parameter$149

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0013f	48 8b f0	 mov	 rsi, rax
$LN108@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00142	48 8b ce	 mov	 rcx, rsi
  00145	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3666 : 		else

  0014a	eb 2c		 jmp	 SHORT $LN146@Reallocate
$_Invalid_parameter$149:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00152	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00153	49 8b d7	 mov	 rdx, r15
  00156	e8 00 00 00 00	 call	 memcpy
  0015b	48 8b 9c 24 80
	00 00 00	 mov	 rbx, QWORD PTR <_Args_1>$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2364 : 			_Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);

  00163	49 03 fe	 add	 rdi, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00166	4c 8b c3	 mov	 r8, rbx
  00169	48 8b cf	 mov	 rcx, rdi
  0016c	49 8b d4	 mov	 rdx, r12
  0016f	e8 00 00 00 00	 call	 memcpy

; 517  : 		_Left = _Right;

  00174	c6 04 1f 00	 mov	 BYTE PTR [rdi+rbx], 0
$LN146@Reallocate:
  00178	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0017d	49 8b c7	 mov	 rax, r15
  00180	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
  00185	4c 8b 6c 24 28	 mov	 r13, QWORD PTR [rsp+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0018a	4d 89 37	 mov	 QWORD PTR [r15], r14
  0018d	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3673 : 		}

  00192	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00196	41 5f		 pop	 r15
  00198	41 5c		 pop	 r12
  0019a	5f		 pop	 rdi
  0019b	5b		 pop	 rbx
  0019c	c3		 ret	 0
$LN147@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  0019d	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  001a2	cc		 int	 3
$LN145@Reallocate:
??$_Reallocate_grow_by@V<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_65e615be2a453ca0576c979606f46740>@@PEBD_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_65e615be2a453ca0576c979606f46740>,char const * __ptr64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z
_TEXT	SEGMENT
__formal$dead$ = 8
_Ptr$ = 16
<_Args_0>$ = 24
??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z PROC ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>, COMDAT

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  00000	49 8b 00	 mov	 rax, QWORD PTR [r8]
  00003	48 89 02	 mov	 QWORD PTR [rdx], rax

; 856  : 			_Objty(_STD forward<_Types>(_Args)...);
; 857  : 		}

  00006	c3		 ret	 0
??$construct@PEADAEBQEAD@?$_Default_allocator_traits@V?$allocator@D@std@@@std@@SAXAEAV?$allocator@D@1@QEAPEADAEBQEAD@Z ENDP ; std::_Default_allocator_traits<std::allocator<char> >::construct<char * __ptr64,char * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
_Al$dead$ = 16
??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z PROC ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>, COMDAT

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1711 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@X@?$_String_alloc@U?$_String_base_types@DV?$allocator@D@std@@@std@@@std@@QEAA@AEBV?$allocator@D@1@@Z ENDP ; std::_String_alloc<std::_String_base_types<char,std::allocator<char> > >::_String_alloc<std::_String_base_types<char,std::allocator<char> > ><std::allocator<char> const & __ptr64,void>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\vcruntime_exception.h
;	COMDAT ??0bad_cast@std@@QEAA@AEBV01@@Z
_TEXT	SEGMENT
this$ = 48
__that$ = 56
??0bad_cast@std@@QEAA@AEBV01@@Z PROC			; std::bad_cast::bad_cast, COMDAT
$LN6:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	48 8b c2	 mov	 rax, rdx

; 65   :         : _Data()

  0000c	48 8d 53 08	 lea	 rdx, QWORD PTR [rbx+8]

; 66   :     {

  00010	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_7exception@std@@6B@
  00017	48 89 0b	 mov	 QWORD PTR [rbx], rcx
  0001a	33 c9		 xor	 ecx, ecx
  0001c	48 89 0a	 mov	 QWORD PTR [rdx], rcx
  0001f	48 89 4a 08	 mov	 QWORD PTR [rdx+8], rcx

; 67   :         __std_exception_copy(&_Other._Data, &_Data);

  00023	48 8d 48 08	 lea	 rcx, QWORD PTR [rax+8]
  00027	ff 15 00 00 00
	00		 call	 QWORD PTR __imp___std_exception_copy
  0002d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_7bad_cast@std@@6B@
  00034	48 89 03	 mov	 QWORD PTR [rbx], rax
  00037	48 8b c3	 mov	 rax, rbx
  0003a	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003e	5b		 pop	 rbx
  0003f	c3		 ret	 0
??0bad_cast@std@@QEAA@AEBV01@@Z ENDP			; std::bad_cast::bad_cast
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >, COMDAT

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax

; 1579 : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??0?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_String_val<std::_Simple_types<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ
_TEXT	SEGMENT
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen, COMDAT

; 3725 : 		{	// report a length_error

$LN4:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 3726 : 		_Xlength_error("string too long");

  00004	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:??_C@_0BA@JFNIOLAK@string?5too?5long?$AA@
  0000b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xlength_error@std@@YAXPEBD@Z
  00011	cc		 int	 3
$LN3@Xlen:
?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z
_TEXT	SEGMENT
this$ = 8
_Requested$ = 16
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth, COMDAT

; 3070 : 		return (_Min_value(

  00000	49 b9 ff ff ff
	ff ff ff ff 7f	 mov	 r9, 9223372036854775807	; 7fffffffffffffffH

; 3589 : 		const size_type _Max = max_size();
; 3590 : 		auto& _My_data = this->_Get_data();
; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0000a	48 83 ca 0f	 or	 rdx, 15

; 3592 : 		if (_Masked > _Max)
; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);

  0000e	49 8b c1	 mov	 rax, r9
  00011	49 3b d1	 cmp	 rdx, r9
  00014	77 24		 ja	 SHORT $LN1@Calculate_

; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;

  00016	4c 8b 41 18	 mov	 r8, QWORD PTR [rcx+24]

; 3598 : 		if (_Old > _Max - _Old / 2)

  0001a	49 8b c8	 mov	 rcx, r8
  0001d	48 d1 e9	 shr	 rcx, 1
  00020	48 2b c1	 sub	 rax, rcx
  00023	4c 3b c0	 cmp	 r8, rax
  00026	76 04		 jbe	 SHORT $LN3@Calculate_

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);

  00028	49 8b c1	 mov	 rax, r9

; 3604 : 		}

  0002b	c3		 ret	 0
$LN3@Calculate_:

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  0002c	4a 8d 04 01	 lea	 rax, QWORD PTR [rcx+r8]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\utility

; 32   : 	return (_Left < _Right ? _Right : _Left);

  00030	48 3b d0	 cmp	 rdx, rax
  00033	48 0f 42 d0	 cmovb	 rdx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00037	48 8b c2	 mov	 rax, rdx
$LN1@Calculate_:

; 3604 : 		}

  0003a	c3		 ret	 0
?_Calculate_growth@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_K_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Calculate_growth
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z
_TEXT	SEGMENT
this$ = 48
_Ptr$ = 56
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal, COMDAT

; 3494 : 		{	// compare [0, size()) with _Ptr for equality

$LN29:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 480  : 		return (_CSTD strlen(_First));

  00004	48 83 c8 ff	 or	 rax, -1
  00008	0f 1f 84 00 00
	00 00 00	 npad	 8
$LL27@Equal:
  00010	48 ff c0	 inc	 rax
  00013	80 3c 02 00	 cmp	 BYTE PTR [rdx+rax], 0
  00017	75 f7		 jne	 SHORT $LL27@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00019	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1606 : 		const value_type * _Result = _Bx._Buf;

  0001e	4c 8b c9	 mov	 r9, rcx

; 1607 : 		if (_Large_string_engaged())

  00021	72 03		 jb	 SHORT $LN13@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00023	4c 8b 09	 mov	 r9, QWORD PTR [rcx]
$LN13@Equal:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00026	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  0002a	4c 3b c0	 cmp	 r8, rax
  0002d	75 13		 jne	 SHORT $LN21@Equal
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0002f	49 8b c9	 mov	 rcx, r9
  00032	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00037	85 c0		 test	 eax, eax
  00039	75 07		 jne	 SHORT $LN21@Equal

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  0003b	b0 01		 mov	 al, 1

; 3497 : 		}

  0003d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00041	c3		 ret	 0
$LN21@Equal:

; 3496 : 		return (_Traits_equal<_Traits>(_My_data._Myptr(), _My_data._Mysize, _Ptr, _Traits::length(_Ptr)));

  00042	32 c0		 xor	 al, al

; 3497 : 		}

  00044	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00048	c3		 ret	 0
?_Equal@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_NQEBD@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Equal
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z
_TEXT	SEGMENT
this$ = 48
_Newcap$ = 56
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve, COMDAT

; 3096 : 		{	// determine new minimum length of allocated storage

$LN64:
  00000	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  00005	57		 push	 rdi
  00006	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3097 : 		auto& _My_data = this->_Get_data();
; 3098 : 		if (_My_data._Mysize > _Newcap)

  0000a	48 8b 71 10	 mov	 rsi, QWORD PTR [rcx+16]
  0000e	48 8b f9	 mov	 rdi, rcx
  00011	48 3b f2	 cmp	 rsi, rdx
  00014	0f 87 84 00 00
	00		 ja	 $LN5@reserve

; 3099 : 			{	// requested capacity is not large enough for current size, ignore
; 3100 : 			return;	// nothing to do
; 3101 : 			}
; 3102 : 
; 3103 : 		if (_My_data._Myres == _Newcap)

  0001a	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]
  0001e	48 3b c2	 cmp	 rax, rdx
  00021	74 7b		 je	 SHORT $LN5@reserve

; 3104 : 			{	// we're already at the requested capacity
; 3105 : 			return;	// nothing to do
; 3106 : 			}
; 3107 : 
; 3108 : 		if (_My_data._Myres < _Newcap)

  00023	73 17		 jae	 SHORT $LN4@reserve

; 3109 : 			{	// reallocate to grow
; 3110 : 			const size_type _Old_size = _My_data._Mysize;
; 3111 : 			_Reallocate_grow_by(_Newcap - _Old_size,

  00025	48 2b d6	 sub	 rdx, rsi
  00028	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {
; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
; 3114 : 				});
; 3115 : 
; 3116 : 			_My_data._Mysize = _Old_size;

  0002d	48 89 77 10	 mov	 QWORD PTR [rdi+16], rsi

; 3127 : 		}

  00031	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  00036	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0003a	5f		 pop	 rdi
  0003b	c3		 ret	 0
$LN4@reserve:

; 3117 : 			return;
; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  0003c	48 83 fa 10	 cmp	 rdx, 16
  00040	73 5c		 jae	 SHORT $LN5@reserve

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00042	48 83 f8 10	 cmp	 rax, 16

; 3117 : 			return;
; 3118 : 			}
; 3119 : 
; 3120 : 		if (this->_BUF_SIZE > _Newcap && _My_data._Large_string_engaged())

  00046	72 56		 jb	 SHORT $LN5@reserve

; 3681 : 		const pointer _Ptr = _My_data._Bx._Ptr;

  00048	48 89 5c 24 30	 mov	 QWORD PTR [rsp+48], rbx

; 3682 : 		auto& _Al = this->_Getal();
; 3683 : 		_Alty_traits::destroy(_Al, _STD addressof(_My_data._Bx._Ptr));
; 3684 : 		_Traits::copy(_My_data._Bx._Buf, _Unfancy(_Ptr), _My_data._Mysize + 1);

  0004d	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
  00051	48 8b 19	 mov	 rbx, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00054	48 8b d3	 mov	 rdx, rbx
  00057	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3685 : 		_Al.deallocate(_Ptr, _My_data._Myres + 1);

  0005c	48 8b 47 18	 mov	 rax, QWORD PTR [rdi+24]
  00060	48 ff c0	 inc	 rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  00063	48 3d 00 10 00
	00		 cmp	 rax, 4096		; 00001000H
  00069	72 1e		 jb	 SHORT $LN47@reserve

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  0006b	f6 c3 1f	 test	 bl, 31
  0006e	75 39		 jne	 SHORT $_Invalid_parameter$65

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00070	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  00074	48 3b c3	 cmp	 rax, rbx
  00077	73 30		 jae	 SHORT $_Invalid_parameter$65
  00079	48 2b d8	 sub	 rbx, rax
  0007c	48 83 eb 08	 sub	 rbx, 8
  00080	48 83 fb 1f	 cmp	 rbx, 31
  00084	77 23		 ja	 SHORT $_Invalid_parameter$65

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  00086	48 8b d8	 mov	 rbx, rax
$LN47@reserve:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00089	48 8b cb	 mov	 rcx, rbx
  0008c	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
  00091	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3686 : 		_My_data._Myres = this->_BUF_SIZE - 1;

  00096	48 c7 47 18 0f
	00 00 00	 mov	 QWORD PTR [rdi+24], 15
$LN5@reserve:

; 3127 : 		}

  0009e	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  000a3	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a7	5f		 pop	 rdi
  000a8	c3		 ret	 0
$_Invalid_parameter$65:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  000a9	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  000af	cc		 int	 3
$LN63@reserve:
?reserve@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAX_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::reserve
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z
_TEXT	SEGMENT
this$dead$ = 8
_New_ptr$ = 16
_Old_ptr$ = 24
_Old_size$ = 32
??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z PROC ; <lambda_9013ee9e23efe4882b67eff5b0ecf103>::operator(), COMDAT

; 3112 : 				[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size) {

  00000	49 8b c0	 mov	 rax, r8
  00003	48 8b ca	 mov	 rcx, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00006	48 8b d0	 mov	 rdx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  00009	4d 8d 41 01	 lea	 r8, QWORD PTR [r9+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0000d	e9 00 00 00 00	 jmp	 memcpy
??R<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@QEBA@QEADQEBD_K@Z ENDP ; <lambda_9013ee9e23efe4882b67eff5b0ecf103>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ
_TEXT	SEGMENT
this$ = 8
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity, COMDAT

; 3092 : 		return (this->_Get_data()._Myres);

  00000	48 8b 41 18	 mov	 rax, QWORD PTR [rcx+24]

; 3093 : 		}

  00004	c3		 ret	 0
?capacity@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBA_KXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::capacity
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ
_TEXT	SEGMENT
this$ = 8
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 1607 : 		if (_Large_string_engaged())

  00005	72 04		 jb	 SHORT $LN16@data

; 3045 : 		return (this->_Get_data()._Myptr());

  00007	48 8b 01	 mov	 rax, QWORD PTR [rcx]

; 3046 : 		}

  0000a	c3		 ret	 0
$LN16@data:

; 3045 : 		return (this->_Get_data()._Myptr());

  0000b	48 8b c1	 mov	 rax, rcx

; 3046 : 		}

  0000e	c3		 ret	 0
?data@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEBAPEBDXZ ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::data
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Right$ = 80
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2481 : 		{	// insert _Right at _Off

$LN52:
  00000	48 89 5c 24 18	 mov	 QWORD PTR [rsp+24], rbx
  00005	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000a	41 56		 push	 r14
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00010	49 83 78 18 10	 cmp	 QWORD PTR [r8+24], 16

; 2481 : 		{	// insert _Right at _Off

  00015	4c 8b f1	 mov	 r14, rcx

; 1606 : 		const value_type * _Result = _Bx._Buf;

  00018	49 8b d8	 mov	 rbx, r8

; 1607 : 		if (_Large_string_engaged())

  0001b	72 03		 jb	 SHORT $LN10@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0001d	49 8b 18	 mov	 rbx, QWORD PTR [r8]
$LN10@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2483 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  00020	49 8b 78 10	 mov	 rdi, QWORD PTR [r8+16]

; 1622 : 		if (_Mysize < _Off)

  00024	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  00028	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  0002c	48 8b c1	 mov	 rax, rcx
  0002f	49 2b c0	 sub	 rax, r8
  00032	48 3b f8	 cmp	 rdi, rax
  00035	0f 87 97 00 00
	00		 ja	 $LN17@insert

; 2517 : 			{
; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  0003b	48 89 74 24 40	 mov	 QWORD PTR [rsp+64], rsi
  00040	49 8d 04 38	 lea	 rax, QWORD PTR [r8+rdi]
  00044	49 89 46 10	 mov	 QWORD PTR [r14+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00048	49 8b f6	 mov	 rsi, r14

; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  0004b	4c 89 7c 24 48	 mov	 QWORD PTR [rsp+72], r15

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00050	48 83 f9 10	 cmp	 rcx, 16

; 1596 : 		if (_Large_string_engaged())

  00054	72 03		 jb	 SHORT $LN35@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00056	49 8b 36	 mov	 rsi, QWORD PTR [r14]
$LN35@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2524 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  00059	48 8d 04 1f	 lea	 rax, QWORD PTR [rdi+rbx]
  0005d	48 3b c6	 cmp	 rax, rsi
  00060	76 1b		 jbe	 SHORT $LN20@insert
  00062	4a 8d 04 06	 lea	 rax, QWORD PTR [rsi+r8]
  00066	48 3b d8	 cmp	 rbx, rax
  00069	77 12		 ja	 SHORT $LN20@insert

; 2527 : 				}
; 2528 : 			else if (_Insert_at <= _Ptr)

  0006b	48 3b f3	 cmp	 rsi, rbx
  0006e	77 05		 ja	 SHORT $LN21@insert

; 2529 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2530 : 				_Ptr_shifted_after = 0;

  00070	45 33 ff	 xor	 r15d, r15d

; 2531 : 				}
; 2532 : 			else

  00073	eb 0b		 jmp	 SHORT $LN22@insert
$LN21@insert:

; 2533 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2534 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00075	4c 8b fe	 mov	 r15, rsi
  00078	4c 2b fb	 sub	 r15, rbx
  0007b	eb 03		 jmp	 SHORT $LN22@insert
$LN20@insert:

; 2525 : 				{	// inserted content is before the shifted region, or does not alias
; 2526 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  0007d	4c 8b ff	 mov	 r15, rdi
$LN22@insert:

; 2535 : 				}
; 2536 : 
; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00080	49 ff c0	 inc	 r8
  00083	48 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  00087	48 8b d6	 mov	 rdx, rsi
  0008a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00090	4d 8b c7	 mov	 r8, r15
  00093	48 8b d3	 mov	 rdx, rbx
  00096	48 8b ce	 mov	 rcx, rsi
  00099	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  0009e	4c 8b c7	 mov	 r8, rdi
  000a1	49 8d 14 3f	 lea	 rdx, QWORD PTR [r15+rdi]
  000a5	4d 2b c7	 sub	 r8, r15
  000a8	4a 8d 0c 3e	 lea	 rcx, QWORD PTR [rsi+r15]
  000ac	48 03 d3	 add	 rdx, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000af	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2483 : 		return (insert(_Off, _Right_data._Myptr(), _Right_data._Mysize));

  000b4	4c 8b 7c 24 48	 mov	 r15, QWORD PTR [rsp+72]
  000b9	49 8b c6	 mov	 rax, r14
  000bc	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]

; 2484 : 		}

  000c1	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000c6	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000cb	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000cf	41 5e		 pop	 r14
  000d1	c3		 ret	 0
$LN17@insert:

; 2544 : 		return (_Reallocate_grow_by(_Count,

  000d2	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  000d7	48 8b d7	 mov	 rdx, rdi
  000da	49 8b ce	 mov	 rcx, r14
  000dd	48 89 5c 24 20	 mov	 QWORD PTR [rsp+32], rbx
  000e2	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>

; 2484 : 		}

  000e7	48 8b 5c 24 50	 mov	 rbx, QWORD PTR [rsp+80]
  000ec	48 8b 7c 24 58	 mov	 rdi, QWORD PTR [rsp+88]
  000f1	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000f5	41 5e		 pop	 r14
  000f7	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KAEBV12@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
this$ = 8
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ PROC ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty, COMDAT

; 1649 : 			{	// user-provided, for fancy pointers
; 1650 : 			}

  00000	48 8b c1	 mov	 rax, rcx
  00003	c3		 ret	 0
??0_Bxty@?$_String_val@U?$_Simple_types@D@std@@@std@@QEAA@XZ ENDP ; std::_String_val<std::_Simple_types<char> >::_Bxty::_Bxty
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z
_TEXT	SEGMENT
this$ = 64
_Off$dead$ = 72
_Ptr$ = 80
_Count$ = 88
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert, COMDAT

; 2512 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

$LN36:
  00000	48 89 7c 24 18	 mov	 QWORD PTR [rsp+24], rdi
  00005	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  00010	4d 8b f0	 mov	 r14, r8
  00013	4c 8b f9	 mov	 r15, rcx

; 1622 : 		if (_Mysize < _Off)

  00016	4c 8b 41 10	 mov	 r8, QWORD PTR [rcx+16]

; 2512 : 		{	// insert [_Ptr, _Ptr + _Count) at _Off

  0001a	49 8b f9	 mov	 rdi, r9

; 2513 : 		auto& _My_data = this->_Get_data();
; 2514 : 		_My_data._Check_offset(_Off);
; 2515 : 		const size_type _Old_size = _My_data._Mysize;
; 2516 : 		if (_Count <= _My_data._Myres - _Old_size)

  0001d	48 8b 49 18	 mov	 rcx, QWORD PTR [rcx+24]
  00021	48 8b c1	 mov	 rax, rcx
  00024	49 2b c0	 sub	 rax, r8
  00027	4c 3b c8	 cmp	 r9, rax
  0002a	0f 87 96 00 00
	00		 ja	 $LN2@insert

; 2517 : 			{
; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  00030	48 89 5c 24 40	 mov	 QWORD PTR [rsp+64], rbx
  00035	4b 8d 04 08	 lea	 rax, QWORD PTR [r8+r9]
  00039	49 89 47 10	 mov	 QWORD PTR [r15+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  0003d	49 8b df	 mov	 rbx, r15

; 2517 : 			{
; 2518 : 			_My_data._Mysize = _Old_size + _Count;

  00040	48 89 74 24 48	 mov	 QWORD PTR [rsp+72], rsi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00045	48 83 f9 10	 cmp	 rcx, 16

; 1596 : 		if (_Large_string_engaged())

  00049	72 03		 jb	 SHORT $LN20@insert
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0004b	49 8b 1f	 mov	 rbx, QWORD PTR [r15]
$LN20@insert:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2524 : 			if (_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)

  0004e	4b 8d 04 0e	 lea	 rax, QWORD PTR [r14+r9]
  00052	48 3b c3	 cmp	 rax, rbx
  00055	76 1a		 jbe	 SHORT $LN5@insert
  00057	4a 8d 04 03	 lea	 rax, QWORD PTR [rbx+r8]
  0005b	4c 3b f0	 cmp	 r14, rax
  0005e	77 11		 ja	 SHORT $LN5@insert

; 2527 : 				}
; 2528 : 			else if (_Insert_at <= _Ptr)

  00060	49 3b de	 cmp	 rbx, r14
  00063	77 04		 ja	 SHORT $LN6@insert

; 2529 : 				{	// all of [_Ptr, _Ptr + _Count) shifts
; 2530 : 				_Ptr_shifted_after = 0;

  00065	33 f6		 xor	 esi, esi

; 2531 : 				}
; 2532 : 			else

  00067	eb 0b		 jmp	 SHORT $LN7@insert
$LN6@insert:

; 2533 : 				{	// [_Ptr, _Ptr + _Count) contains _Insert_at, so only the part after _Insert_at shifts
; 2534 : 				_Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);

  00069	48 8b f3	 mov	 rsi, rbx
  0006c	49 2b f6	 sub	 rsi, r14
  0006f	eb 03		 jmp	 SHORT $LN7@insert
$LN5@insert:

; 2525 : 				{	// inserted content is before the shifted region, or does not alias
; 2526 : 				_Ptr_shifted_after = _Count; // none of _Ptr's data shifts

  00071	48 8b f7	 mov	 rsi, rdi
$LN7@insert:

; 2535 : 				}
; 2536 : 
; 2537 : 			_Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1); // move suffix + null down

  00074	49 ff c0	 inc	 r8
  00077	4a 8d 0c 0b	 lea	 rcx, QWORD PTR [rbx+r9]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 506  : 		return ((_Elem *)_CSTD memmove(_First1, _First2, _Count));

  0007b	48 8b d3	 mov	 rdx, rbx
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_memmove

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00084	4c 8b c6	 mov	 r8, rsi
  00087	49 8b d6	 mov	 rdx, r14
  0008a	48 8b cb	 mov	 rcx, rbx
  0008d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2539 : 			_Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after,

  00092	4c 8b c7	 mov	 r8, rdi
  00095	4a 8d 14 36	 lea	 rdx, QWORD PTR [rsi+r14]
  00099	4c 2b c6	 sub	 r8, rsi
  0009c	48 8d 0c 33	 lea	 rcx, QWORD PTR [rbx+rsi]
  000a0	48 03 d7	 add	 rdx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000a3	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2541 : 			return (*this);

  000a8	48 8b 74 24 48	 mov	 rsi, QWORD PTR [rsp+72]
  000ad	49 8b c7	 mov	 rax, r15
  000b0	48 8b 5c 24 40	 mov	 rbx, QWORD PTR [rsp+64]

; 2545 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2547 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2548 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2550 : 			}, _Off, _Ptr, _Count));
; 2551 : 		}

  000b5	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000ba	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000bf	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000c3	41 5f		 pop	 r15
  000c5	c3		 ret	 0
$LN2@insert:

; 2542 : 			}
; 2543 : 
; 2544 : 		return (_Reallocate_grow_by(_Count,

  000c6	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  000cb	48 8b d7	 mov	 rdx, rdi
  000ce	49 8b cf	 mov	 rcx, r15
  000d1	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14
  000d6	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>

; 2545 : 			[](_Elem * const _New_ptr, const _Elem * const _Old_ptr, const size_type _Old_size,
; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {
; 2547 : 			_Traits::copy(_New_ptr, _Old_ptr, _Off);
; 2548 : 			_Traits::copy(_New_ptr + _Off, _Ptr, _Count);
; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
; 2550 : 			}, _Off, _Ptr, _Count));
; 2551 : 		}

  000db	48 8b 7c 24 50	 mov	 rdi, QWORD PTR [rsp+80]
  000e0	4c 8b 74 24 58	 mov	 r14, QWORD PTR [rsp+88]
  000e5	48 83 c4 30	 add	 rsp, 48			; 00000030H
  000e9	41 5f		 pop	 r15
  000eb	c3		 ret	 0
?insert@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_KQEBD0@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::insert
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z
_TEXT	SEGMENT
this$dead$ = 48
_New_ptr$ = 56
_Old_ptr$ = 64
_Old_size$ = 72
_Off$dead$ = 80
_Ptr$ = 88
_Count$ = 96
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z PROC ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator(), COMDAT

; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	57		 push	 rdi
  00010	48 83 ec 20	 sub	 rsp, 32			; 00000020H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00014	48 8b 5c 24 60	 mov	 rbx, QWORD PTR _Count$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00019	48 8b fa	 mov	 rdi, rdx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0001c	48 8b 54 24 58	 mov	 rdx, QWORD PTR _Ptr$[rsp]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  00021	49 8b e8	 mov	 rbp, r8
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00024	4c 8b c3	 mov	 r8, rbx
  00027	48 8b cf	 mov	 rcx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2546 : 				const size_type _Off, const _Elem * const _Ptr, const size_type _Count) {

  0002a	49 8b f1	 mov	 rsi, r9
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0002d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00032	4c 8d 46 01	 lea	 r8, QWORD PTR [rsi+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00036	48 8b d5	 mov	 rdx, rbp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00039	48 8d 0c 1f	 lea	 rcx, QWORD PTR [rdi+rbx]

; 2550 : 			}, _Off, _Ptr, _Count));

  0003d	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00042	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00047	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  0004c	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00050	5f		 pop	 rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00051	e9 00 00 00 00	 jmp	 memcpy
??R<lambda_f3a66ab6a0570788f31503db83886f49>@@QEBA@QEADQEBD_K212@Z ENDP ; <lambda_f3a66ab6a0570788f31503db83886f49>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z
_TEXT	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z PROC ; std::operator>><char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 23   : 	{	// extract a string

$LN178:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 70	 sub	 rsp, 112		; 00000070H
  00010	48 c7 40 b8 fe
	ff ff ff	 mov	 QWORD PTR [rax-72], -2
  00018	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001c	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00020	48 8b da	 mov	 rbx, rdx
  00023	48 8b f9	 mov	 rdi, rcx
  00026	48 89 4c 24 38	 mov	 QWORD PTR _Istr$GSCopy$[rsp], rcx

; 24   : 	typedef ctype<_Elem> _Ctype;
; 25   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 26   : 	typedef basic_string<_Elem, _Traits, _Alloc> _Mystr;
; 27   : 	typedef typename _Mystr::size_type _Mysizt;
; 28   : 
; 29   : 	ios_base::iostate _State = ios_base::goodbit;

  0002b	33 f6		 xor	 esi, esi
  0002d	89 74 24 34	 mov	 DWORD PTR _State$[rsp], esi

; 30   : 	bool _Changed = false;

  00031	45 32 ff	 xor	 r15b, r15b
  00034	44 88 7c 24 30	 mov	 BYTE PTR _Changed$[rsp], r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 92   : 			: _Myistr(_Istr)

  00039	4c 8b e1	 mov	 r12, rcx
  0003c	48 89 48 a8	 mov	 QWORD PTR [rax-88], rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00040	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00043	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00047	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0004c	48 85 c9	 test	 rcx, rcx
  0004f	74 07		 je	 SHORT $LN25@operator

; 95   : 				_Myistr.rdbuf()->_Lock();

  00051	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00054	ff 50 08	 call	 QWORD PTR [rax+8]
  00057	90		 npad	 1
$LN25@operator:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  00058	33 d2		 xor	 edx, edx
  0005a	48 8b cf	 mov	 rcx, rdi
  0005d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00063	88 44 24 48	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 33   : 	if (_Ok)

  00067	84 c0		 test	 al, al
  00069	0f 84 3f 01 00
	00		 je	 $LN19@operator

; 34   : 		{	// state okay, extract characters
; 35   : 		const _Ctype& _Ctype_fac = _USE(_Istr.getloc(), _Ctype);

  0006f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00072	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00076	48 03 cf	 add	 rcx, rdi
  00079	48 8d 54 24 58	 lea	 rdx, QWORD PTR $T4[rsp]
  0007e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?getloc@ios_base@std@@QEBA?AVlocale@2@XZ
  00084	90		 npad	 1
  00085	48 8b c8	 mov	 rcx, rax
  00088	e8 00 00 00 00	 call	 ??$use_facet@V?$ctype@D@std@@@std@@YAAEBV?$ctype@D@0@AEBVlocale@0@@Z ; std::use_facet<std::ctype<char> >
  0008d	4c 8b e8	 mov	 r13, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 404  : 		if (_Ptr != 0)

  00090	48 8b 4c 24 60	 mov	 rcx, QWORD PTR $T4[rsp+8]
  00095	48 85 c9	 test	 rcx, rcx
  00098	74 19		 je	 SHORT $LN36@operator

; 405  : 			delete _Ptr->_Decref();

  0009a	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  0009d	ff 50 10	 call	 QWORD PTR [rax+16]
  000a0	48 8b c8	 mov	 rcx, rax
  000a3	48 85 c0	 test	 rax, rax
  000a6	74 0b		 je	 SHORT $LN36@operator
  000a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000ab	ba 01 00 00 00	 mov	 edx, 1
  000b0	ff 10		 call	 QWORD PTR [rax]
  000b2	90		 npad	 1
$LN36@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  000b3	48 c7 43 10 00
	00 00 00	 mov	 QWORD PTR [rbx+16], 0

; 1595 : 		value_type * _Result = _Bx._Buf;

  000bb	48 8b c3	 mov	 rax, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  000be	48 83 7b 18 10	 cmp	 QWORD PTR [rbx+24], 16

; 1596 : 		if (_Large_string_engaged())

  000c3	72 03		 jb	 SHORT $LN60@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  000c5	48 8b 03	 mov	 rax, QWORD PTR [rbx]
$LN60@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  000c8	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000cb	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  000ce	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  000d2	4c 8b 74 39 28	 mov	 r14, QWORD PTR [rcx+rdi+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3070 : 		return (_Min_value(

  000d7	48 b8 ff ff ff
	ff ff ff ff 7f	 mov	 rax, 9223372036854775807 ; 7fffffffffffffffH
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 40   : 			&& (_Mysizt)_Istr.width() < _Str.max_size()

  000e1	4d 85 f6	 test	 r14, r14
  000e4	7e 05		 jle	 SHORT $LN13@operator
  000e6	4c 3b f0	 cmp	 r14, rax
  000e9	72 03		 jb	 SHORT $LN98@operator
$LN13@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3070 : 		return (_Min_value(

  000eb	4c 8b f0	 mov	 r14, rax
$LN98@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 42   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  000ee	48 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+rdi+72]
  000f3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  000f9	8b d0		 mov	 edx, eax
  000fb	0f 1f 44 00 00	 npad	 5
$LL4@operator:

; 43   : 
; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  00100	4d 85 f6	 test	 r14, r14
  00103	0f 84 8f 00 00
	00		 je	 $LN3@operator

; 45   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  00109	83 fa ff	 cmp	 edx, -1
  0010c	75 0b		 jne	 SHORT $LN7@operator

; 46   : 				{	// end of file, quit
; 47   : 				_State |= ios_base::eofbit;

  0010e	be 01 00 00 00	 mov	 esi, 1
  00113	89 74 24 34	 mov	 DWORD PTR _State$[rsp], esi

; 48   : 				break;

  00117	eb 7f		 jmp	 SHORT $LN3@operator
$LN7@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xlocale

; 2344 : 		return ((_Ctype._Table[(unsigned char)_Ch] & _Maskval) != 0);

  00119	0f b6 ca	 movzx	 ecx, dl
  0011c	49 8b 45 18	 mov	 rax, QWORD PTR [r13+24]
  00120	f6 04 48 48	 test	 BYTE PTR [rax+rcx*2], 72 ; 00000048H
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 50   : 			else if (_Ctype_fac.is(_Ctype::space,

  00124	75 72		 jne	 SHORT $LN3@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2377 : 		const size_type _Old_size = _My_data._Mysize;

  00126	48 8b 4b 10	 mov	 rcx, QWORD PTR [rbx+16]

; 2378 : 		if (_Count <= _My_data._Myres - _Old_size)

  0012a	4c 8b 43 18	 mov	 r8, QWORD PTR [rbx+24]
  0012e	49 8b c0	 mov	 rax, r8
  00131	48 2b c1	 sub	 rax, rcx
  00134	48 83 f8 01	 cmp	 rax, 1
  00138	72 26		 jb	 SHORT $LN137@operator

; 2379 : 			{
; 2380 : 			_My_data._Mysize = _Old_size + _Count;

  0013a	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  0013e	48 89 43 10	 mov	 QWORD PTR [rbx+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00142	4c 8b cb	 mov	 r9, rbx

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00145	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00149	72 03		 jb	 SHORT $LN146@operator
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0014b	4c 8b 0b	 mov	 r9, QWORD PTR [rbx]
$LN146@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 512  : 		return ((_Elem *)_CSTD memset(_First, _Ch, _Count));

  0014e	0f be c2	 movsx	 eax, dl
  00151	0f b6 c0	 movzx	 al, al
  00154	41 88 04 09	 mov	 BYTE PTR [r9+rcx], al

; 517  : 		_Left = _Right;

  00158	41 c6 44 09 01
	00		 mov	 BYTE PTR [r9+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2384 : 			return (*this);

  0015e	eb 14		 jmp	 SHORT $LN136@operator
$LN137@operator:

; 2385 : 			}
; 2386 : 
; 2387 : 		return (_Reallocate_grow_by(_Count,

  00160	88 54 24 20	 mov	 BYTE PTR [rsp+32], dl
  00164	ba 01 00 00 00	 mov	 edx, 1
  00169	44 8b ca	 mov	 r9d, edx
  0016c	48 8b cb	 mov	 rcx, rbx
  0016f	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_e1befb086ad3257e3f042a63030725f7>@@_KD@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_e1befb086ad3257e3f042a63030725f7>,unsigned __int64,char>
$LN136@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 56   : 				_Changed = true;

  00174	41 b7 01	 mov	 r15b, 1
  00177	44 88 7c 24 30	 mov	 BYTE PTR _Changed$[rsp], r15b

; 43   : 
; 44   : 		for (; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())

  0017c	49 ff ce	 dec	 r14
  0017f	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  00182	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00186	48 8b 4c 39 48	 mov	 rcx, QWORD PTR [rcx+rdi+72]
  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  00191	8b d0		 mov	 edx, eax
  00193	e9 68 ff ff ff	 jmp	 $LL4@operator
$LN3@operator:
  00198	eb 14		 jmp	 SHORT $LN19@operator
$LN20@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  0019a	8b 74 24 34	 mov	 esi, DWORD PTR _State$[rsp]
  0019e	44 0f b6 7c 24
	30		 movzx	 r15d, BYTE PTR _Changed$[rsp]
  001a4	4c 8b 64 24 40	 mov	 r12, QWORD PTR _Ok$[rsp]
  001a9	48 8b 7c 24 38	 mov	 rdi, QWORD PTR _Istr$GSCopy$[rsp]
$LN19@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)
; 59   : 		}
; 60   : 
; 61   : 	_Istr.width(0);

  001ae	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001b1	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  001b5	48 c7 44 39 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rdi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 62   : 	if (!_Changed)

  001be	45 84 ff	 test	 r15b, r15b
  001c1	75 03		 jne	 SHORT $LN11@operator

; 63   : 		_State |= ios_base::failbit;

  001c3	83 ce 02	 or	 esi, 2
$LN11@operator:

; 64   : 	_Istr.setstate(_State);

  001c6	48 8b 07	 mov	 rax, QWORD PTR [rdi]
  001c9	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  001cd	48 03 cf	 add	 rcx, rdi
  001d0	45 33 c0	 xor	 r8d, r8d
  001d3	8b d6		 mov	 edx, esi
  001d5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  001db	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  001dc	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  001e0	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  001e4	4a 8b 4c 22 48	 mov	 rcx, QWORD PTR [rdx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  001e9	48 85 c9	 test	 rcx, rcx
  001ec	74 07		 je	 SHORT $LN174@operator

; 101  : 				_Myistr.rdbuf()->_Unlock();

  001ee	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  001f1	ff 52 10	 call	 QWORD PTR [rdx+16]
  001f4	90		 npad	 1
$LN174@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 65   : 	return (_Istr);

  001f5	48 8b c7	 mov	 rax, rdi

; 66   : 	}

  001f8	4c 8d 5c 24 70	 lea	 r11, QWORD PTR [rsp+112]
  001fd	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  00201	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  00205	49 8b e3	 mov	 rsp, r11
  00208	41 5f		 pop	 r15
  0020a	41 5e		 pop	 r14
  0020c	41 5d		 pop	 r13
  0020e	41 5c		 pop	 r12
  00210	5f		 pop	 rdi
  00211	c3		 ret	 0
??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z ENDP ; std::operator>><char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00018	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33

; 57   : 				}
; 58   : 		_CATCH_IO_(_Istr)

  00024	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00029	55		 push	 rbp
  0002a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0002e	48 8b ea	 mov	 rbp, rdx
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:
  00031	48 8b 55 38	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0003c	48 03 ca	 add	 rcx, rdx
  0003f	41 b0 01	 mov	 r8b, 1
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0004d	90		 npad	 1
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, $LN20@catch$33
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
  0005b	cc		 int	 3
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
  00000	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$2@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$2
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 40 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00018	48 8d 8a 58 00
	00 00		 lea	 rcx, QWORD PTR $T4[rdx]
  0001f	e9 00 00 00 00	 jmp	 ??1locale@std@@QEAA@XZ	; std::locale::~locale
?dtor$1@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 48
_State$ = 52
_Istr$GSCopy$ = 56
_Ok$ = 64
$T4 = 88
_Istr$ = 160
_Str$ = 168
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA PROC ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33

; 58   : 		_CATCH_IO_(_Istr)

  00024	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00029	55		 push	 rbp
  0002a	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0002e	48 8b ea	 mov	 rbp, rdx
__catch$??$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z$0:
  00031	48 8b 55 38	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00035	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00038	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0003c	48 03 ca	 add	 rcx, rdx
  0003f	41 b0 01	 mov	 r8b, 1
  00042	ba 04 00 00 00	 mov	 edx, 4
  00047	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0004d	90		 npad	 1
  0004e	48 8d 05 00 00
	00 00		 lea	 rax, $LN20@catch$33
  00055	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00059	5d		 pop	 rbp
  0005a	c3		 ret	 0
  0005b	cc		 int	 3
?catch$33@?0???$?5DU?$char_traits@D@std@@V?$allocator@D@1@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@@Z@4HA ENDP ; `std::operator>><char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$33
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z PROC ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>, COMDAT

; 1607 : 	return (static_cast<remove_reference_t<_Ty>&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1608 : 	}

  00003	c3		 ret	 0
??$move@AEAV?$basic_istream@DU?$char_traits@D@std@@@std@@@std@@YA$$QEAV?$basic_istream@DU?$char_traits@D@std@@@0@AEAV10@@Z ENDP ; std::move<std::basic_istream<char,std::char_traits<char> > & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z
_TEXT	SEGMENT
this$dead$ = 48
_Eng$dead$ = 56
_Min$ = 64
_Max$ = 72
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z PROC ; std::uniform_int<int>::_Eval<std::random_device>, COMDAT

; 2352 : 		{	// compute next value in range [_Min, _Max]

$LN91:
  00000	48 89 5c 24 10	 mov	 QWORD PTR [rsp+16], rbx
  00005	48 89 6c 24 18	 mov	 QWORD PTR [rsp+24], rbp
  0000a	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  0000f	41 56		 push	 r14
  00011	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 2353 : 		_Rng_from_urng<_Uty, _Engine> _Rng(_Eng);
; 2354 : 
; 2355 : 		const _Uty _Umin = _Adjust(_Uty(_Min));

  00015	41 be 00 00 00
	80		 mov	 r14d, -2147483648	; ffffffff80000000H

; 2356 : 		const _Uty _Umax = _Adjust(_Uty(_Max));
; 2357 : 
; 2358 : 		_Uty _Uret = 0;
; 2359 : 
; 2360 : 		if (_Umax - _Umin == _Uty(-1))

  0001b	33 db		 xor	 ebx, ebx
  0001d	43 8d 2c 30	 lea	 ebp, DWORD PTR [r8+r14]
  00021	44 2b cd	 sub	 r9d, ebp
  00024	43 8d 3c 31	 lea	 edi, DWORD PTR [r9+r14]
  00028	83 ff ff	 cmp	 edi, -1			; ffffffffH
  0002b	75 11		 jne	 SHORT $LN2@Eval
  0002d	0f 1f 00	 npad	 3
$LL32@Eval:

; 6442 : 		return (_Random_device());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00036	8b d0		 mov	 edx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00038	84 db		 test	 bl, bl
  0003a	75 f4		 jne	 SHORT $LL32@Eval
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2362 : 		else

  0003c	eb 4b		 jmp	 SHORT $LN43@Eval
$LN2@Eval:

; 2363 : 			_Uret = static_cast<_Uty>(_Rng(_Umax - _Umin + 1));

  0003e	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00043	8d 77 01	 lea	 esi, DWORD PTR [rdi+1]
$LL42@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3487 : 			_Udiff _Ret = 0;	// random bits

  00046	44 8b c3	 mov	 r8d, ebx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00049	8b c3		 mov	 eax, ebx

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0004b	85 ff		 test	 edi, edi
  0004d	74 15		 je	 SHORT $LN46@Eval
  0004f	90		 npad	 1
$LL51@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00050	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00056	44 8b c0	 mov	 r8d, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00059	84 db		 test	 bl, bl
  0005b	75 f3		 jne	 SHORT $LL51@Eval

; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  0005d	83 c8 ff	 or	 eax, -1			; ffffffffH
  00060	84 db		 test	 bl, bl
  00062	75 ec		 jne	 SHORT $LL51@Eval
$LN46@Eval:

; 3491 : 				{	// need more random bits
; 3492 : 				_Ret <<= _Bits - 1;	// avoid full shift
; 3493 : 				_Ret <<= 1;
; 3494 : 				_Ret |= _Get_bits();
; 3495 : 				_Mask <<= _Bits - 1;	// avoid full shift
; 3496 : 				_Mask <<= 1;
; 3497 : 				_Mask |= _Bmask;
; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00064	33 d2		 xor	 edx, edx
  00066	f7 f6		 div	 esi
  00068	8b c8		 mov	 ecx, eax
  0006a	44 8b ca	 mov	 r9d, edx
  0006d	33 d2		 xor	 edx, edx
  0006f	41 8b c0	 mov	 eax, r8d
  00072	f7 f6		 div	 esi
  00074	3b c1		 cmp	 eax, ecx
  00076	72 05		 jb	 SHORT $LN76@Eval
  00078	44 3b cf	 cmp	 r9d, edi
  0007b	75 c9		 jne	 SHORT $LL42@Eval
$LN76@Eval:

; 3503 : 				return (_Ret % _Index);

  0007d	33 d2		 xor	 edx, edx
  0007f	41 8b c0	 mov	 eax, r8d
  00082	f7 f6		 div	 esi
  00084	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
$LN43@Eval:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 2366 : 		}

  00089	48 8b 5c 24 38	 mov	 rbx, QWORD PTR [rsp+56]
  0008e	4a 8d 04 32	 lea	 rax, QWORD PTR [rdx+r14]
  00092	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00097	03 c5		 add	 eax, ebp
  00099	48 8b 6c 24 40	 mov	 rbp, QWORD PTR [rsp+64]
  0009e	48 83 c4 20	 add	 rsp, 32			; 00000020H
  000a2	41 5e		 pop	 r14
  000a4	c3		 ret	 0
??$_Eval@Vrandom_device@std@@@?$uniform_int@H@std@@AEBAHAEAVrandom_device@1@HH@Z ENDP ; std::uniform_int<int>::_Eval<std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string
;	COMDAT ??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z
_TEXT	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z PROC ; std::getline<char,std::char_traits<char>,std::allocator<char> >, COMDAT

; 75   : 	{	// get characters into string, discard delimiter

$LN156:
  00000	48 8b c4	 mov	 rax, rsp
  00003	57		 push	 rdi
  00004	41 54		 push	 r12
  00006	41 55		 push	 r13
  00008	41 56		 push	 r14
  0000a	41 57		 push	 r15
  0000c	48 83 ec 50	 sub	 rsp, 80			; 00000050H
  00010	48 c7 40 c8 fe
	ff ff ff	 mov	 QWORD PTR [rax-56], -2
  00018	48 89 58 18	 mov	 QWORD PTR [rax+24], rbx
  0001c	48 89 70 20	 mov	 QWORD PTR [rax+32], rsi
  00020	45 0f b6 f8	 movzx	 r15d, r8b
  00024	48 8b fa	 mov	 rdi, rdx
  00027	48 8b f1	 mov	 rsi, rcx
  0002a	48 89 4c 24 28	 mov	 QWORD PTR _Istr$GSCopy$[rsp], rcx

; 76   : 	typedef basic_istream<_Elem, _Traits> _Myis;
; 77   : 
; 78   : 	ios_base::iostate _State = ios_base::goodbit;

  0002f	33 db		 xor	 ebx, ebx
  00031	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx

; 79   : 	bool _Changed = false;

  00035	45 32 f6	 xor	 r14b, r14b
  00038	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 92   : 			: _Myistr(_Istr)

  0003d	4c 8b e1	 mov	 r12, rcx
  00040	48 89 48 b8	 mov	 QWORD PTR [rax-72], rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00044	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00047	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0004b	4a 8b 4c 21 48	 mov	 rcx, QWORD PTR [rcx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  00050	48 85 c9	 test	 rcx, rcx
  00053	74 07		 je	 SHORT $LN24@getline

; 95   : 				_Myistr.rdbuf()->_Lock();

  00055	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00058	ff 50 08	 call	 QWORD PTR [rax+8]
  0005b	90		 npad	 1
$LN24@getline:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0005c	b2 01		 mov	 dl, 1
  0005e	48 8b ce	 mov	 rcx, rsi
  00061	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00067	88 44 24 38	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 82   : 	if (_Ok)

  0006b	84 c0		 test	 al, al
  0006d	0f 84 e9 00 00
	00		 je	 $LN152@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00073	48 89 5f 10	 mov	 QWORD PTR [rdi+16], rbx

; 1595 : 		value_type * _Result = _Bx._Buf;

  00077	48 8b c7	 mov	 rax, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  0007a	48 83 7f 18 10	 cmp	 QWORD PTR [rdi+24], 16

; 1596 : 		if (_Large_string_engaged())

  0007f	72 03		 jb	 SHORT $LN53@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00081	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN53@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00084	c6 00 00	 mov	 BYTE PTR [rax], 0

; 537  : 		return ((unsigned char)_Ch);

  00087	45 0f b6 ff	 movzx	 r15d, r15b
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 88   : 		typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

  0008b	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0008e	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00092	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00097	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sgetc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  0009d	8b d0		 mov	 edx, eax
  0009f	49 bd ff ff ff
	ff ff ff ff 7f	 mov	 r13, 9223372036854775807 ; 7fffffffffffffffH
  000a9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@getline:

; 91   : 			if (_Traits::eq_int_type(_Traits::eof(), _Meta))

  000b0	83 fa ff	 cmp	 edx, -1
  000b3	75 05		 jne	 SHORT $LN7@getline

; 92   : 				{	// end of file, quit
; 93   : 				_State |= ios_base::eofbit;

  000b5	8d 5a 02	 lea	 ebx, QWORD PTR [rdx+2]

; 94   : 				break;

  000b8	eb 2f		 jmp	 SHORT $LN154@getline
$LN7@getline:

; 95   : 				}
; 96   : 			else if (_Traits::eq_int_type(_Meta, _Metadelim))

  000ba	41 3b d7	 cmp	 edx, r15d
  000bd	75 1c		 jne	 SHORT $LN9@getline

; 97   : 				{	// got a delimiter, discard it and quit
; 98   : 				_Changed = true;

  000bf	41 b6 01	 mov	 r14b, 1
  000c2	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 99   : 				_Istr.rdbuf()->sbumpc();

  000c7	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000ca	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ce	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000d3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sbumpc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ

; 100  : 				break;

  000d9	eb 12		 jmp	 SHORT $LN3@getline
$LN9@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3062 : 		return (this->_Get_data()._Mysize);

  000db	48 8b 4f 10	 mov	 rcx, QWORD PTR [rdi+16]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 102  : 			else if (_Str.max_size() <= _Str.size())

  000df	4c 3b e9	 cmp	 r13, rcx
  000e2	77 0b		 ja	 SHORT $LN11@getline

; 103  : 				{	// string too large, quit
; 104  : 				_State |= ios_base::failbit;

  000e4	bb 02 00 00 00	 mov	 ebx, 2
$LN154@getline:
  000e9	89 5c 24 24	 mov	 DWORD PTR _State$[rsp], ebx
$LN3@getline:
  000ed	eb 68		 jmp	 SHORT $LN18@getline
$LN11@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2992 : 		if (_Old_size < _My_data._Myres)

  000ef	4c 8b 47 18	 mov	 r8, QWORD PTR [rdi+24]
  000f3	49 3b c8	 cmp	 rcx, r8
  000f6	73 1e		 jae	 SHORT $LN117@getline

; 2993 : 			{
; 2994 : 			_My_data._Mysize = _Old_size + 1;

  000f8	48 8d 41 01	 lea	 rax, QWORD PTR [rcx+1]
  000fc	48 89 47 10	 mov	 QWORD PTR [rdi+16], rax

; 1595 : 		value_type * _Result = _Bx._Buf;

  00100	48 8b c7	 mov	 rax, rdi

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00103	49 83 f8 10	 cmp	 r8, 16

; 1596 : 		if (_Large_string_engaged())

  00107	72 03		 jb	 SHORT $LN126@getline
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  00109	48 8b 07	 mov	 rax, QWORD PTR [rdi]
$LN126@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  0010c	88 14 08	 mov	 BYTE PTR [rax+rcx], dl
  0010f	c6 44 08 01 00	 mov	 BYTE PTR [rax+rcx+1], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2998 : 			return;

  00114	eb 0c		 jmp	 SHORT $LN116@getline
$LN117@getline:

; 2999 : 			}
; 3000 : 
; 3001 : 		_Reallocate_grow_by(1,

  00116	44 0f b6 ca	 movzx	 r9d, dl
  0011a	48 8b cf	 mov	 rcx, rdi
  0011d	e8 00 00 00 00	 call	 ??$_Reallocate_grow_by@V<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_319d5e083f45f90dcdce5dce53cbb275>@@D@Z ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_319d5e083f45f90dcdce5dce53cbb275>,char>
$LN116@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 110  : 				_Changed = true;

  00122	41 b6 01	 mov	 r14b, 1
  00125	44 88 74 24 20	 mov	 BYTE PTR _Changed$[rsp], r14b

; 89   : 
; 90   : 		for (; ; _Meta = _Istr.rdbuf()->snextc())

  0012a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0012d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00131	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?snextc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHXZ
  0013c	8b d0		 mov	 edx, eax
  0013e	e9 6d ff ff ff	 jmp	 $LL4@getline
$LN19@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  00143	8b 5c 24 24	 mov	 ebx, DWORD PTR _State$[rsp]
  00147	44 0f b6 74 24
	20		 movzx	 r14d, BYTE PTR _Changed$[rsp]
  0014d	4c 8b 64 24 30	 mov	 r12, QWORD PTR _Ok$[rsp]
  00152	48 8b 74 24 28	 mov	 rsi, QWORD PTR _Istr$GSCopy$[rsp]
$LN18@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)
; 113  : 		}
; 114  : 
; 115  : 	if (!_Changed)

  00157	45 84 f6	 test	 r14b, r14b
  0015a	75 03		 jne	 SHORT $LN13@getline
$LN152@getline:

; 116  : 		_State |= ios_base::failbit;

  0015c	83 cb 02	 or	 ebx, 2
$LN13@getline:

; 117  : 	_Istr.setstate(_State);

  0015f	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00162	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00166	48 03 ce	 add	 rcx, rsi
  00169	45 33 c0	 xor	 r8d, r8d
  0016c	8b d3		 mov	 edx, ebx
  0016e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00174	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  00175	49 8b 0c 24	 mov	 rcx, QWORD PTR [r12]
  00179	48 63 51 04	 movsxd	 rdx, DWORD PTR [rcx+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  0017d	4a 8b 4c 22 48	 mov	 rcx, QWORD PTR [rdx+r12+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  00182	48 85 c9	 test	 rcx, rcx
  00185	74 07		 je	 SHORT $LN153@getline

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00187	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  0018a	ff 52 10	 call	 QWORD PTR [rdx+16]
  0018d	90		 npad	 1
$LN153@getline:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\string

; 118  : 	return (_Istr);

  0018e	48 8b c6	 mov	 rax, rsi

; 119  : 	}

  00191	4c 8d 5c 24 50	 lea	 r11, QWORD PTR [rsp+80]
  00196	49 8b 5b 40	 mov	 rbx, QWORD PTR [r11+64]
  0019a	49 8b 73 48	 mov	 rsi, QWORD PTR [r11+72]
  0019e	49 8b e3	 mov	 rsp, r11
  001a1	41 5f		 pop	 r15
  001a3	41 5e		 pop	 r14
  001a5	41 5d		 pop	 r13
  001a7	41 5c		 pop	 r12
  001a9	5f		 pop	 rdi
  001aa	c3		 ret	 0
??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z ENDP ; std::getline<char,std::char_traits<char>,std::allocator<char> >
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28

; 111  : 				}
; 112  : 		_CATCH_IO_(_Istr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  00025	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$28
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
  00000	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
  0000c	48 8d 8a 30 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
?dtor$0@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
_Changed$ = 32
_State$ = 36
_Istr$GSCopy$ = 40
_Ok$ = 48
_Istr$ = 128
_Str$ = 136
_Delim$ = 144
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA PROC ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28

; 112  : 		_CATCH_IO_(_Istr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z$0:
  00025	48 8b 55 28	 mov	 rdx, QWORD PTR _Istr$GSCopy$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN19@catch$28
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$28@?0???$getline@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@YAAEAV?$basic_istream@DU?$char_traits@D@std@@@0@$$QEAV10@AEAV?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@0@D@Z@4HA ENDP ; `std::getline<char,std::char_traits<char>,std::allocator<char> >'::`1'::catch$28
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
;	COMDAT ??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z
_TEXT	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z PROC ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>, COMDAT

; 24   : 	{	// insert a character-type sequence into _Ostr as if through a basic_string copy

$LN111:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	56		 push	 rsi
  00006	57		 push	 rdi
  00007	41 54		 push	 r12
  00009	41 56		 push	 r14
  0000b	41 57		 push	 r15
  0000d	48 83 ec 40	 sub	 rsp, 64			; 00000040H
  00011	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T27[rsp], -2
  0001a	48 89 5c 24 78	 mov	 QWORD PTR [rsp+120], rbx
  0001f	4d 8b f8	 mov	 r15, r8
  00022	4c 8b e2	 mov	 r12, rdx
  00025	48 8b f1	 mov	 rsi, rcx

; 25   : 	ios_base::iostate _State = ios_base::goodbit;

  00028	33 db		 xor	 ebx, ebx
  0002a	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  00031	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00034	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 422  : 		return (_Wide);

  00038	49 8b 7c 09 28	 mov	 rdi, QWORD PTR [r9+rcx+40]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 26   : 	_SizeT _Pad = _Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size

  0003d	48 85 ff	 test	 rdi, rdi
  00040	7e 0a		 jle	 SHORT $LN17@Insert_str
  00042	49 3b f8	 cmp	 rdi, r8
  00045	76 05		 jbe	 SHORT $LN17@Insert_str
  00047	49 2b f8	 sub	 rdi, r8
  0004a	eb 02		 jmp	 SHORT $LN18@Insert_str
$LN17@Insert_str:
  0004c	33 ff		 xor	 edi, edi
$LN18@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 98   : 			: _Myostr(_Ostr)

  0004e	4c 8b f6	 mov	 r14, rsi
  00051	48 89 74 24 28	 mov	 QWORD PTR _Ok$[rsp], rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00056	49 8b 4c 09 48	 mov	 rcx, QWORD PTR [r9+rcx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 100  : 			if (_Myostr.rdbuf() != 0)

  0005b	48 85 c9	 test	 rcx, rcx
  0005e	74 07		 je	 SHORT $LN35@Insert_str

; 101  : 				_Myostr.rdbuf()->_Lock();

  00060	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00063	ff 50 08	 call	 QWORD PTR [rax+8]
  00066	90		 npad	 1
$LN35@Insert_str:

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00067	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0006a	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  0006e	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  00073	75 15		 jne	 SHORT $LN31@Insert_str
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 79   : 		return (_Tiestr);

  00075	48 8b 4c 31 50	 mov	 rcx, QWORD PTR [rcx+rsi+80]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 123  : 			if (_Ostr.good() && _Ostr.tie() != 0 && _Ostr.tie() != &_Ostr)

  0007a	48 85 c9	 test	 rcx, rcx
  0007d	74 0b		 je	 SHORT $LN31@Insert_str
  0007f	48 3b ce	 cmp	 rcx, rsi
  00082	74 06		 je	 SHORT $LN31@Insert_str

; 124  : 				_Ostr.tie()->flush();

  00084	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?flush@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAAEAV12@XZ
$LN31@Insert_str:

; 125  : 			_Ok = _Ostr.good();	// store test only after flushing tie

  0008a	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  0008d	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 338  : 		return (rdstate() == goodbit);

  00091	83 7c 31 10 00	 cmp	 DWORD PTR [rcx+rsi+16], 0
  00096	0f 94 c0	 sete	 al
  00099	88 44 24 30	 mov	 BYTE PTR _Ok$[rsp+8], al
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 30   : 	if (!_Ok)

  0009d	84 c0		 test	 al, al
  0009f	75 0a		 jne	 SHORT $LN8@Insert_str

; 31   : 		_State |= ios_base::badbit;

  000a1	bb 04 00 00 00	 mov	 ebx, 4

; 32   : 	else

  000a6	e9 ca 00 00 00	 jmp	 $LN22@Insert_str
$LN8@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 377  : 		return (_Fmtfl);

  000ab	8b 44 31 18	 mov	 eax, DWORD PTR [rcx+rsi+24]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 35   : 		if ((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)

  000af	25 c0 01 00 00	 and	 eax, 448		; 000001c0H
  000b4	83 f8 40	 cmp	 eax, 64			; 00000040H
  000b7	74 3f		 je	 SHORT $LN103@Insert_str
  000b9	0f 1f 80 00 00
	00 00		 npad	 7
$LL4@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000c0	48 85 ff	 test	 rdi, rdi
  000c3	74 2f		 je	 SHORT $LN3@Insert_str

; 37   : 				if (_Traits::eq_int_type(_Traits::eof(),

  000c5	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000c8	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000cc	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  000d1	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  000d6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  000dc	83 f8 ff	 cmp	 eax, -1
  000df	75 0e		 jne	 SHORT $LN2@Insert_str

; 38   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 39   : 					{	// insertion failed, quit
; 40   : 					_State |= ios_base::badbit;

  000e1	bb 04 00 00 00	 mov	 ebx, 4
  000e6	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx

; 41   : 					break;

  000ed	eb 31		 jmp	 SHORT $LL107@Insert_str
$LN2@Insert_str:

; 36   : 			for (; 0 < _Pad; --_Pad)	// pad on left

  000ef	48 ff cf	 dec	 rdi
  000f2	eb cc		 jmp	 SHORT $LL4@Insert_str
$LN3@Insert_str:

; 42   : 					}
; 43   : 
; 44   : 		if (_State == ios_base::goodbit
; 45   : 			&& _Ostr.rdbuf()->sputn(_Data, (streamsize)_Size)

  000f4	85 db		 test	 ebx, ebx
  000f6	75 28		 jne	 SHORT $LL107@Insert_str
$LN103@Insert_str:
  000f8	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  000fb	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  000ff	4d 8b c7	 mov	 r8, r15
  00102	49 8b d4	 mov	 rdx, r12
  00105	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  0010a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputn@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAA_JPEBD_J@Z
  00110	49 3b c7	 cmp	 rax, r15
  00113	74 0b		 je	 SHORT $LL107@Insert_str

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  00115	bb 04 00 00 00	 mov	 ebx, 4

; 48   : 		else

  0011a	eb 2f		 jmp	 SHORT $LN109@Insert_str
  0011c	0f 1f 40 00	 npad	 4
$LL107@Insert_str:

; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00120	48 85 ff	 test	 rdi, rdi
  00123	74 2d		 je	 SHORT $LN6@Insert_str

; 50   : 				if (_Traits::eq_int_type(_Traits::eof(),

  00125	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00128	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0012c	0f b6 54 31 58	 movzx	 edx, BYTE PTR [rcx+rsi+88]
  00131	48 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+rsi+72]
  00136	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?sputc@?$basic_streambuf@DU?$char_traits@D@std@@@std@@QEAAHD@Z
  0013c	83 f8 ff	 cmp	 eax, -1
  0013f	75 05		 jne	 SHORT $LN5@Insert_str

; 51   : 					_Ostr.rdbuf()->sputc(_Ostr.fill())))
; 52   : 					{	// insertion failed, quit
; 53   : 					_State |= ios_base::badbit;

  00141	83 cb 04	 or	 ebx, 4

; 54   : 					break;

  00144	eb 05		 jmp	 SHORT $LN109@Insert_str
$LN5@Insert_str:

; 49   : 			for (; 0 < _Pad; --_Pad)	// pad on right

  00146	48 ff cf	 dec	 rdi
  00149	eb d5		 jmp	 SHORT $LL107@Insert_str
$LN109@Insert_str:

; 46   : 				!= (streamsize)_Size)
; 47   : 				_State |= ios_base::badbit;

  0014b	89 9c 24 88 00
	00 00		 mov	 DWORD PTR _State$[rsp], ebx
$LN6@Insert_str:

; 55   : 					}
; 56   : 		_Ostr.width(0);

  00152	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00155	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xiosbase

; 428  : 		_Wide = _Newwidth;

  00159	48 c7 44 31 28
	00 00 00 00	 mov	 QWORD PTR [rcx+rsi+40], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h
  00162	eb 11		 jmp	 SHORT $LN22@Insert_str
$LN23@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
  00164	48 8b 74 24 70	 mov	 rsi, QWORD PTR _Ostr$[rsp]
  00169	8b 9c 24 88 00
	00 00		 mov	 ebx, DWORD PTR _State$[rsp]
  00170	4c 8b 74 24 28	 mov	 r14, QWORD PTR _Ok$[rsp]
$LN22@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 60   : 	_Ostr.setstate(_State);

  00175	48 8b 06	 mov	 rax, QWORD PTR [rsi]
  00178	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  0017c	48 03 ce	 add	 rcx, rsi
  0017f	45 33 c0	 xor	 r8d, r8d
  00182	8b d3		 mov	 edx, ebx
  00184	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  0018a	90		 npad	 1
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 131  : 			if (!_STD uncaught_exception())

  0018b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?uncaught_exception@std@@YA_NXZ
  00191	84 c0		 test	 al, al
  00193	75 0a		 jne	 SHORT $LN84@Insert_str

; 132  : 				this->_Myostr._Osfx();

  00195	49 8b ce	 mov	 rcx, r14
  00198	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Osfx@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAAXXZ
  0019e	90		 npad	 1
$LN84@Insert_str:

; 106  : 			if (_Myostr.rdbuf() != 0)

  0019f	49 8b 06	 mov	 rax, QWORD PTR [r14]
  001a2	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  001a6	4a 8b 4c 31 48	 mov	 rcx, QWORD PTR [rcx+r14+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ostream

; 106  : 			if (_Myostr.rdbuf() != 0)

  001ab	48 85 c9	 test	 rcx, rcx
  001ae	74 07		 je	 SHORT $LN88@Insert_str

; 107  : 				_Myostr.rdbuf()->_Unlock();

  001b0	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  001b3	ff 50 10	 call	 QWORD PTR [rax+16]
  001b6	90		 npad	 1
$LN88@Insert_str:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring_insert.h

; 61   : 	return (_Ostr);

  001b7	48 8b c6	 mov	 rax, rsi

; 62   : 	}

  001ba	48 8b 5c 24 78	 mov	 rbx, QWORD PTR [rsp+120]
  001bf	48 83 c4 40	 add	 rsp, 64			; 00000040H
  001c3	41 5f		 pop	 r15
  001c5	41 5e		 pop	 r14
  001c7	41 5c		 pop	 r12
  001c9	5f		 pop	 rdi
  001ca	5e		 pop	 rsi
  001cb	c3		 ret	 0
??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z ENDP ; std::_Insert_string<char,std::char_traits<char>,unsigned __int64>
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8

; 57   : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$8
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
  00000	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$1@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$1
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
  0000c	48 8d 8a 28 00
	00 00		 lea	 rcx, QWORD PTR _Ok$[rdx]
  00013	e9 00 00 00 00	 jmp	 ??1sentry@?$basic_ostream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_ostream<char,std::char_traits<char> >::sentry::~sentry
?dtor$0@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T27 = 32
_Ok$ = 40
_Ostr$ = 112
_Data$ = 120
_Size$ = 128
_State$ = 136
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA PROC ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8

; 57   : 		_CATCH_IO_(_Ostr)

  00018	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0001d	55		 push	 rbp
  0001e	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00022	48 8b ea	 mov	 rbp, rdx
__catch$??$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z$0:
  00025	48 8b 55 70	 mov	 rdx, QWORD PTR _Ostr$[rbp]
  00029	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0002c	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00030	48 03 ca	 add	 rcx, rdx
  00033	41 b0 01	 mov	 r8b, 1
  00036	ba 04 00 00 00	 mov	 edx, 4
  0003b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?setstate@?$basic_ios@DU?$char_traits@D@std@@@std@@QEAAXH_N@Z
  00041	90		 npad	 1
  00042	48 8d 05 00 00
	00 00		 lea	 rax, $LN23@catch$8
  00049	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0004d	5d		 pop	 rbp
  0004e	c3		 ret	 0
  0004f	cc		 int	 3
?catch$8@?0???$_Insert_string@DU?$char_traits@D@std@@_K@std@@YAAEAV?$basic_ostream@DU?$char_traits@D@std@@@0@AEAV10@QEBD_K@Z@4HA ENDP ; `std::_Insert_string<char,std::char_traits<char>,unsigned __int64>'::`1'::catch$8
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z PROC ; std::forward<std::allocator<char> >, COMDAT

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1593 : 	}

  00003	c3		 ret	 0
??$forward@V?$allocator@D@std@@@std@@YA$$QEAV?$allocator@D@0@AEAV10@@Z ENDP ; std::forward<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0V?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@$$QEAV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z
_TEXT	SEGMENT
_Left$dead$ = 8
_Right$dead$ = 16
__formal$dead$ = 24
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z PROC ; std::_Pocma<std::allocator<char> >, COMDAT

; 1042 : 	_Left = _STD move(_Right);
; 1043 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocma@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@0U?$integral_constant@_N$00@0@@Z ENDP ; std::_Pocma<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
;	COMDAT ??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z
_TEXT	SEGMENT
__formal$dead$ = 8
__formal$dead$ = 16
__formal$dead$ = 24
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z PROC ; std::_Pocca<std::allocator<char> >, COMDAT

; 1029 : 	}

  00000	c2 00 00	 ret	 0
??$_Pocca@V?$allocator@D@std@@@std@@YAXAEAV?$allocator@D@0@AEBV10@U?$integral_constant@_N$0A@@0@@Z ENDP ; std::_Pocca<std::allocator<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z PROC		; std::forward<char * __ptr64 const & __ptr64>, COMDAT

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1593 : 	}

  00003	c3		 ret	 0
??$forward@AEBQEAD@std@@YAAEBQEADAEBQEAD@Z ENDP		; std::forward<char * __ptr64 const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\type_traits
;	COMDAT ??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z
_TEXT	SEGMENT
_Arg$ = 8
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z PROC ; std::forward<std::allocator<char> const & __ptr64>, COMDAT

; 1592 : 	return (static_cast<_Ty&&>(_Arg));

  00000	48 8b c1	 mov	 rax, rcx

; 1593 : 	}

  00003	c3		 ret	 0
??$forward@AEBV?$allocator@D@std@@@std@@YAAEBV?$allocator@D@0@AEBV10@@Z ENDP ; std::forward<std::allocator<char> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z
_TEXT	SEGMENT
this$ = 8
__formal$dead$ = 16
_Val1$dead$ = 24
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z PROC ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>, COMDAT
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 1576 : 		_Mysize(0),

  00000	33 c0		 xor	 eax, eax
  00002	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 1577 : 		_Myres(0)

  00006	48 89 41 18	 mov	 QWORD PTR [rcx+24], rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 313  : 		}

  0000a	48 8b c1	 mov	 rax, rcx
  0000d	c3		 ret	 0
??$?0AEBV?$allocator@D@std@@$$V@?$_Compressed_pair@V?$allocator@D@std@@V?$_String_val@U?$_Simple_types@D@std@@@2@$00@std@@QEAA@U_One_then_variadic_args_t@1@AEBV?$allocator@D@1@@Z ENDP ; std::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1>::_Compressed_pair<std::allocator<char>,std::_String_val<std::_Simple_types<char> >,1><std::allocator<char> const & __ptr64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z
_TEXT	SEGMENT
_Left$ = 48
_Left_size$ = 56
_Right$ = 64
_Right_size$ = 72
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z PROC ; std::_Traits_equal<std::char_traits<char> >, COMDAT

; 24   : 	{	// compare [_Left, _Left + _Left_size) to [_Right, _Right + _Right_size) for equality using _Traits

$LN9:
  00000	48 83 ec 28	 sub	 rsp, 40			; 00000028H
  00004	49 8b c0	 mov	 rax, r8

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00007	49 3b d1	 cmp	 rdx, r9
  0000a	75 16		 jne	 SHORT $LN3@Traits_equ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 475  : 		return (_CSTD memcmp(_First1, _First2, _Count));

  0000c	4c 8b c2	 mov	 r8, rdx
  0000f	48 8b d0	 mov	 rdx, rax
  00012	e8 00 00 00 00	 call	 memcmp
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00017	85 c0		 test	 eax, eax
  00019	75 07		 jne	 SHORT $LN3@Traits_equ
  0001b	b0 01		 mov	 al, 1

; 26   : 	}

  0001d	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00021	c3		 ret	 0
$LN3@Traits_equ:

; 25   : 	return (_Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0);

  00022	32 c0		 xor	 al, al

; 26   : 	}

  00024	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00028	c3		 ret	 0
??$_Traits_equal@U?$char_traits@D@std@@@std@@YA_NQEBD_K01@Z ENDP ; std::_Traits_equal<std::char_traits<char> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z
_TEXT	SEGMENT
this$ = 80
_Size_increase$ = 88
_Fn$dead$ = 96
??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >, COMDAT

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	57		 push	 rdi
  00003	41 57		 push	 r15
  00005	48 83 ec 30	 sub	 rsp, 48			; 00000030H

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;

  00009	4c 8b 79 10	 mov	 r15, QWORD PTR [rcx+16]

; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  0000d	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  00017	48 8b c3	 mov	 rax, rbx
  0001a	48 8b f9	 mov	 rdi, rcx
  0001d	49 2b c7	 sub	 rax, r15
  00020	48 3b c2	 cmp	 rax, rdx
  00023	0f 82 32 01 00
	00		 jb	 $LN135@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00029	4c 89 64 24 28	 mov	 QWORD PTR [rsp+40], r12
  0002e	4e 8d 24 3a	 lea	 r12, QWORD PTR [rdx+r15]
  00032	4c 89 74 24 20	 mov	 QWORD PTR [rsp+32], r14

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00037	4c 8b 71 18	 mov	 r14, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  0003b	49 8b cc	 mov	 rcx, r12
  0003e	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  00042	48 3b cb	 cmp	 rcx, rbx
  00045	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00047	49 8b d6	 mov	 rdx, r14
  0004a	48 8b c3	 mov	 rax, rbx
  0004d	48 d1 ea	 shr	 rdx, 1
  00050	48 2b c2	 sub	 rax, rdx
  00053	4c 3b f0	 cmp	 r14, rax
  00056	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00058	4a 8d 04 32	 lea	 rax, QWORD PTR [rdx+r14]
  0005c	48 8b d9	 mov	 rbx, rcx
  0005f	48 3b c8	 cmp	 rcx, rax
  00062	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00066	48 89 6c 24 60	 mov	 QWORD PTR [rsp+96], rbp
  0006b	48 8b cb	 mov	 rcx, rbx
  0006e	48 83 c1 01	 add	 rcx, 1
  00072	48 89 74 24 68	 mov	 QWORD PTR [rsp+104], rsi
  00077	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  0007e	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  00082	33 ed		 xor	 ebp, ebp
  00084	48 85 c9	 test	 rcx, rcx
  00087	75 04		 jne	 SHORT $LN76@Reallocate
  00089	8b f5		 mov	 esi, ebp
  0008b	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  0008d	40 84 ed	 test	 bpl, bpl
  00090	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  00092	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  00098	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  00099	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000a0	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000a2	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000a6	48 3b c1	 cmp	 rax, rcx
  000a9	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000ab	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000b1	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000b2	48 8b c8	 mov	 rcx, rax
  000b5	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000ba	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000be	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000c2	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000c6	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000c8	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000cd	48 8b f0	 mov	 rsi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000d0	4c 89 67 10	 mov	 QWORD PTR [rdi+16], r12

; 3113 : 				_Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);

  000d4	4d 8d 47 01	 lea	 r8, QWORD PTR [r15+1]

; 3657 : 		_My_data._Myres = _New_capacity;

  000d8	48 89 5f 18	 mov	 QWORD PTR [rdi+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000dc	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000df	49 83 fe 10	 cmp	 r14, 16
  000e3	72 4b		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000e5	48 8b 1f	 mov	 rbx, QWORD PTR [rdi]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000e8	48 8b d3	 mov	 rdx, rbx
  000eb	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  000f0	49 ff c6	 inc	 r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  000f3	40 84 ed	 test	 bpl, bpl
  000f6	75 31		 jne	 SHORT $_Invalid_parameter$137

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  000f8	49 81 fe 00 10
	00 00		 cmp	 r14, 4096		; 00001000H
  000ff	72 1e		 jb	 SHORT $LN102@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00101	f6 c3 1f	 test	 bl, 31
  00104	75 23		 jne	 SHORT $_Invalid_parameter$137

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00106	48 8b 43 f8	 mov	 rax, QWORD PTR [rbx-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0010a	48 3b c3	 cmp	 rax, rbx
  0010d	73 1a		 jae	 SHORT $_Invalid_parameter$137
  0010f	48 2b d8	 sub	 rbx, rax
  00112	48 83 eb 08	 sub	 rbx, 8
  00116	48 83 fb 1f	 cmp	 rbx, 31
  0011a	77 0d		 ja	 SHORT $_Invalid_parameter$137

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0011c	48 8b d8	 mov	 rbx, rax
$LN102@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  0011f	48 8b cb	 mov	 rcx, rbx
  00122	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3666 : 		else

  00127	eb 0f		 jmp	 SHORT $LN134@Reallocate
$_Invalid_parameter$137:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  00129	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  0012f	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00130	48 8b d7	 mov	 rdx, rdi
  00133	e8 00 00 00 00	 call	 memcpy
$LN134@Reallocate:
  00138	48 8b 6c 24 60	 mov	 rbp, QWORD PTR [rsp+96]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0013d	48 8b c7	 mov	 rax, rdi
  00140	4c 8b 64 24 28	 mov	 r12, QWORD PTR [rsp+40]
  00145	4c 8b 74 24 20	 mov	 r14, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0014a	48 89 37	 mov	 QWORD PTR [rdi], rsi
  0014d	48 8b 74 24 68	 mov	 rsi, QWORD PTR [rsp+104]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3673 : 		}

  00152	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00156	41 5f		 pop	 r15
  00158	5f		 pop	 rdi
  00159	5b		 pop	 rbx
  0015a	c3		 ret	 0
$LN135@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  0015b	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00160	cc		 int	 3
$LN133@Reallocate:
??$_Reallocate_grow_by@V<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@$$V@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_9013ee9e23efe4882b67eff5b0ecf103>@@@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_9013ee9e23efe4882b67eff5b0ecf103> >
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z
_TEXT	SEGMENT
this$ = 96
_Size_increase$ = 104
_Fn$dead$ = 112
<_Args_0>$dead$ = 120
<_Args_1>$ = 128
<_Args_2>$ = 136
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>, COMDAT

; 3641 : 		{	// reallocate to increase size by _Size_increase elements, new buffer prepared by

  00000	40 53		 push	 rbx
  00002	41 54		 push	 r12
  00004	41 55		 push	 r13
  00006	41 56		 push	 r14
  00008	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 3642 : 			// _Fn(_New_ptr, _Old_ptr, _Old_size, _Args...)
; 3643 : 		auto& _My_data = this->_Get_data();
; 3644 : 		const size_type _Old_size = _My_data._Mysize;

  0000c	4c 8b 69 10	 mov	 r13, QWORD PTR [rcx+16]

; 3645 : 		if (max_size() - _Old_size < _Size_increase)

  00010	48 bb ff ff ff
	ff ff ff ff 7f	 mov	 rbx, 9223372036854775807 ; 7fffffffffffffffH
  0001a	4c 8b a4 24 80
	00 00 00	 mov	 r12, QWORD PTR <_Args_1>$[rsp]
  00022	48 8b c3	 mov	 rax, rbx
  00025	49 2b c5	 sub	 rax, r13
  00028	4c 8b f1	 mov	 r14, rcx
  0002b	48 3b c2	 cmp	 rax, rdx
  0002e	0f 82 5a 01 00
	00		 jb	 $LN147@Reallocate

; 3648 : 			}
; 3649 : 
; 3650 : 		const size_type _New_size = _Old_size + _Size_increase;

  00034	48 89 7c 24 28	 mov	 QWORD PTR [rsp+40], rdi
  00039	4a 8d 3c 2a	 lea	 rdi, QWORD PTR [rdx+r13]
  0003d	4c 89 7c 24 20	 mov	 QWORD PTR [rsp+32], r15

; 3651 : 		const size_type _Old_capacity = _My_data._Myres;

  00042	4c 8b 79 18	 mov	 r15, QWORD PTR [rcx+24]

; 3591 : 		const size_type _Masked = _Requested | this->_ALLOC_MASK;

  00046	48 8b cf	 mov	 rcx, rdi
  00049	48 83 c9 0f	 or	 rcx, 15

; 3592 : 		if (_Masked > _Max)

  0004d	48 3b cb	 cmp	 rcx, rbx
  00050	77 1f		 ja	 SHORT $LN33@Reallocate

; 3593 : 			{	// the mask overflows, settle for max_size()
; 3594 : 			return (_Max);
; 3595 : 			}
; 3596 : 
; 3597 : 		const size_type _Old = _My_data._Myres;
; 3598 : 		if (_Old > _Max - _Old / 2)

  00052	49 8b d7	 mov	 rdx, r15
  00055	48 8b c3	 mov	 rax, rbx
  00058	48 d1 ea	 shr	 rdx, 1
  0005b	48 2b c2	 sub	 rax, rdx
  0005e	4c 3b f8	 cmp	 r15, rax
  00061	77 0e		 ja	 SHORT $LN33@Reallocate

; 3599 : 			{	// similarly, geometric overflows
; 3600 : 			return (_Max);
; 3601 : 			}
; 3602 : 
; 3603 : 		return (_Max_value(_Masked, _Old + _Old / 2));

  00063	4a 8d 04 3a	 lea	 rax, QWORD PTR [rdx+r15]
  00067	48 8b d9	 mov	 rbx, rcx
  0006a	48 3b c8	 cmp	 rcx, rax
  0006d	48 0f 42 d8	 cmovb	 rbx, rax
$LN33@Reallocate:

; 3652 : 		const size_type _New_capacity = _Calculate_growth(_New_size);
; 3653 : 		auto& _Al = this->_Getal();
; 3654 : 		const pointer _New_ptr = _Al.allocate(_New_capacity + 1); // throws

  00071	48 89 6c 24 70	 mov	 QWORD PTR [rsp+112], rbp
  00076	48 8b cb	 mov	 rcx, rbx
  00079	48 83 c1 01	 add	 rcx, 1
  0007d	48 89 74 24 30	 mov	 QWORD PTR [rsp+48], rsi
  00082	48 c7 c0 ff ff
	ff ff		 mov	 rax, -1
  00089	48 0f 42 c8	 cmovb	 rcx, rax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 54   : 		return (_Ptr);

  0008d	33 ed		 xor	 ebp, ebp
  0008f	48 85 c9	 test	 rcx, rcx
  00092	75 04		 jne	 SHORT $LN76@Reallocate
  00094	8b f5		 mov	 esi, ebp
  00096	eb 43		 jmp	 SHORT $LN75@Reallocate
$LN76@Reallocate:

; 55   : 		}
; 56   : 
; 57   : 	// check overflow of multiply
; 58   : 	if (static_cast<size_t>(-1) / _Sz < _Count)

  00098	40 84 ed	 test	 bpl, bpl
  0009b	74 07		 je	 SHORT $LN77@Reallocate

; 59   : 		{
; 60   : 		_Xbad_alloc();	// report no memory

  0009d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000a3	cc		 int	 3
$LN77@Reallocate:

; 61   : 		}
; 62   : 
; 63   : 	const size_t _User_size = _Count * _Sz;
; 64   : 
; 65   : #if defined(_M_IX86) || defined(_M_X64)
; 66   : 	if (_Try_aligned_allocation
; 67   : 		&& _BIG_ALLOCATION_THRESHOLD <= _User_size)

  000a4	48 81 f9 00 10
	00 00		 cmp	 rcx, 4096		; 00001000H
  000ab	72 26		 jb	 SHORT $LN78@Reallocate

; 68   : 		{	// allocate large block
; 69   : 		static_assert(sizeof(void *) < _BIG_ALLOCATION_ALIGNMENT,
; 70   : 			"Big allocations should at least match vector register size");
; 71   : 		const size_t _Block_size = _NON_USER_SIZE + _User_size;

  000ad	48 8d 41 27	 lea	 rax, QWORD PTR [rcx+39]

; 72   : 		if (_Block_size <= _User_size)

  000b1	48 3b c1	 cmp	 rax, rcx
  000b4	77 07		 ja	 SHORT $LN79@Reallocate

; 73   : 			{
; 74   : 			_Xbad_alloc();	// report no memory

  000b6	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Xbad_alloc@std@@YAXXZ
  000bc	cc		 int	 3
$LN79@Reallocate:

; 75   : 			}
; 76   : 
; 77   : 		const uintptr_t _Ptr_container =
; 78   : 			reinterpret_cast<uintptr_t>(::operator new(_Block_size));

  000bd	48 8b c8	 mov	 rcx, rax
  000c0	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new

; 79   : 		_SCL_SECURE_ALWAYS_VALIDATE(_Ptr_container != 0);
; 80   : 		_Ptr = reinterpret_cast<void *>((_Ptr_container + _NON_USER_SIZE)

  000c5	48 8d 70 27	 lea	 rsi, QWORD PTR [rax+39]
  000c9	48 83 e6 e0	 and	 rsi, -32		; ffffffffffffffe0H

; 81   : 			& ~(_BIG_ALLOCATION_ALIGNMENT - 1));
; 82   : 		static_cast<uintptr_t *>(_Ptr)[-1] = _Ptr_container;

  000cd	48 89 46 f8	 mov	 QWORD PTR [rsi-8], rax

; 83   : 
; 84   :  #ifdef _DEBUG
; 85   : 		static_cast<uintptr_t *>(_Ptr)[-2] = _BIG_ALLOCATION_SENTINEL;
; 86   :  #endif /* _DEBUG */
; 87   :  		return (_Ptr);

  000d1	eb 08		 jmp	 SHORT $LN75@Reallocate
$LN78@Reallocate:

; 88   : 		}
; 89   : #else /* ^^^ x86/x64 hardware ^^^ // vvv ARM hardware vvv */
; 90   : 	(void)_Try_aligned_allocation;
; 91   : #endif /* defined(_M_IX86) || defined(_M_X64) */
; 92   : 
; 93   : 	_Ptr = ::operator new(_User_size);

  000d3	e8 00 00 00 00	 call	 ??2@YAPEAX_K@Z		; operator new
  000d8	48 8b f0	 mov	 rsi, rax
$LN75@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3657 : 		_My_data._Myres = _New_capacity;

  000db	49 89 5e 18	 mov	 QWORD PTR [r14+24], rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000df	49 8b d4	 mov	 rdx, r12
  000e2	48 8b 9c 24 88
	00 00 00	 mov	 rbx, QWORD PTR <_Args_2>$[rsp]
  000ea	48 8b ce	 mov	 rcx, rsi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3656 : 		_My_data._Mysize = _New_size;

  000ed	49 89 7e 10	 mov	 QWORD PTR [r14+16], rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000f1	4c 8b c3	 mov	 r8, rbx
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3659 : 		if (this->_BUF_SIZE <= _Old_capacity)

  000f4	49 83 ff 10	 cmp	 r15, 16
  000f8	72 59		 jb	 SHORT $LN3@Reallocate

; 3660 : 			{
; 3661 : 			const pointer _Old_ptr = _My_data._Bx._Ptr;

  000fa	49 8b 3e	 mov	 rdi, QWORD PTR [r14]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  000fd	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00102	4d 8d 45 01	 lea	 r8, QWORD PTR [r13+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00106	48 8b d7	 mov	 rdx, rdi
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00109	48 8d 0c 1e	 lea	 rcx, QWORD PTR [rsi+rbx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0010d	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3663 : 			_Al.deallocate(_Old_ptr, _Old_capacity + 1);

  00112	49 ff c7	 inc	 r15
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 102  : 	if (_Count > static_cast<size_t>(-1) / _Sz)

  00115	40 84 ed	 test	 bpl, bpl
  00118	75 32		 jne	 SHORT $_Invalid_parameter$149

; 103  : 		{
; 104  : 		goto _Invalid_parameter; // TRANSITION, VSO#359498
; 105  : 		}
; 106  : 
; 107  : 	if (_BIG_ALLOCATION_THRESHOLD <= _Count * _Sz)

  0011a	49 81 ff 00 10
	00 00		 cmp	 r15, 4096		; 00001000H
  00121	72 1f		 jb	 SHORT $LN108@Reallocate

; 108  : 		{	// deallocate large block
; 109  : 		const uintptr_t _Ptr_user = reinterpret_cast<uintptr_t>(_Ptr);
; 110  : 		if ((_Ptr_user & (_BIG_ALLOCATION_ALIGNMENT - 1)) != 0)

  00123	40 f6 c7 1f	 test	 dil, 31
  00127	75 23		 jne	 SHORT $_Invalid_parameter$149

; 111  : 			{
; 112  : 			goto _Invalid_parameter;
; 113  : 			}
; 114  : 
; 115  : 		const uintptr_t _Ptr_ptr = _Ptr_user - sizeof(void *);
; 116  : 		const uintptr_t _Ptr_container =
; 117  : 			*reinterpret_cast<uintptr_t *>(_Ptr_ptr);

  00129	48 8b 47 f8	 mov	 rax, QWORD PTR [rdi-8]

; 118  : 
; 119  :  #ifdef _DEBUG
; 120  : 		// If the following asserts, it likely means that we are performing
; 121  : 		// an aligned delete on memory coming from an unaligned allocation.
; 122  : 		if (reinterpret_cast<uintptr_t *>(_Ptr_ptr)[-1] != _BIG_ALLOCATION_SENTINEL)
; 123  : 			{
; 124  : 			goto _Invalid_parameter;
; 125  : 			}
; 126  :  #endif /* _DEBUG */
; 127  : 
; 128  : 		// Extra paranoia on aligned allocation/deallocation
; 129  : 		if (_Ptr_container >= _Ptr_user)

  0012d	48 3b c7	 cmp	 rax, rdi
  00130	73 1a		 jae	 SHORT $_Invalid_parameter$149
  00132	48 2b f8	 sub	 rdi, rax
  00135	48 83 ef 08	 sub	 rdi, 8
  00139	48 83 ff 1f	 cmp	 rdi, 31
  0013d	77 0d		 ja	 SHORT $_Invalid_parameter$149

; 130  : 			{
; 131  : 			goto _Invalid_parameter;
; 132  : 			}
; 133  : 
; 134  :  #ifdef _DEBUG
; 135  : 		if (2 * sizeof(void *) > _Ptr_user - _Ptr_container)
; 136  :  #else /* _DEBUG */
; 137  : 		if (sizeof(void *) > _Ptr_user - _Ptr_container)
; 138  :  #endif /* _DEBUG */
; 139  : 			{
; 140  : 			goto _Invalid_parameter;
; 141  : 			}
; 142  : 
; 143  : 		if (_Ptr_user - _Ptr_container > _NON_USER_SIZE)
; 144  : 			{
; 145  : 			goto _Invalid_parameter;
; 146  : 			}
; 147  : 
; 148  : 		_Ptr = reinterpret_cast<void *>(_Ptr_container);

  0013f	48 8b f8	 mov	 rdi, rax
$LN108@Reallocate:

; 149  : 		}
; 150  : 
; 151  : 	::operator delete(_Ptr);

  00142	48 8b cf	 mov	 rcx, rdi
  00145	e8 00 00 00 00	 call	 ??3@YAXPEAX@Z		; operator delete
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3666 : 		else

  0014a	eb 1c		 jmp	 SHORT $LN146@Reallocate
$_Invalid_parameter$149:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 155  : 	_SCL_SECURE_INVALID_ARGUMENT_NO_ASSERT;

  0014c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__invalid_parameter_noinfo_noreturn
  00152	cc		 int	 3
$LN3@Reallocate:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00153	e8 00 00 00 00	 call	 memcpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  00158	4d 8d 45 01	 lea	 r8, QWORD PTR [r13+1]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  0015c	49 8b d6	 mov	 rdx, r14
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2549 : 			_Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);

  0015f	48 8d 0c 1e	 lea	 rcx, QWORD PTR [rsi+rbx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 486  : 		return ((_Elem *)_CSTD memcpy(_First1, _First2, _Count));

  00163	e8 00 00 00 00	 call	 memcpy
$LN146@Reallocate:
  00168	48 8b 6c 24 70	 mov	 rbp, QWORD PTR [rsp+112]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3672 : 		return (*this);

  0016d	49 8b c6	 mov	 rax, r14
  00170	48 8b 7c 24 28	 mov	 rdi, QWORD PTR [rsp+40]
  00175	4c 8b 7c 24 20	 mov	 r15, QWORD PTR [rsp+32]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xmemory0

; 855  : 		::new (const_cast<void *>(static_cast<const volatile void *>(_Ptr)))

  0017a	49 89 36	 mov	 QWORD PTR [r14], rsi
  0017d	48 8b 74 24 30	 mov	 rsi, QWORD PTR [rsp+48]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 3673 : 		}

  00182	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00186	41 5e		 pop	 r14
  00188	41 5d		 pop	 r13
  0018a	41 5c		 pop	 r12
  0018c	5b		 pop	 rbx
  0018d	c3		 ret	 0
$LN147@Reallocate:

; 3646 : 			{
; 3647 : 			_Xlen();	// result too long

  0018e	e8 00 00 00 00	 call	 ?_Xlen@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@SAXXZ ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Xlen
  00193	cc		 int	 3
$LN145@Reallocate:
??$_Reallocate_grow_by@V<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD_K@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV01@_KV<lambda_f3a66ab6a0570788f31503db83886f49>@@_KPEBD2@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::_Reallocate_grow_by<<lambda_f3a66ab6a0570788f31503db83886f49>,unsigned __int64,char const * __ptr64,unsigned __int64>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry, COMDAT
$LN12:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 100  : 			if (_Myistr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 100  : 			if (_Myistr.rdbuf() != 0)

  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN11@sentry

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN11@sentry:
  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::~sentry
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits, COMDAT

; 3508 : 		{	// return a random value

$LN25:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 74 24 10	 mov	 QWORD PTR [rsp+16], rsi
  0000a	57		 push	 rdi
  0000b	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 3509 : 		_Udiff _Ret = 0;

  0000f	33 db		 xor	 ebx, ebx
  00011	48 8b f9	 mov	 rdi, rcx

; 3510 : 
; 3511 : 		for (size_t _Num = 0; _Num < CHAR_BIT * sizeof (_Udiff);

  00014	8b f3		 mov	 esi, ebx
  00016	66 66 0f 1f 84
	00 00 00 00 00	 npad	 10
$LL4@Get_all_bi:

; 3512 : 			_Num += _Bits)
; 3513 : 			{	// don't mask away any bits
; 3514 : 			_Ret <<= _Bits - 1;	// avoid full shift

  00020	0f b6 4f 08	 movzx	 ecx, BYTE PTR [rdi+8]
  00024	80 c1 ff	 add	 cl, 255			; 000000ffH
  00027	d3 e3		 shl	 ebx, cl

; 3515 : 			_Ret <<= 1;

  00029	03 db		 add	 ebx, ebx
  0002b	0f 1f 44 00 00	 npad	 5
$LL7@Get_all_bi:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00030	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00036	3b 47 10	 cmp	 eax, DWORD PTR [rdi+16]
  00039	77 f5		 ja	 SHORT $LL7@Get_all_bi

; 3516 : 			_Ret |= _Get_bits();

  0003b	48 03 77 08	 add	 rsi, QWORD PTR [rdi+8]
  0003f	0b d8		 or	 ebx, eax
  00041	48 83 fe 20	 cmp	 rsi, 32			; 00000020H
  00045	72 d9		 jb	 SHORT $LL4@Get_all_bi

; 3517 : 			}
; 3518 : 
; 3519 : 		return (_Ret);
; 3520 : 		}

  00047	48 8b 74 24 38	 mov	 rsi, QWORD PTR [rsp+56]
  0004c	8b c3		 mov	 eax, ebx
  0004e	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  00053	48 83 c4 20	 add	 rsp, 32			; 00000020H
  00057	5f		 pop	 rdi
  00058	c3		 ret	 0
?_Get_all_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_all_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z
_TEXT	SEGMENT
this$ = 48
_Index$ = 56
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::operator(), COMDAT

; 3484 : 		{	// adapt _Urng closed range to [0, _Index)

$LN33:
  00000	48 89 5c 24 08	 mov	 QWORD PTR [rsp+8], rbx
  00005	48 89 6c 24 10	 mov	 QWORD PTR [rsp+16], rbp
  0000a	48 89 74 24 18	 mov	 QWORD PTR [rsp+24], rsi
  0000f	48 89 7c 24 20	 mov	 QWORD PTR [rsp+32], rdi
  00014	41 56		 push	 r14
  00016	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  0001a	44 8b f2	 mov	 r14d, edx
  0001d	8d 6a ff	 lea	 ebp, DWORD PTR [rdx-1]
  00020	48 8b f9	 mov	 rdi, rcx
$LL2@operator:

; 3485 : 		for (; ; )
; 3486 : 			{	// try a sample random value
; 3487 : 			_Udiff _Ret = 0;	// random bits

  00023	33 db		 xor	 ebx, ebx

; 3488 : 			_Udiff _Mask = 0;	// 2^N - 1, _Ret is within [0, _Mask]

  00025	33 f6		 xor	 esi, esi

; 3489 : 
; 3490 : 			while (_Mask < _Udiff(_Index - 1))

  00027	85 ed		 test	 ebp, ebp
  00029	74 37		 je	 SHORT $LN6@operator
  0002b	0f 1f 44 00 00	 npad	 5
$LL5@operator:

; 3491 : 				{	// need more random bits
; 3492 : 				_Ret <<= _Bits - 1;	// avoid full shift

  00030	0f b6 4f 08	 movzx	 ecx, BYTE PTR [rdi+8]
  00034	80 c1 ff	 add	 cl, 255			; 000000ffH
  00037	d3 e3		 shl	 ebx, cl

; 3493 : 				_Ret <<= 1;

  00039	03 db		 add	 ebx, ebx
  0003b	0f 1f 44 00 00	 npad	 5
$LL11@operator:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00040	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
  00046	8b c8		 mov	 ecx, eax
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00048	8b 47 10	 mov	 eax, DWORD PTR [rdi+16]
  0004b	3b c8		 cmp	 ecx, eax
  0004d	77 f1		 ja	 SHORT $LL11@operator

; 3494 : 				_Ret |= _Get_bits();
; 3495 : 				_Mask <<= _Bits - 1;	// avoid full shift

  0004f	0b d9		 or	 ebx, ecx
  00051	0f b6 4f 08	 movzx	 ecx, BYTE PTR [rdi+8]
  00055	80 c1 ff	 add	 cl, 255			; 000000ffH
  00058	d3 e6		 shl	 esi, cl

; 3496 : 				_Mask <<= 1;

  0005a	03 f6		 add	 esi, esi

; 3497 : 				_Mask |= _Bmask;

  0005c	0b f0		 or	 esi, eax
  0005e	3b f5		 cmp	 esi, ebp
  00060	72 ce		 jb	 SHORT $LL5@operator
$LN6@operator:

; 3498 : 				}
; 3499 : 
; 3500 : 			// _Ret is [0, _Mask], _Index - 1 <= _Mask, return if unbiased
; 3501 : 			if (_Ret / _Index < _Mask / _Index
; 3502 : 				|| _Mask % _Index == _Udiff(_Index - 1))

  00062	33 d2		 xor	 edx, edx
  00064	8b c6		 mov	 eax, esi
  00066	41 f7 f6	 div	 r14d
  00069	8b c8		 mov	 ecx, eax
  0006b	44 8b c2	 mov	 r8d, edx
  0006e	33 d2		 xor	 edx, edx
  00070	8b c3		 mov	 eax, ebx
  00072	41 f7 f6	 div	 r14d
  00075	3b c1		 cmp	 eax, ecx
  00077	72 05		 jb	 SHORT $LN25@operator
  00079	44 3b c5	 cmp	 r8d, ebp
  0007c	75 a5		 jne	 SHORT $LL2@operator
$LN25@operator:

; 3503 : 				return (_Ret % _Index);
; 3504 : 			}
; 3505 : 		}

  0007e	48 8b 6c 24 38	 mov	 rbp, QWORD PTR [rsp+56]
  00083	8b c3		 mov	 eax, ebx
  00085	48 8b 5c 24 30	 mov	 rbx, QWORD PTR [rsp+48]
  0008a	33 d2		 xor	 edx, edx
  0008c	48 8b 74 24 40	 mov	 rsi, QWORD PTR [rsp+64]
  00091	48 8b 7c 24 48	 mov	 rdi, QWORD PTR [rsp+72]
  00096	41 f7 f6	 div	 r14d
  00099	8b c2		 mov	 eax, edx
  0009b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0009f	41 5e		 pop	 r14
  000a1	c3		 ret	 0
??R?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAAII@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::operator()
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z
_TEXT	SEGMENT
this$ = 8
_Func$ = 16
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>, COMDAT

; 3477 : 		: _Ref(_Func), _Bits(CHAR_BIT * sizeof (_Udiff)), _Bmask(_Udiff(-1))

  00000	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 3479 : 		for (; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
; 3480 : 			--_Bits;
; 3481 : 		}

  00003	48 8b c1	 mov	 rax, rcx
  00006	48 c7 41 08 20
	00 00 00	 mov	 QWORD PTR [rcx+8], 32	; 00000020H
  0000e	c7 41 10 ff ff
	ff ff		 mov	 DWORD PTR [rcx+16], -1	; ffffffffH
  00015	c3		 ret	 0
??0?$_Rng_from_urng@IVrandom_device@std@@@std@@QEAA@AEAVrandom_device@1@@Z ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Rng_from_urng<unsigned int,std::random_device>
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAII@Z
_TEXT	SEGMENT
_Uval$ = 8
?_Adjust@?$uniform_int@H@std@@CAII@Z PROC		; std::uniform_int<int>::_Adjust, COMDAT

; 2370 : 		return (_Adjust(_Uval, is_signed<_Ty>()));

  00000	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H
  00005	03 c1		 add	 eax, ecx

; 2371 : 		}

  00007	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAII@Z ENDP		; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ
_TEXT	SEGMENT
this$ = 8
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool, COMDAT

; 122  : 			return (_Ok);

  00000	0f b6 41 08	 movzx	 eax, BYTE PTR [rcx+8]

; 123  : 			}

  00004	c3		 ret	 0
??Bsentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEBA_NXZ ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::operator bool
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z
_TEXT	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z PROC ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry, COMDAT

; 116  : 			{	// construct locking and calling _Ipfx

$LN11:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	57		 push	 rdi
  00006	48 83 ec 30	 sub	 rsp, 48			; 00000030H
  0000a	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2
  00013	48 89 5c 24 48	 mov	 QWORD PTR [rsp+72], rbx
  00018	41 0f b6 f8	 movzx	 edi, r8b
  0001c	48 8b d9	 mov	 rbx, rcx

; 92   : 			: _Myistr(_Istr)

  0001f	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 94   : 			if (_Myistr.rdbuf() != 0)

  00022	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00025	4c 63 48 04	 movsxd	 r9, DWORD PTR [rax+4]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\ios

; 91   : 		return (_Mystrbuf);

  00029	49 8b 4c 11 48	 mov	 rcx, QWORD PTR [r9+rdx+72]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream

; 94   : 			if (_Myistr.rdbuf() != 0)

  0002e	48 85 c9	 test	 rcx, rcx
  00031	74 07		 je	 SHORT $LN5@sentry

; 95   : 				_Myistr.rdbuf()->_Lock();

  00033	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00036	ff 50 08	 call	 QWORD PTR [rax+8]
  00039	90		 npad	 1
$LN5@sentry:

; 117  : 			_Ok = this->_Myistr._Ipfx(_Noskip);

  0003a	40 0f b6 d7	 movzx	 edx, dil
  0003e	48 8b 0b	 mov	 rcx, QWORD PTR [rbx]
  00041	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Ipfx@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA_N_N@Z
  00047	88 43 08	 mov	 BYTE PTR [rbx+8], al

; 118  : 			}

  0004a	48 8b c3	 mov	 rax, rbx
  0004d	48 8b 5c 24 48	 mov	 rbx, QWORD PTR [rsp+72]
  00052	48 83 c4 30	 add	 rsp, 48			; 00000030H
  00056	5f		 pop	 rdi
  00057	c3		 ret	 0
??0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::sentry::sentry
_TEXT	ENDS
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
;	COMDAT text$x
text$x	SEGMENT
$T3 = 32
this$ = 64
_Istr$ = 72
_Noskip$ = 80
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA PROC ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
  00000	48 8b 8a 40 00
	00 00		 mov	 rcx, QWORD PTR this$[rdx]
  00007	e9 00 00 00 00	 jmp	 ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
?dtor$0@?0???0sentry@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@_N@Z@4HA ENDP ; `std::basic_istream<char,std::char_traits<char> >::sentry::sentry'::`1'::dtor$0
text$x	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ
_TEXT	SEGMENT
$T3 = 32
this$ = 64
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base, COMDAT

; 99   : 			{	// destroy after unlocking

$LN8:
  00000	48 83 ec 38	 sub	 rsp, 56			; 00000038H
  00004	48 c7 44 24 20
	fe ff ff ff	 mov	 QWORD PTR $T3[rsp], -2

; 100  : 			if (_Myistr.rdbuf() != 0)

  0000d	48 8b 11	 mov	 rdx, QWORD PTR [rcx]
  00010	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  00013	48 63 48 04	 movsxd	 rcx, DWORD PTR [rax+4]
  00017	48 8b 4c 11 48	 mov	 rcx, QWORD PTR [rcx+rdx+72]
  0001c	48 85 c9	 test	 rcx, rcx
  0001f	74 07		 je	 SHORT $LN2@Sentry_bas

; 101  : 				_Myistr.rdbuf()->_Unlock();

  00021	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00024	ff 50 10	 call	 QWORD PTR [rax+16]
  00027	90		 npad	 1
$LN2@Sentry_bas:

; 102  : 			}

  00028	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0002c	c3		 ret	 0
??1_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@XZ ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::~_Sentry_base
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring
;	COMDAT ?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z
_TEXT	SEGMENT
this$ = 8
_Off$dead$ = 16
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z PROC ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase, COMDAT

; 1617 : 		return (_BUF_SIZE <= _Myres);

  00000	48 83 79 18 10	 cmp	 QWORD PTR [rcx+24], 16

; 3692 : 		_Traits::assign(_My_data._Myptr()[_My_data._Mysize = _Newsize], _Elem());

  00005	48 c7 41 10 00
	00 00 00	 mov	 QWORD PTR [rcx+16], 0

; 1596 : 		if (_Large_string_engaged())

  0000d	72 0a		 jb	 SHORT $LN31@erase
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstddef

; 265  : 	return (_Ptr);

  0000f	48 8b 01	 mov	 rax, QWORD PTR [rcx]
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00012	c6 00 00	 mov	 BYTE PTR [rax], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2610 : 		return (*this);

  00015	48 8b c1	 mov	 rax, rcx

; 2611 : 		}

  00018	c3		 ret	 0
$LN31@erase:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\iosfwd

; 517  : 		_Left = _Right;

  00019	c6 01 00	 mov	 BYTE PTR [rcx], 0
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xstring

; 2610 : 		return (*this);

  0001c	48 8b c1	 mov	 rax, rcx

; 2611 : 		}

  0001f	c3		 ret	 0
?erase@?$basic_string@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@QEAAAEAV12@_K@Z ENDP ; std::basic_string<char,std::char_traits<char>,std::allocator<char> >::erase
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility
;	COMDAT ?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ
_TEXT	SEGMENT
this$ = 48
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ PROC ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits, COMDAT

; 3527 : 		{	// return a random value within [0, _Bmask]

$LN17:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H
  00006	48 8b d9	 mov	 rbx, rcx
  00009	0f 1f 80 00 00
	00 00		 npad	 7
$LL2@Get_bits:
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random

; 6442 : 		return (_Random_device());

  00010	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_?_Random_device@std@@YAIXZ
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\xutility

; 3532 : 			if (_Val <= _Bmask)

  00016	3b 43 10	 cmp	 eax, DWORD PTR [rbx+16]
  00019	77 f5		 ja	 SHORT $LL2@Get_bits

; 3533 : 				return (_Val);
; 3534 : 			}
; 3535 : 		}

  0001b	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0001f	5b		 pop	 rbx
  00020	c3		 ret	 0
?_Get_bits@?$_Rng_from_urng@IVrandom_device@std@@@std@@AEAAIXZ ENDP ; std::_Rng_from_urng<unsigned int,std::random_device>::_Get_bits
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\random
;	COMDAT ?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z
_TEXT	SEGMENT
_Uval$ = 8
__formal$dead$ = 16
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z PROC ; std::uniform_int<int>::_Adjust, COMDAT

; 2375 : 		const _Uty _Adjuster = (_Uty(-1) >> 1) + 1;	// 2^(N-1)
; 2376 : 
; 2377 : 		if (_Uval < _Adjuster)

  00000	b8 00 00 00 80	 mov	 eax, -2147483648	; ffffffff80000000H

; 2378 : 			return (_Uval + _Adjuster);
; 2379 : 		else
; 2380 : 			return (_Uval - _Adjuster);

  00005	03 c1		 add	 eax, ecx

; 2381 : 		}

  00007	c3		 ret	 0
?_Adjust@?$uniform_int@H@std@@CAIIU?$integral_constant@_N$00@2@@Z ENDP ; std::uniform_int<int>::_Adjust
_TEXT	ENDS
; Function compile flags: /Ogtpy
; File f:\program files (x86)\microsoft visual studio\2017\enterprise\vc\tools\msvc\14.11.25503\include\istream
;	COMDAT ??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z
_TEXT	SEGMENT
this$ = 48
_Istr$ = 56
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z PROC ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base, COMDAT

; 93   : 			{	// lock the stream buffer, if there

$LN10:
  00000	40 53		 push	 rbx
  00002	48 83 ec 20	 sub	 rsp, 32			; 00000020H

; 92   : 			: _Myistr(_Istr)

  00006	48 89 11	 mov	 QWORD PTR [rcx], rdx

; 93   : 			{	// lock the stream buffer, if there

  00009	48 8b d9	 mov	 rbx, rcx

; 94   : 			if (_Myistr.rdbuf() != 0)

  0000c	48 8b 02	 mov	 rax, QWORD PTR [rdx]
  0000f	4c 63 40 04	 movsxd	 r8, DWORD PTR [rax+4]
  00013	49 8b 4c 10 48	 mov	 rcx, QWORD PTR [r8+rdx+72]
  00018	48 85 c9	 test	 rcx, rcx
  0001b	74 06		 je	 SHORT $LN8@Sentry_bas

; 95   : 				_Myistr.rdbuf()->_Lock();

  0001d	48 8b 01	 mov	 rax, QWORD PTR [rcx]
  00020	ff 50 08	 call	 QWORD PTR [rax+8]
$LN8@Sentry_bas:

; 96   : 			}

  00023	48 8b c3	 mov	 rax, rbx
  00026	48 83 c4 20	 add	 rsp, 32			; 00000020H
  0002a	5b		 pop	 rbx
  0002b	c3		 ret	 0
??0_Sentry_base@?$basic_istream@DU?$char_traits@D@std@@@std@@QEAA@AEAV12@@Z ENDP ; std::basic_istream<char,std::char_traits<char> >::_Sentry_base::_Sentry_base
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@UEAAPEAXI@Z
??_E?$basic_stringstream@DU?$char_traits@D@std@@V?$allocator@D@2@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_stringstream<char,std::char_traits<char>,std::allocator<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ifstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ifstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_ofstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_ofstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
; Function compile flags: /Odspy
;	COMDAT ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z
_TEXT	SEGMENT
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z PROC ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor', COMDAT
  00000	48 63 41 fc	 movsxd	 rax, DWORD PTR [rcx-4]
  00004	48 2b c8	 sub	 rcx, rax
  00007	e9 00 00 00 00	 jmp	 ??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@UEAAPEAXI@Z
??_E?$basic_fstream@DU?$char_traits@D@std@@@std@@$4PPPPPPPM@A@EAAPEAXI@Z ENDP ; std::basic_fstream<char,std::char_traits<char> >::`vector deleting destructor'
_TEXT	ENDS
END
